<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS-2</title>
    <url>/2023/01/12/%E5%89%8D%E7%AB%AF/CSS-2/</url>
    <content><![CDATA[<h1 id="css"><a class="markdownIt-Anchor" href="#css"></a> CSS</h1>
<h2 id="css字体"><a class="markdownIt-Anchor" href="#css字体"></a> CSS字体</h2>
<h3 id="字体大小font-size"><a class="markdownIt-Anchor" href="#字体大小font-size"></a> 字体大小font-size</h3>
<h4 id="属性值"><a class="markdownIt-Anchor" href="#属性值"></a> 属性值</h4>
<ul>
<li>取值：数字+单位</li>
<li>谷歌浏览器默认文字大小是16px
<ul>
<li>单位需要设置，否则无效</li>
</ul>
</li>
<li>我们不能通过调整字体的大小使得一些文字看上去像标题
<ul>
<li>标题需要通过<code>&lt;h1&gt;-&lt;h6&gt;</code>的标签来表示</li>
<li>段落通过<code>&lt;p&gt;</code>标签来表示</li>
</ul>
</li>
</ul>
<h4 id="单位"><a class="markdownIt-Anchor" href="#单位"></a> 单位</h4>
<ul>
<li>px
<ul>
<li>控制的是文本的绝对大小</li>
<li>设置文字的大小与像素，完全控制文字的大小</li>
<li>默认是16px</li>
</ul>
</li>
<li>em
<ul>
<li>控制的是文本的相对大小</li>
<li>1em和当前的字体大小相等，默认是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>e</mi><mi>m</mi><mo>=</mo><mn>16</mn><mi>p</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">1em=16px</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord mathnormal">p</span><span class="mord mathnormal">x</span></span></span></span></li>
</ul>
</li>
<li>百分比
<ul>
<li>控制的是文字的相对大小</li>
<li>100%和当前的字体大小相等</li>
</ul>
</li>
</ul>
<h3 id="字体粗细font-weight"><a class="markdownIt-Anchor" href="#字体粗细font-weight"></a> 字体粗细font-weight</h3>
<h4 id="属性值-2"><a class="markdownIt-Anchor" href="#属性值-2"></a> 属性值</h4>
<ul>
<li>关键字
<ul>
<li>正常：normal(400)</li>
<li>加粗：bold(700)</li>
<li>更粗：bolder(900)</li>
<li>更细：lighter</li>
</ul>
</li>
<li>数字
<ul>
<li>100～900的整百数</li>
</ul>
</li>
<li>并不是所有的字体都提供了九种粗细，因此部分取值在页面中的现实没有变化</li>
</ul>
<h3 id="字体样式font-style"><a class="markdownIt-Anchor" href="#字体样式font-style"></a> 字体样式font-style</h3>
<h4 id="属性值-3"><a class="markdownIt-Anchor" href="#属性值-3"></a> 属性值</h4>
<ul>
<li>关键字
<ul>
<li>normal：显示一个标准的字体样式</li>
<li>italic：显示一个倾斜的字体样式</li>
</ul>
</li>
<li>效果等价于<code>&lt;em&gt;</code>以及<code>&lt;i&gt;</code>标签</li>
</ul>
<h3 id="字体类型font-family"><a class="markdownIt-Anchor" href="#字体类型font-family"></a> 字体类型font-family</h3>
<h4 id="属性值-4"><a class="markdownIt-Anchor" href="#属性值-4"></a> 属性值</h4>
<ul>
<li>具体的字体名称</li>
<li>字体1，字体2，字体3…，字体系列</li>
<li>常见的字体包括：微软雅黑、黑体、宋体等等</li>
<li>常见的字体系列：<code>sans-serif</code>、<code>serif</code>以及<code>monospace</code>
<ul>
<li>无衬线字体<code>sans-serif</code>
<ul>
<li>特点：文字笔画粗细均匀，且首尾无装饰</li>
<li>常用于网页设计</li>
<li>常见的字体：微软雅黑、黑体</li>
</ul>
</li>
<li>衬线字体<code>serif</code>
<ul>
<li>文字笔画粗细不均匀。并且有笔锋等装饰</li>
<li>常用语书籍报刊的印刷</li>
<li>常见的字体：宋体、楷体</li>
</ul>
</li>
<li>等宽字体<code>monospace</code>
<ul>
<li>每个字母或者文字的宽度相同</li>
<li>常用于代码的编写</li>
<li>常见字体：Consolas</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4>
<ul>
<li>渲染规则
<ul>
<li>从左往右按照顺序查找，如果电脑中未安装该字体，则显示下一个字体</li>
<li>如果都不支持，会显示最后字体系列中的默认字体</li>
</ul>
</li>
<li>如果字体名称中存在多个单词，则使用<strong>引号</strong>将其包裹</li>
<li>最后一项的字体序列不需要引号包裹</li>
<li>尽量使用系统常见的自带字体，保证不同用户浏览网页时都能正常显示</li>
</ul>
<h3 id="字体类型font属性连写"><a class="markdownIt-Anchor" href="#字体类型font属性连写"></a> 字体类型font属性连写</h3>
<h4 id="复合属性"><a class="markdownIt-Anchor" href="#复合属性"></a> 复合属性</h4>
<ul>
<li>一个属性冒号可以写多个值</li>
</ul>
<h4 id="font符合属性"><a class="markdownIt-Anchor" href="#font符合属性"></a> font符合属性</h4>
<ul>
<li>font后可以跟四个属性，顺序分别为：<code>style</code> <code>weight</code> <code>size</code> <code>family</code></li>
<li>以上顺序不可以错乱</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#id</span>&#123;</span><br><span class="line">  	<span class="comment">/*对id为id的标签，设置其字体 样式为倾斜 粗细为加粗 大小为32px 字体为苹方*/</span></span><br><span class="line">		<span class="attribute">font</span>: italic bold <span class="number">32px</span> <span class="string">&quot;Apple Braille&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>省略
<ul>
<li>只能省略样式和粗细，如果省略了相当于设置为默认值</li>
</ul>
</li>
<li>同时设置单独和连写形式
<ul>
<li>单独的样式要么写在连写的下面（可能会发生样式的层叠）</li>
<li>要么写在连写的里面</li>
</ul>
</li>
</ul>
<h3 id="样式的层叠问题"><a class="markdownIt-Anchor" href="#样式的层叠问题"></a> 样式的层叠问题</h3>
<ul>
<li>当给同一个标签设置了相同属性，此时样式会<strong>层叠</strong>（覆盖）</li>
<li>写在最后的样式会生效</li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-1</title>
    <url>/2023/01/11/%E5%89%8D%E7%AB%AF/CSS-1/</url>
    <content><![CDATA[<h1 id="css"><a class="markdownIt-Anchor" href="#css"></a> CSS</h1>
<h2 id="基础认识css"><a class="markdownIt-Anchor" href="#基础认识css"></a> 基础认识CSS</h2>
<ul>
<li>层叠样式表<em>Cascading style sheets</em></li>
<li>作用：给页面中的HTML标签设置样式</li>
<li><strong>样式</strong>
<ul>
<li>样式定义如何显示一个HTML元素</li>
<li>样式通常存储在<u>样式表</u>中</li>
<li>外部样式表可以极大的提升工作效率</li>
<li>外部样式表通常存储在CSS文件中</li>
<li>多个样式定义可以层叠为一个</li>
</ul>
</li>
</ul>
<h2 id="语法规则"><a class="markdownIt-Anchor" href="#语法规则"></a> 语法规则</h2>
<h3 id="css的基本组成"><a class="markdownIt-Anchor" href="#css的基本组成"></a> CSS的基本组成</h3>
<ul>
<li>CSS规则主要由两部分组成：<strong>选择器</strong>，以及一条或者多条的<strong>声明</strong>
<ul>
<li>选择器：用于选择需要改变样式的元素</li>
<li>每条声明由一个属性和一个值组成</li>
<li>属性是需要设置的样式属性，每个属性有一个值，属性和值用<strong>冒号</strong>分开</li>
<li>每条属性之间用<strong>分号</strong>隔开
<ul>
<li>在HTML里一个标签的不同属性用空格隔开即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="css的注释"><a class="markdownIt-Anchor" href="#css的注释"></a> CSS的注释</h3>
<ul>
<li>使用<code>/* */</code>作为注释</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这是一条CSS的注释*/</span></span><br></pre></td></tr></table></figure>
<h3 id="css的引入方式"><a class="markdownIt-Anchor" href="#css的引入方式"></a> CSS的引入方式</h3>
<ul>
<li>CSS的引入方式一共分为<em>3</em>种，包括内嵌式、外联式、行内式</li>
</ul>
<h4 id="内嵌式"><a class="markdownIt-Anchor" href="#内嵌式"></a> 内嵌式</h4>
<ul>
<li>CSS写在<code>style</code>标签中，将CSS内嵌在HTML中</li>
<li><code>style</code>标签虽然可以写在页面的任意位置，但是通常约定写在<code>head</code>标签中</li>
</ul>
<h4 id="外联式"><a class="markdownIt-Anchor" href="#外联式"></a> 外联式</h4>
<ul>
<li>CSS写在一个单独的<code>.css</code>文件中</li>
<li>需要通过<code>link</code>标签在网页种引入
<ul>
<li><code>link</code>标签也一般写在<code>head</code>标签中</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;CascadingStyleSheets.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>rel</code>属性指的是HTML文件和需要链接的文件的关系</p>
<ul>
<li>这里引入的CSS文件是HTML文件的央视文件</li>
</ul>
</li>
<li>
<p><code>herf</code>属性指的是引入文件的链接</p>
</li>
<li>
<p>在<code>.css</code>文件中直接写CSS语句即可</p>
</li>
</ul>
<h4 id="行内式"><a class="markdownIt-Anchor" href="#行内式"></a> 行内式</h4>
<ul>
<li>CSS写在标签的<code>style</code>属性中</li>
</ul>
<h4 id="三种方式的比较"><a class="markdownIt-Anchor" href="#三种方式的比较"></a> 三种方式的比较</h4>
<table>
    <tr>
        <th style="font-weight: bolder;">引入方式</th>
        <th style="font-weight: bolder;">书写位置</th>
        <th style="font-weight: bolder;">作用范围</th>
        <th style="font-weight: bolder;">使用场景</th>
    </tr>
    <tr>
        <td>内嵌式</td>
        <td>HTML文件的style标签中</td>
        <td>当前页面</td>
        <td>小案例中</td>
    </tr>
    <tr>
        <td>外联式</td>
        <td>单独创建一个.css文件，用link标签进行链接</td>
        <td>可以作用于所有与之链接的HTMl文件</td>
        <td>项目中</td>
    </tr>
    <tr>
        <td>内行式</td>
        <td>写在标签的style属性中</td>
        <td>当前标签</td>
        <td>配合js进行使用</td>
    </tr>
</table>
<h2 id="基础选择器"><a class="markdownIt-Anchor" href="#基础选择器"></a> 基础选择器</h2>
<ul>
<li>选择器用于选择需要改变样式的元素</li>
</ul>
<h3 id="标签选择器"><a class="markdownIt-Anchor" href="#标签选择器"></a> 标签选择器</h3>
<h4 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h4>
<ul>
<li>标签名 {属性名：属性值;}</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">th</span>&#123;</span><br><span class="line">		<span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h4>
<ul>
<li>通过标<strong>签名找</strong>到页面中<strong>所有</strong>的这列标签，设置格式</li>
<li>标签选择器选择的是<strong>一类标签</strong>，而不是单独的一个</li>
<li>标签选择器无论嵌套的关系有多深，都能找到对应的标签</li>
</ul>
<h3 id="类选择器"><a class="markdownIt-Anchor" href="#类选择器"></a> 类选择器</h3>
<h4 id="结构-2"><a class="markdownIt-Anchor" href="#结构-2"></a> 结构</h4>
<ul>
<li>.类名{属性名：属性值;}</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.name</span>&#123;</span><br><span class="line">  	<span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类名需要自己定义，类名前有一个点</li>
</ul>
<h4 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2"></a> 作用</h4>
<ul>
<li>所有标签上都有<code>class</code>属性，<code>class</code>属性的属性值称为类名</li>
<li>类名可以由数字、字母、下划线、中划线组成，但不能以数字或者中划线开头</li>
<li>一个标签可以同时有多个类名，类名之间通过空格隔开
<ul>
<li>多个类名都写在<code>class</code>属性中</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;color size&quot;</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>类名可以重复，一个类选择器可以同时选中多个标签</li>
</ul>
<h3 id="id选择器"><a class="markdownIt-Anchor" href="#id选择器"></a> id选择器</h3>
<h4 id="结构-3"><a class="markdownIt-Anchor" href="#结构-3"></a> 结构</h4>
<ul>
<li>#id属性值{属性名：属性值;}</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#name</span>&#123;</span><br><span class="line">  	<span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>id值需要自己定义，id值之前需要一个#</li>
</ul>
<h4 id="作用-3"><a class="markdownIt-Anchor" href="#作用-3"></a> 作用</h4>
<ul>
<li>通过id值，找到页面中带有这个id值的标签，设置样式</li>
<li>所有的标签都有id属性</li>
<li>id属性在一个页面中是唯一的，不可重复</li>
<li>一个标签上只能有一个id属性
<ul>
<li>但是一个标签上可以有多个类</li>
</ul>
</li>
<li>一个id选择器一次只能选择一个标签</li>
</ul>
<h3 id="通配符选择器"><a class="markdownIt-Anchor" href="#通配符选择器"></a> 通配符选择器</h3>
<h4 id="结构-4"><a class="markdownIt-Anchor" href="#结构-4"></a> 结构</h4>
<ul>
<li>*{属性名：属性值;}</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">  	<span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="作用-4"><a class="markdownIt-Anchor" href="#作用-4"></a> 作用</h4>
<ul>
<li>找到页面中所有的标签，设置样式</li>
<li>只有在极少数情况下才会使用
<ul>
<li>可以用于清楚所有标签默认的<code>margin</code>和<code>padding</code>（间距）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建博客过程中，4000端口被占用</title>
    <url>/2022/11/23/Hexo/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C4000%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/</url>
    <content><![CDATA[<h1 id="hexo搭建博客过程中4000端口被占用"><a class="markdownIt-Anchor" href="#hexo搭建博客过程中4000端口被占用"></a> hexo搭建博客过程中，4000端口被占用</h1>
<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2>
<p>当我今天准备上传新的博客的时候，我先使用hexo s命令打算在本地先预览一下，然后却报错了，系统提示我4000端口被占用了。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8f6m4a6xvj30ni0fagp0.jpg" alt="" /></p>
<h2 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决</h2>
<p>我们知道，hexo在本地使用的是4000端口，那么解决这个问题就有两种方法</p>
<ul>
<li>更改hexo使用的端口</li>
<li>杀掉正在占用4000端口的其他进程</li>
</ul>
<p>针对第一种方法，我在hexo的配置文件中没有找到相关端口的配置，所以我放弃了这种方法</p>
<ul>
<li>
<p>在Mac下，查看端口的占用情况使用的命令如下</p>
<ul>
<li><code>sudo lsof -i tcp:端口号</code></li>
<li>其中的意思是：list open files，用于查看打开的文件以及相关联进程信息的工具</li>
<li>这里说的“文件”不单指一般的文件，还包括目录、socket套接字、设备文件和命名管道</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8f6uvj57yj30nk03774i.jpg" alt="" /></p>
</li>
<li>
<p>然后杀掉这个进程即可，杀掉进程的命令如下</p>
<ul>
<li><code>sudo kill -9 PID</code></li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8f6wjfcbjj30nj07sq3q.jpg" alt="" /></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML标签</title>
    <url>/2022/12/30/%E5%89%8D%E7%AB%AF/HTML%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="html标签"><a class="markdownIt-Anchor" href="#html标签"></a> HTML标签</h1>
<h2 id="排版标签"><a class="markdownIt-Anchor" href="#排版标签"></a> 排版标签</h2>
<h3 id="标题标签heading"><a class="markdownIt-Anchor" href="#标题标签heading"></a> 标题标签（Heading）</h3>
<h4 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 场景</h4>
<ul>
<li>在新闻和文章的页面中，都离不开标题，用来突出显示文章主题</li>
</ul>
<h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4>
<ul>
<li>h系列标签</li>
<li>HTML标题是通过<code>&lt;h1&gt; - &lt;h6&gt;</code> 标签来定义的</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>1级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>2级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>3级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>4级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>5级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>6级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1～6级标题，重要程度依次递减
<ul>
<li>标题独占一行</li>
<li>不同的等级文字加粗程度不同、大小不同</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/9849fe.png" alt="" /></p>
<h3 id="段落标签"><a class="markdownIt-Anchor" href="#段落标签"></a> 段落标签</h3>
<h4 id="场景-2"><a class="markdownIt-Anchor" href="#场景-2"></a> 场景</h4>
<ul>
<li>在文章的页面中，用于分段显示内容</li>
</ul>
<h4 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h4>
<ul>
<li>HTML 段落是通过标签<code>&lt;p&gt;</code>来定义</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>段落之间存在间隙</li>
<li>一个段落独占一行</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是另一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>测试 测试 测试 测试 测试 测试 测试 测试 测试 测试 测试 测试 测试 测试 测试 测试 测试 测试 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/vxxujn.png" alt="" /></p>
<h4 id="webstorm代码自动换行"><a class="markdownIt-Anchor" href="#webstorm代码自动换行"></a> WebStorm代码自动换行</h4>
<ul>
<li>在WebStorm中编辑代码时，如果一行代码太长可以选择自动换行功能</li>
<li>点击代码行号的灰色部分，勾选<strong>Soft-Wrap</strong>即可</li>
</ul>
<p><img data-src="https://p.ipic.vip/3keq86.png" alt="" /></p>
<h3 id="换行标签"><a class="markdownIt-Anchor" href="#换行标签"></a> 换行标签</h3>
<h4 id="场景-3"><a class="markdownIt-Anchor" href="#场景-3"></a> 场景</h4>
<ul>
<li>让文字强制换行显示</li>
</ul>
<h4 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h4>
<ul>
<li><code>&lt;br&gt;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段文字<span class="tag">&lt;<span class="name">br</span>&gt;</span>我是强制换行后的一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/jqzc8v.png" alt="" /></p>
<ul>
<li>单标签</li>
<li>可以让文字强制换行</li>
</ul>
<h3 id="水平线标签"><a class="markdownIt-Anchor" href="#水平线标签"></a> 水平线标签</h3>
<h4 id="场景-4"><a class="markdownIt-Anchor" href="#场景-4"></a> 场景</h4>
<ul>
<li>分割不同主题内容的水平线</li>
</ul>
<h4 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h4>
<ul>
<li><code>&lt;hr&gt;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是水平线之下的文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/bt7vsl.png" alt="" /></p>
<h2 id="文本格式化标签"><a class="markdownIt-Anchor" href="#文本格式化标签"></a> 文本格式化标签</h2>
<h3 id="场景-5"><a class="markdownIt-Anchor" href="#场景-5"></a> 场景</h3>
<ul>
<li>需要让文字<strong>加粗</strong>、<u>下划线</u>、<em>倾斜</em>、<s>删除线</s>等效果
<ul>
<li>在Typora中删除线的快捷键是<strong>control + shift +`</strong></li>
</ul>
</li>
</ul>
<h3 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h3>
<table>
<thead>
<tr>
<th style="text-align:center">标签</th>
<th style="text-align:center">标签</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>b</code></td>
<td style="text-align:center"><code>strong</code></td>
<td style="text-align:center">加粗</td>
</tr>
<tr>
<td style="text-align:center"><code>u</code></td>
<td style="text-align:center"><code>ins</code></td>
<td style="text-align:center">下划线</td>
</tr>
<tr>
<td style="text-align:center"><code>i</code></td>
<td style="text-align:center"><code>em</code></td>
<td style="text-align:center">倾斜</td>
</tr>
<tr>
<td style="text-align:center"><code>s</code></td>
<td style="text-align:center"><code>del</code></td>
<td style="text-align:center">删除线</td>
</tr>
</tbody>
</table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>文本格式化标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>加粗的两种效果<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>加粗1<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>加粗2<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>下划线的两种效果<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">u</span>&gt;</span>下划线1<span class="tag">&lt;/<span class="name">u</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">ins</span>&gt;</span>下划线2<span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>倾斜的两种效果<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>倾斜1<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>倾斜2<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>删除线的两种效果<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">s</span>&gt;</span>删除效果1<span class="tag">&lt;/<span class="name">s</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">del</span>&gt;</span>删除效果2<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/f6g5ft.png" alt="" /></p>
<ul>
<li>当希望强调某种效果时，使用单词标签，否则就使用字母标签即可</li>
</ul>
<h2 id="媒体标签"><a class="markdownIt-Anchor" href="#媒体标签"></a> 媒体标签</h2>
<h3 id="场景-6"><a class="markdownIt-Anchor" href="#场景-6"></a> 场景</h3>
<ul>
<li>在网页中显示图片</li>
</ul>
<h3 id="标签的属性"><a class="markdownIt-Anchor" href="#标签的属性"></a> 标签的属性</h3>
<ul>
<li>标签属性由两部分组成
<ul>
<li>属性名</li>
<li>属性值</li>
</ul>
</li>
<li>标签的属性卸载<strong>开始标签内部</strong></li>
<li>标签上可以同时存在多个属性
<ul>
<li>多个属性之间用空格隔开</li>
<li>多个属性之间没有顺序之分</li>
</ul>
</li>
<li>标签名与属性之间一定要用空格隔开</li>
</ul>
<p><img data-src="https://p.ipic.vip/02ecv3.png" alt="" /></p>
<h3 id="路径"><a class="markdownIt-Anchor" href="#路径"></a> 路径</h3>
<ul>
<li>绝对路径
<ul>
<li>目录下的绝对位置，可直接到达目标位置，通常从根目录开始的路径</li>
<li>或者完整的网络地址</li>
<li>不同的电脑下绝对路径会不相同，所以一般不使用绝对路径</li>
</ul>
</li>
<li>相对路径
<ul>
<li>从当前文件开始出发寻找目标文件的过程</li>
</ul>
</li>
<li>相对路径的分类
<ol>
<li>同级目录
<ul>
<li>当前文件和目标文件在同一个目录中</li>
<li>相对路径直接为<code>文件名</code>或者<code>./文件名</code></li>
</ul>
</li>
<li>下级目录
<ul>
<li>目标文件在下级目录中</li>
<li>相对路径为<code>目标文件所在的目录/文件名</code></li>
</ul>
</li>
<li>上级目录
<ul>
<li>目标文件在上级目录中</li>
<li>相对路径为<code>../目标文件所在的目录/文件名</code></li>
<li>通过<code>..</code>来返回上一级目录</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="图片标签"><a class="markdownIt-Anchor" href="#图片标签"></a> 图片标签</h3>
<ul>
<li><code>&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;</code></li>
<li>单标签</li>
<li><code>img</code>标签需要展示对应的效果，需要借助标签属性进行设置
<ul>
<li><code>src=&quot;&quot;</code>以及<code>alt=&quot;&quot;</code>都是<code>img</code>标签的属性</li>
</ul>
</li>
</ul>
<h4 id="src属性"><a class="markdownIt-Anchor" href="#src属性"></a> src属性</h4>
<ul>
<li><code>src</code>是<code>img</code>标签的源属性，源属性的值是图像的URL地址
<ul>
<li>即存储图像的地址</li>
<li>绝对路径或者相对路径都可以</li>
</ul>
</li>
</ul>
<h4 id="alt属性"><a class="markdownIt-Anchor" href="#alt属性"></a> alt属性</h4>
<ul>
<li><code>alt</code>属性用来为图像定义一串预备的可替换的文本
<ul>
<li>在浏览器无法载入图像时，替换文本属性告诉用户失去的信息</li>
<li>当图片加载失败时，才显示替换文本</li>
<li>当图片加载成功时，不会显示替换文本</li>
</ul>
</li>
</ul>
<h4 id="height和width属性"><a class="markdownIt-Anchor" href="#height和width属性"></a> height和width属性</h4>
<ul>
<li><code>height</code>属性用于设置图片的高度
<ul>
<li>属性值默认单位为像素</li>
</ul>
</li>
<li><code>width</code>属性用于设置图片的宽度
<ul>
<li>属性值默认单位为像素</li>
<li>如果只设置了高度或者宽度中的一个，另一个会自动等比例缩放（图片不会变形）</li>
<li>建议在使用图片时指定图片的高度或宽度，这样页面加载时就会保留指定的尺寸。如果没有指定图片的大小，加载页面时有可能会破坏HTML页面的整体布局。</li>
</ul>
</li>
</ul>
<h4 id="title属性"><a class="markdownIt-Anchor" href="#title属性"></a> title属性</h4>
<ul>
<li><code>title</code>属性用于显示提示文本，当鼠标悬停时才显示的文本</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;screenshotOfMyBlog.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;我个人博客的截图&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1180&quot;</span> <span class="attr">height</span>=<span class="string">&quot;729&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/xyflsi.png" alt="" /></p>
<h3 id="音频标签"><a class="markdownIt-Anchor" href="#音频标签"></a> 音频标签</h3>
<ul>
<li><code>&lt;audio src=&quot;&quot;&gt;&lt;/audio&gt;</code></li>
<li><code>audio</code>标签在HTML4中是无效的</li>
<li>只支持三种格式的音频文件
<ul>
<li>Mp3 、Waw、Ogg</li>
</ul>
</li>
</ul>
<h4 id="controls属性"><a class="markdownIt-Anchor" href="#controls属性"></a> controls属性</h4>
<ul>
<li>显示播放的控件</li>
</ul>
<h4 id="autoplay属性"><a class="markdownIt-Anchor" href="#autoplay属性"></a> autoplay属性</h4>
<ul>
<li>自动播放</li>
<li>部分浏览器不支持该功能</li>
</ul>
<h4 id="loop属性"><a class="markdownIt-Anchor" href="#loop属性"></a> loop属性</h4>
<ul>
<li>循环播放</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;./music.mp3&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="视频标签"><a class="markdownIt-Anchor" href="#视频标签"></a> 视频标签</h3>
<ul>
<li><code>&lt;video src=&quot;&quot;&gt;&lt;/video&gt;</code></li>
<li>同样有<code>controls</code> <code>autoplay</code> <code>loop</code>三种属性
<ul>
<li><code>autoplay</code>需要和<code>muted</code>（静音）一起使用才能实现自动播放</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;./video.mp4&quot;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/8ak15s.png" alt="" /></p>
<h2 id="链接标签"><a class="markdownIt-Anchor" href="#链接标签"></a> 链接标签</h2>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3>
<ul>
<li>
<p>点击之后，从一个页面跳转到另一个页面</p>
</li>
<li>
<p>又称为a标签、超链接、锚链接</p>
</li>
<li>
<p>双标签，内部可以包裹内容</p>
</li>
</ul>
<h3 id="href属性"><a class="markdownIt-Anchor" href="#href属性"></a> href属性</h3>
<ul>
<li><code>href</code>属性中添加跳转地址
<ul>
<li>需要跳转到外部网页的话需要填入完整的URL</li>
<li>需要跳转到内部网页的话填入路径</li>
<li><code>href=&quot;#&quot;</code>代表空链接</li>
</ul>
</li>
</ul>
<h3 id="target属性"><a class="markdownIt-Anchor" href="#target属性"></a> target属性</h3>
<ul>
<li>属性值：目标网页的打开形式</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">属性值</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>_self</code></td>
<td style="text-align:center">默认值，在当前窗口中跳转（覆盖原网页）</td>
</tr>
<tr>
<td style="text-align:center"><code>_blank</code></td>
<td style="text-align:center">在新窗口中跳转（保留原网页）</td>
</tr>
</tbody>
</table>
<h3 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;目标网页&quot;</span>&gt;</span>链接的名称<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.google.com.hk/?client=safari&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>谷歌网页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./Test4.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>音视频测试网页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/qkkkil.png" alt="" /></p>
<h2 id="列表标签"><a class="markdownIt-Anchor" href="#列表标签"></a> 列表标签</h2>
<h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3>
<ul>
<li>场景
<ul>
<li>在网页中按照<strong>行</strong>展示关联性的内容，如新闻列表、排行榜、账单等等</li>
</ul>
</li>
<li>特点
<ul>
<li>按照行的方式，争气显示内容</li>
</ul>
</li>
<li>种类
<ul>
<li>无序列表、有序列表、自定义列表</li>
</ul>
</li>
</ul>
<h3 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h3>
<h4 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2"></a> 作用</h4>
<ul>
<li>在网页表示一组无顺序之分的列表</li>
</ul>
<h4 id="标签组成"><a class="markdownIt-Anchor" href="#标签组成"></a> 标签组成</h4>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ul</code></td>
<td style="text-align:center">表示无序列表的整体，用于包裹<code>li</code>标签</td>
</tr>
<tr>
<td style="text-align:center"><code>li</code></td>
<td style="text-align:center">表示无序列表的每一项，用于包含</td>
</tr>
</tbody>
</table>
<ul>
<li><code>ul</code>标签中只允许包含<code>li</code>标签
<ul>
<li><code>ul</code>和<code>li</code>是嵌套关系</li>
</ul>
</li>
<li><code>li</code>标签中可以包含任意内容</li>
<li>显示特点
<ul>
<li>列表的每一行前默认显示圆点表示</li>
</ul>
</li>
</ul>
<h4 id="代码-7"><a class="markdownIt-Anchor" href="#代码-7"></a> 代码</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一行<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二行<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三行<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>第四行<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/l1xp2b.png" alt="" /></p>
<h3 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表"></a> 有序列表</h3>
<h4 id="作用-3"><a class="markdownIt-Anchor" href="#作用-3"></a> 作用</h4>
<ul>
<li>在网页中表示一组有顺序之分的列表，如排行榜等</li>
</ul>
<h4 id="标签组成-2"><a class="markdownIt-Anchor" href="#标签组成-2"></a> 标签组成</h4>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ol</code></td>
<td style="text-align:center">表示有序列表的整体，用于包裹<code>li</code>标签</td>
</tr>
<tr>
<td style="text-align:center"><code>li</code></td>
<td style="text-align:center">表示有序列表的每一项，用于包含每一行的内容</td>
</tr>
</tbody>
</table>
<ul>
<li><code>ol</code>标签中只允许包含<code>li</code>标签</li>
<li><code>li</code>标签中可以包含任意内容</li>
<li>列表的每一项前默认显示序号标识</li>
</ul>
<h4 id="代码-8"><a class="markdownIt-Anchor" href="#代码-8"></a> 代码</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表第一行<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表第二行<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表第三行<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/j8e40w.png" alt="" /></p>
<h3 id="自定义列表description-list"><a class="markdownIt-Anchor" href="#自定义列表description-list"></a> 自定义列表Description List</h3>
<h4 id="作用-4"><a class="markdownIt-Anchor" href="#作用-4"></a> 作用</h4>
<ul>
<li>在网页的底部导航中通常会使用自定义列表来实现</li>
</ul>
<p><img data-src="https://p.ipic.vip/uo36os.png" alt="" /></p>
<h4 id="标签组成-3"><a class="markdownIt-Anchor" href="#标签组成-3"></a> 标签组成</h4>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>dl</code></td>
<td style="text-align:center">表示自定义列表整体，用于包裹<code>dt</code>和<code>dd</code>标签</td>
</tr>
<tr>
<td style="text-align:center"><code>dt</code></td>
<td style="text-align:center">自定义列表的主题</td>
</tr>
<tr>
<td style="text-align:center"><code>dd</code></td>
<td style="text-align:center">表示自定义列表针对主题的每一项内容</td>
</tr>
</tbody>
</table>
<ul>
<li>自定义列表中每一项前会默认显示锁进效果</li>
<li><code>dl</code>标签中只能包含<code>dt</code>和<code>dl</code></li>
<li><code>dt</code>和<code>dl</code>中可以包含任意内容</li>
</ul>
<h3 id="代码-9"><a class="markdownIt-Anchor" href="#代码-9"></a> 代码</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>自定义列表的主题<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span>&gt;</span>自定义列表第一行<span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span>&gt;</span>自定义列表第二行<span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span>&gt;</span>自定义列表第三行<span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="表格标签"><a class="markdownIt-Anchor" href="#表格标签"></a> 表格标签</h2>
<h3 id="表格的基本标签"><a class="markdownIt-Anchor" href="#表格的基本标签"></a> 表格的基本标签</h3>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>table</code></td>
<td style="text-align:center">表格整体，用于包裹多个<code>tr</code></td>
</tr>
<tr>
<td style="text-align:center"><code>tr</code></td>
<td style="text-align:center">表格的每行，用于包裹<code>td</code></td>
</tr>
<tr>
<td style="text-align:center"><code>td</code></td>
<td style="text-align:center">表格单元格，用于包裹内容</td>
</tr>
<tr>
<td style="text-align:center"><code>th</code></td>
<td style="text-align:center">表格每一列的主题</td>
</tr>
<tr>
<td style="text-align:center"><code>caption</code></td>
<td style="text-align:center">表格的标题</td>
</tr>
</tbody>
</table>
<ul>
<li><code>table</code>用于包含<code>tr</code></li>
<li>有几行就需要几对<code>tr</code></li>
<li><code>tr</code>可以包含<code>th</code>，也可以包含<code>td</code></li>
<li>一对<code>td</code>或者<code>th</code>只能包含一个单元格的内容</li>
<li>表格的标题默认在表格整体顶部居中位置显示</li>
<li><code>caption</code>标签书写在<code>table</code>标签内部</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">caption</span>&gt;</span>通讯录<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>电话<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>朋友<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>23456<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>老师<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/4gs8d2.png" alt="" /></p>
<h3 id="表格相关的属性"><a class="markdownIt-Anchor" href="#表格相关的属性"></a> 表格相关的属性</h3>
<h4 id="border"><a class="markdownIt-Anchor" href="#border"></a> border</h4>
<ul>
<li>为表格增加边框</li>
<li>属性值为边框的宽度，单位是像素</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置边框的宽度为1px--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>title1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>title2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>cell1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>cell2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/93fsle.png" alt="" /></p>
<h4 id="width"><a class="markdownIt-Anchor" href="#width"></a> width</h4>
<ul>
<li>为表格的宽度</li>
<li>属性值为边框的宽度，单位是像素</li>
</ul>
<h4 id="heigth"><a class="markdownIt-Anchor" href="#heigth"></a> heigth</h4>
<ul>
<li>为表格的高度</li>
<li>属性值为边框的高度，单位是像素</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>title1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>title2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>cell1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>cell2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/556tu3.png" alt="" /></p>
<h3 id="表格的结构标签"><a class="markdownIt-Anchor" href="#表格的结构标签"></a> 表格的结构标签</h3>
<ul>
<li>作用
<ul>
<li>让表格的内容结构分组，突出表格的不同部分（头部、主体、底部），使语义更加清晰</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>thead</code></td>
<td style="text-align:center">表格头部</td>
</tr>
<tr>
<td style="text-align:center"><code>tbody</code></td>
<td style="text-align:center">表格主体</td>
</tr>
<tr>
<td style="text-align:center"><code>tfoot</code></td>
<td style="text-align:center">表格底部</td>
</tr>
</tbody>
</table>
<ul>
<li>表格结构标签可以省略</li>
<li>表格结构变迁内部用<code>tr</code>标签包裹内容</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>通讯录<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>电话<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>朋友<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>23456<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>老师<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>总结<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>总结<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>总结<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/lah8l9.png" alt="" /></p>
<h3 id="合并单元格"><a class="markdownIt-Anchor" href="#合并单元格"></a> 合并单元格</h3>
<h4 id="作用-5"><a class="markdownIt-Anchor" href="#作用-5"></a> 作用</h4>
<ul>
<li>将水平或垂直多个单元格合并成一个单元格</li>
<li>跨行合并：垂直合并成一个</li>
<li>跨列合并：水平合并成一个</li>
</ul>
<h4 id="代码-10"><a class="markdownIt-Anchor" href="#代码-10"></a> 代码</h4>
<ul>
<li>首先明确合并哪几个单元格</li>
<li>通过<strong>左上原则</strong>，确定保留谁删除谁
<ul>
<li>跨行合并：只保留最上面的</li>
<li>跨列合并：只保留最左边的</li>
</ul>
</li>
<li>给保留的单元格设置：跨行合并（<code>rowspan</code>）或者跨列合并（<code>colspan</code>）</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rowspan</code></td>
<td>合并单元格的个数</td>
<td>跨行合并</td>
</tr>
<tr>
<td><code>colspan</code></td>
<td>合并单元格的个数</td>
<td>跨列合并</td>
</tr>
</tbody>
</table>
<ul>
<li>只有同一个结构标签中的单元格才能合并，不能跨结构标签合并</li>
<li>被合并的元素需要手动删除</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>合并后的表格<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--垂直合并2格单元格--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被合并掉的元素需要手动删除--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;td&gt;2&lt;/td&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被合并的元素需要手动删除&lt;td&gt;3&lt;/td&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被合并的元素需要手动删除&lt;td&gt;3&lt;/td&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/tjqjsn.png" alt="" /></p>
<h2 id="表单标签"><a class="markdownIt-Anchor" href="#表单标签"></a> 表单标签</h2>
<h3 id="表单"><a class="markdownIt-Anchor" href="#表单"></a> 表单</h3>
<ul>
<li>表单是一个包含表单元素的区域</li>
<li>表单元素是<strong>允许用户在表单中输入内容</strong>，比如：文本域（textarea）、下拉列表（select）、单选框（radio-buttons）、复选框（checkbox） 等等</li>
</ul>
<h3 id="input系列标签"><a class="markdownIt-Anchor" href="#input系列标签"></a> input系列标签</h3>
<h4 id="作用-6"><a class="markdownIt-Anchor" href="#作用-6"></a> 作用</h4>
<ul>
<li>在网页中收集用户输入的内容</li>
</ul>
<h4 id="代码-11"><a class="markdownIt-Anchor" href="#代码-11"></a> 代码</h4>
<ul>
<li>标签名：<code>input</code>
<ul>
<li><code>input</code>标签可以通过<code>type</code>属性值的不同展示不同的效果</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">type属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>input</code></td>
<td style="text-align:center"><code>text</code></td>
<td style="text-align:center">文本狂，用于输入单行文本</td>
</tr>
<tr>
<td style="text-align:center"><code>input</code></td>
<td style="text-align:center"><code>password</code></td>
<td style="text-align:center">密码框，用于输入密码</td>
</tr>
<tr>
<td style="text-align:center"><code>input</code></td>
<td style="text-align:center"><code>radio</code></td>
<td style="text-align:center">单选框，用于多选一</td>
</tr>
<tr>
<td style="text-align:center"><code>input</code></td>
<td style="text-align:center"><code>checkbox</code></td>
<td style="text-align:center">多选框，用于多选多</td>
</tr>
<tr>
<td style="text-align:center"><code>input</code></td>
<td style="text-align:center"><code>file</code></td>
<td style="text-align:center">文件选择，用于上传文件</td>
</tr>
<tr>
<td style="text-align:center"><code>input</code></td>
<td style="text-align:center"><code>submit</code></td>
<td style="text-align:center">提交按钮，用于提交</td>
</tr>
<tr>
<td style="text-align:center"><code>input</code></td>
<td style="text-align:center"><code>reset</code></td>
<td style="text-align:center">重置按钮，用于重置</td>
</tr>
<tr>
<td style="text-align:center"><code>input</code></td>
<td style="text-align:center"><code>button</code></td>
<td style="text-align:center">普通按钮，默认无功能，配合JS实现其他功能</td>
</tr>
</tbody>
</table>
<h4 id="placeholder属性"><a class="markdownIt-Anchor" href="#placeholder属性"></a> placeholder属性</h4>
<ul>
<li>占位符，用于提示用书输入内容的文本</li>
<li>默认是浅色的字体</li>
<li>注意区分<code>placeholder</code>和<code>value</code>属性之间的区别
<ul>
<li><code>placeholder</code>是占位符，不是真正的值，只起到提示的作用</li>
<li><code>value</code>是真正输入到<code>input</code>标签中的值</li>
</ul>
</li>
</ul>
<h4 id="input-type-text"><a class="markdownIt-Anchor" href="#input-type-text"></a> input Type text</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">文本框：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">文本框：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入文本&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>显示的内容就是输入的内容</li>
</ul>
<p><img data-src="https://p.ipic.vip/b0fdgr.png" alt="" /></p>
<p><img data-src="https://p.ipic.vip/sk7sve.png" alt="" /></p>
<h4 id="input-type-password"><a class="markdownIt-Anchor" href="#input-type-password"></a> input Type  password</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">密码框：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>输入的内容无法直接看到</li>
</ul>
<p><img data-src="https://p.ipic.vip/ja0y4r.png" alt="" /></p>
<h4 id="input-tpye-radio"><a class="markdownIt-Anchor" href="#input-tpye-radio"></a> input Tpye radio</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">单选框：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在多个单选框中只能选择一个</li>
<li>默认情况下<code>radio</code>并没有实现单选功能</li>
<li><code>name</code>属性
<ul>
<li>具有部分组的作用</li>
<li>有相同<code>name</code>属性值的单选框为一组，一组中只有一个单选框可以被选中</li>
</ul>
</li>
<li><code>checked</code>属性
<ul>
<li>默认选中</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">单选框：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;language&quot;</span> <span class="attr">checked</span>&gt;</span>HTML	<span class="comment">&lt;!--默认选中HTML--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;language&quot;</span>&gt;</span>CSS</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;language&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/l0yfx9.png" alt="" /></p>
<p><img data-src="https://p.ipic.vip/vjkfnh.png" alt="" /></p>
<h4 id="input-type-checkbox"><a class="markdownIt-Anchor" href="#input-type-checkbox"></a> input Type checkbox</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">多选框：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">多选框：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>唱歌</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>跳舞</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>篮球</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>rap<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多选框中的内容可以勾选多个</li>
<li><img data-src="https://p.ipic.vip/nk2srz.png" alt="" /></li>
</ul>
<p><img data-src="https://p.ipic.vip/xmtf64.png" alt="" /></p>
<h4 id="input-type-file"><a class="markdownIt-Anchor" href="#input-type-file"></a> input Type file</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">文件：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>点开<u>选择文件</u>即可上传文件</li>
<li><code>multiple</code>属性
<ul>
<li>允许一次性上传多个文件</li>
</ul>
</li>
</ul>
<p><img data-src="https://p.ipic.vip/tahno2.png" alt="" /></p>
<h3 id="按钮标签"><a class="markdownIt-Anchor" href="#按钮标签"></a> 按钮标签</h3>
<h4 id="type属性值"><a class="markdownIt-Anchor" href="#type属性值"></a> type属性值</h4>
<table>
<thead>
<tr>
<th style="text-align:center">标签名</th>
<th style="text-align:center">type值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>input</code>/<code>button</code></td>
<td style="text-align:center"><code>submit</code></td>
<td style="text-align:center">提交按钮，点击之后提交数据给后端服务器</td>
</tr>
<tr>
<td style="text-align:center"><code>input</code>/<code>button</code></td>
<td style="text-align:center"><code>reset</code></td>
<td style="text-align:center">重置按钮，点击之后恢复表单默认值</td>
</tr>
<tr>
<td style="text-align:center"><code>input</code>/<code>button</code></td>
<td style="text-align:center"><code>button</code></td>
<td style="text-align:center">普通按钮，默认无功能，配合JS添加功能</td>
</tr>
</tbody>
</table>
<h4 id="value属性"><a class="markdownIt-Anchor" href="#value属性"></a> value属性</h4>
<ul>
<li>用于修改按钮上所显示的文字</li>
<li><code>submit</code>和<code>reset</code>按钮默认显示提交和重置</li>
</ul>
<h4 id="表单域标签"><a class="markdownIt-Anchor" href="#表单域标签"></a> 表单域标签</h4>
<ul>
<li>使用<code>form</code>标签把表单标签包裹起来一起使用，用来实现按钮的功能</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;普通按钮&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/hzdlmk.png" alt="" /></p>
<h3 id="select下拉菜单标签"><a class="markdownIt-Anchor" href="#select下拉菜单标签"></a> select下拉菜单标签</h3>
<ul>
<li>
<p>在网页中提供多个选项的下拉菜单空间</p>
</li>
<li>
<p>标签组成</p>
<ul>
<li><code>select</code>标签：下拉菜单的整体</li>
<li><code>option</code>标签：下拉菜单的每一项
<ul>
<li><code>selected</code>属性代表默认选中的选项</li>
<li>默认情况下下拉菜单的第一个选项是默认选中的个选项</li>
</ul>
</li>
<li><code>select</code>标签用于包裹<code>option</code>标签</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">selected</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="textarea文本域标签"><a class="markdownIt-Anchor" href="#textarea文本域标签"></a> textarea文本域标签</h3>
<ul>
<li>在网页中提供可输入多行文字的表单控件</li>
<li>可以实现自动换行</li>
</ul>
<h4 id="常见属性"><a class="markdownIt-Anchor" href="#常见属性"></a> 常见属性</h4>
<ul>
<li><code>cols</code>：规定了文本域可见的宽度</li>
<li><code>rows</code>：规定了文本域可见的行数</li>
</ul>
<h3 id="label标签"><a class="markdownIt-Anchor" href="#label标签"></a> label标签</h3>
<ul>
<li>用于绑定内容与表单标签的关系</li>
<li>以单选表单为例：
<ul>
<li>在之前的单选表单中只有选中了前面的单选框才能勾选该选项</li>
<li>将单选表单与单选项的内容绑定后，通过单选项的内容也能选择该项</li>
</ul>
</li>
</ul>
<h4 id="使用方法1"><a class="markdownIt-Anchor" href="#使用方法1"></a> 使用方法1</h4>
<ul>
<li>使用<code>label</code>标签将内容包裹起来</li>
<li>在表单标签中添加<code>id</code>属性</li>
<li>在<code>label</code>标签的<code>for</code>属性中设置对应的<code>id</code>属性值
<ul>
<li>将<code>label</code>的<code>for</code>属性的值和表单标签中<code>id</code>属性的值统一</li>
</ul>
</li>
<li>区分<code>name</code>属性和<code>id</code>属性
<ul>
<li><code>name</code>属性是用于将多个单选框设置成一个总体
<ul>
<li>在这个总体里，只能有一个单选项被选中</li>
<li>在这个总体里的每一个单选表单的<code>name</code>值都相同，才代表它们都在这一个总体里</li>
</ul>
</li>
<li><code>id</code>属性是用于将<code>label</code>标签和表单标签的内容联系在一起
<ul>
<li>需要被捆绑在一起的表单标签的<code>id</code>属性和对应的<code>label</code>标签的<code>for</code>属性相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="使用方法2"><a class="markdownIt-Anchor" href="#使用方法2"></a> 使用方法2</h4>
<ul>
<li>直接使用label标签将内容和表单标签包裹在一起</li>
<li>将label标签中的for属性删除即可</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;language&quot;</span> <span class="attr">id</span>=<span class="string">&quot;HTML&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;HTML&quot;</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;language&quot;</span> <span class="attr">id</span>=<span class="string">&quot;CSS&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;CSS&quot;</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;language&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="语义化标签"><a class="markdownIt-Anchor" href="#语义化标签"></a> 语义化标签</h2>
<h3 id="无语义的布局标签div和span"><a class="markdownIt-Anchor" href="#无语义的布局标签div和span"></a> 无语义的布局标签div和span</h3>
<ul>
<li><code>div</code>标签
<ul>
<li>被该标签包裹的内容没有任何特殊效果，只是对其包裹的内容在排版上有特殊要求</li>
<li>被<code>div</code>包裹的内容独享一行</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">这是普通文字</span><br><span class="line">这是普通文字</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/n2eu9x.png" alt="" /></p>
<ul>
<li><code>span</code>标签
<ul>
<li>一行可以显示多个</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">这是普通文字</span><br><span class="line">这是普通文字</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>这是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>这是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>这是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/sdbuuw.png" alt="" /></p>
<h3 id="有语义的布局标签"><a class="markdownIt-Anchor" href="#有语义的布局标签"></a> 有语义的布局标签</h3>
<ul>
<li>适用于移动端的网页制作</li>
</ul>
<table>
      <caption>有语义的布局标签</caption>
    <tr>
        <th>标签名</th>
        <th>语义</th>
    </tr>
    <tr>
        <td>header</td>
        <td>网页头部</td>
    </tr>
    <tr>
        <td>nav</td>
        <td>网页导航</td>
    </tr>
    <tr>
        <td>footer</td>
        <td>网页底部</td>
    </tr>
    <tr>
        <td>aside</td>
        <td>网页侧边栏</td>
    </tr>
    <tr>
        <td>section</td>
        <td>网页区块</td>
    </tr>
    <tr>
        <td>article</td>
        <td>网页文章</td>
    </tr>
</table>
<h2 id="字符实体"><a class="markdownIt-Anchor" href="#字符实体"></a> 字符实体</h2>
<ul>
<li>能够通过字符实体在网页中显示特殊符号</li>
<li>浏览器无法识别一些特殊符号（比如空格、大于号、小于号等等）</li>
<li>常见字符实体</li>
<li>区分大小写，同时以分号结束</li>
<li>空格的实体名称<code>&amp;nbsp;</code></li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML简介</title>
    <url>/2022/12/29/%E5%89%8D%E7%AB%AF/HTML%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="html简介"><a class="markdownIt-Anchor" href="#html简介"></a> HTML简介</h1>
<h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h2>
<h3 id="网页的组成"><a class="markdownIt-Anchor" href="#网页的组成"></a> 网页的组成</h3>
<ul>
<li>文字、图片、音频、视频、超链接</li>
</ul>
<h3 id="渲染引擎"><a class="markdownIt-Anchor" href="#渲染引擎"></a> 渲染引擎</h3>
<ul>
<li>渲染引擎（浏览器内核）：浏览器中专门对代码进行解析渲染的部分</li>
<li>渲染引擎不同，导致解析代码的速度、性能、效果也不同</li>
</ul>
<h3 id="web标准"><a class="markdownIt-Anchor" href="#web标准"></a> Web标准</h3>
<ul>
<li>不同浏览器的渲染引擎不同，对于相同代码的解析效果会存在差异</li>
<li>Web标准由三部分构成
<ol>
<li><strong>结构</strong>：HTML
<ul>
<li>页面元素和内容</li>
</ul>
</li>
<li><strong>表现</strong>：CSS
<ul>
<li>网页元素的外观和位置等页面样式（颜色、大小等）</li>
</ul>
</li>
<li><strong>行为</strong>：JavaScript
<ul>
<li>网页模型的定义与页面交互</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="html"><a class="markdownIt-Anchor" href="#html"></a> HTML</h2>
<h3 id="html概念"><a class="markdownIt-Anchor" href="#html概念"></a> HTML概念</h3>
<ul>
<li>Hyper Text Markup Language：超文本标记语言</li>
<li>专门用于网页开发的语言，通过HTML标签对网页中的文本、图片、音频、视频等内容进行描述</li>
</ul>
<h3 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> Hello World</h3>
<ul>
<li>编写一个简单的html文件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/1c8elq.png" alt="" /></p>
<ul>
<li>加粗的语法规则
<ul>
<li>使用<code>strong</code>标签</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>加粗的内容<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>大部分标签都是有首有尾的</li>
</ul>
<h3 id="解决sublime-text中文乱码问题"><a class="markdownIt-Anchor" href="#解决sublime-text中文乱码问题"></a> 解决Sublime Text中文乱码问题</h3>
<ul>
<li>由于刚开始学前端相关的知识，我现在使用的较为轻便的Sublime Text作为开发工具</li>
<li>在编写带有中文字符的HTMl文件时，我发现中文会出现乱码的情况</li>
</ul>
<p><img data-src="https://p.ipic.vip/pp3cjm.png" alt="" /></p>
<h4 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h4>
<ul>
<li>Sublime Text默认采用UTF-8的字符集，不支持<strong>GB2312</strong>（中文字符集）</li>
</ul>
<h4 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h4>
<ul>
<li>
<p>在Sublime中下载一个<strong>convertToUTF8</strong>的插件</p>
<ul>
<li>用快捷点<code>command + shift + P</code>调出插件管理页面</li>
</ul>
<p><img data-src="https://p.ipic.vip/vgpzi2.png" alt="" /></p>
<ul>
<li>输入<code>Package Control: install Package</code>（或者直接输入<code>install</code>）</li>
</ul>
<p><img data-src="https://p.ipic.vip/2is7xl.png" alt="" /></p>
<ul>
<li>然后搜索插件名字<strong>convertToUTF8</strong>进行安装</li>
</ul>
</li>
<li>
<p>插件安装好后，在Sublime中更改文件的字符集</p>
<ul>
<li>在<code>File</code>中选择<code>Save with Encoding</code>然后选择<code>UTF-8 with BOM</code></li>
</ul>
<p><img data-src="https://p.ipic.vip/o75npw.png" alt="" /></p>
</li>
</ul>
<h3 id="html页面固定结构"><a class="markdownIt-Anchor" href="#html页面固定结构"></a> HTML页面固定结构</h3>
<ul>
<li>网页中存在固定结构
<ul>
<li>整体、头部、标题、主体</li>
<li><code>html</code>标签：网页的整体</li>
<li><code>head</code>标签：网页的头部</li>
<li><code>title</code>标签：网页的标题</li>
<li><code>body</code>标签：网页的主体</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test2<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    通过WebStorm创建的HTML文件<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>加粗的文字<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://p.ipic.vip/exbc2q.png" alt="" /></p>
<ul>
<li>网页中固定的结构是要通过特定的HTML标签进行描述的</li>
</ul>
<h2 id="html语法"><a class="markdownIt-Anchor" href="#html语法"></a> HTML语法</h2>
<h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这里是注释--&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>快捷键<code>command + /</code></li>
</ul>
<h3 id="标签的结构"><a class="markdownIt-Anchor" href="#标签的结构"></a> 标签的结构</h3>
<ul>
<li>标签由<code>&lt; &gt; / 英文字母</code>组成，并且把标签中尖括号括号包裹起来的英文单词成为标签名</li>
<li>常见的标签由两部分组成，我们称之为<strong>双标签</strong>
<ul>
<li>前部分称为开始标签</li>
<li>后部分称为结束标签</li>
<li>中间包裹的内容</li>
</ul>
</li>
<li>少部分标签由一部分组成，我们称之为<strong>单标签</strong>
<ul>
<li>自成一体，无法包裹内容</li>
<li><code>&lt;br&gt;</code>：用于换行</li>
<li><code>&lt;hr&gt;</code>：用于输出一个横线</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>加粗的文字<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="标签的关系"><a class="markdownIt-Anchor" href="#标签的关系"></a> 标签的关系</h3>
<ul>
<li>父子关系（嵌套关系）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>兄弟关系（并列关系）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap和Hashtable</title>
    <url>/2022/12/24/Java/HashMap%E5%92%8CHashtable/</url>
    <content><![CDATA[<h2 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h2>
<h3 id="哈希表的实现"><a class="markdownIt-Anchor" href="#哈希表的实现"></a> 哈希表的实现</h3>
<ul>
<li><code>HashMap</code>在底层是哈希表的数据结构</li>
<li>哈希表是一个<strong>数组</strong>和<strong>单向链表</strong>的结合体
<ul>
<li>数组在查询方面效率高</li>
<li>链表在数据增删方面效率高</li>
<li>哈希表充分融合以上两者的优点</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>哈希表在底层其实是一个<code>Node&lt;K,V&gt;</code>一维数组，数组中每个元素是一个单向链表
<ul>
<li><code>final int hash</code>是哈希值，<code>hash</code>值是哈希键<code>key</code>通过<code>hashCode()</code>方法执行的结果，哈希值可以由哈希函数转换为<u>数组存储的下标</u>
<ul>
<li>这里的<code>hashCode()</code>方法指的是<code>Object</code>类中的方法，效果近似于计算每个引用的内存地址，但是我们需要对其进行重写</li>
<li>使得<code>key</code>相同的元素的<code>hashCode</code>也相同</li>
</ul>
</li>
<li><code>final K key</code>存储于<code>Map</code>集合中的<code>key</code></li>
<li><code>V value</code>存储于<code>Map</code>集合中的<code>value</code></li>
<li><code>Node&lt;K,V&gt; next</code>单向链表中存储下一个节点地址的引用</li>
</ul>
</li>
<li><code>HashMap</code>集合的<strong>默认初始化容量</strong>是<em>16</em>，<strong>默认加载因子</strong>是<em>0.75</em>
<ul>
<li>默认加载因子的意思是：当HashMap集合底层数组的容量达到75%时，数组开始扩容</li>
<li><code>HashMap</code>集合的初始化容量必须是<em>2</em>的幂次
<ul>
<li>这样可以达到散列均匀，提高<code>HashMap</code>集合的存取销量</li>
</ul>
</li>
</ul>
</li>
<li>在JDK8之后，如果哈希表单向链表的元素超过<em>8</em>个
<ul>
<li>单向链表会变成红黑树数据结构</li>
<li>当红黑树中节点个数小于<em>6</em>时，又会重新把红黑树变成单向链表</li>
</ul>
</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9etqvpc4ij30j6083wfb.jpg" alt="" /></p>
<ul>
<li>哈希表中元素的查询是通过数组完成的
<ul>
<li>直接通过计算节点的<code>key</code>的<code>hashCode</code>，然后计算对应的<code>hash</code>值，即可得到该节点在数组中的下标</li>
<li>然后再遍历数组对应下标处的单链表，即可找到某个节点</li>
<li>不需要遍历整个数组，只需要遍历部分单链表</li>
</ul>
</li>
<li>哈希表中元素的增删是通过链表完成的
<ul>
<li>所有的元素均存储在单链表的节点中</li>
<li>通过更改单链表中的指针，来完成对单链表中元素的增删</li>
</ul>
</li>
</ul>
<h3 id="mapputk-key-v-value实现原理"><a class="markdownIt-Anchor" href="#mapputk-key-v-value实现原理"></a> <code>Map.put(K key, V value)</code>实现原理</h3>
<ol>
<li>现将要插入的<code>(K key, V value)</code>封装成<code>Node</code>对象</li>
<li>通过调用<code>key</code>的<code>hashCode()</code>方法，得到这个节点的哈希值；再通过调用哈希函数，将<code>hash</code>值转化为数组的下标</li>
<li>如果数组中该下标位置处没有任何元素，则直接把这个节点加入数组</li>
<li>如果数组下标对应的位置上有元素（链表），则将这个待插入的节点依次和链表上所有的的节点进行比较（用待插入节点的<code>key</code>和链表上节点的<code>key</code>进行<code>equals</code>）。
<ul>
<li>如果每一个比较的结果都是<code>false</code>（代表没有节点和它拥有相同的<code>key</code>），则待插入的链表将会被插入到这个链表的<u>末尾</u></li>
<li>否则将会用待插入节点的<code>value</code>去替换返回<code>true</code>节点的<code>value</code>（<code>equals</code>的结果为<code>true</code>代表这两个节点拥有相同的<code>key</code>）（原节点的<code>value</code>被覆盖）</li>
</ul>
</li>
</ol>
<h3 id="mapgetobject-key实现原理"><a class="markdownIt-Anchor" href="#mapgetobject-key实现原理"></a> <code>Map.get(Object key)</code>实现原理</h3>
<ol>
<li>通过调用<code>key</code>的<code>hashCode()</code>方法，得到这个<code>key</code>所对应的<code>hash</code>值；再通过调用哈希函数，将<code>hash</code>值转化为数组对应的下标</li>
<li>如果数组下标对应处没有元素，则直接返回<code>null</code></li>
<li>如果数组下标对应的位置上有元素（链表），则将这个链表上的节点的<code>key</code>依次和待查找的<code>key</code>进行比较（<code>equals</code>比较）
<ul>
<li>当比较的结果为<code>true</code>时，返回这个<code>key</code>所在节点的<code>value</code></li>
<li>如果所有节点比较的结果都为<code>false</code>时，返回<code>null</code></li>
</ul>
</li>
</ol>
<h3 id="哈希表存储特点的解释"><a class="markdownIt-Anchor" href="#哈希表存储特点的解释"></a> 哈希表存储特点的解释</h3>
<ol>
<li>无序
<ul>
<li>无法提前确认某个节点会存放在单链表的第几个位置</li>
<li>每次遍历哈希表时所有的元素顺序也都不相同</li>
<li><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9es374pwlj30fy0b4glz.jpg" alt="" /></li>
</ul>
</li>
<li>不可重复
<ul>
<li>在存储和取出元素时，通过<code>equals</code>方法来保证只会有一个元素被获取
<ul>
<li>需要重写<code>equals()</code>，在哈希表中增删查元素时，比较的是节点中的内容，而不是节点的引用</li>
</ul>
</li>
<li>如果发生重复（即拥有相同的<code>key</code>），那么会发生覆盖现象</li>
</ul>
</li>
</ol>
<ul>
<li>
<p><code>HashMap</code>集合中<code>key</code>部分的元素其实时存放到了<code>HashSet</code>集合中</p>
</li>
<li>
<p><code>HashMap</code>中同一个单链表上所有节点的<code>hash</code>值都相同，但是同一个链表上所有的节点的<code>key</code>值都不相同</p>
<ul>
<li>
<p><code>hashCode()</code>的返回值应该均匀</p>
</li>
<li>
<p>极限条件下，如果<code>hashCode()</code>的返回值只有一个，那么哈希表就完全变成了一个单链表。所有的元素都存储于一个单链表上</p>
</li>
<li>
<p>极限条件下，如果所有<code>hashCode()</code>的返回值都不相同，那么哈希表的数组长度需要无限长来容纳所有的元素。所有的元素都会存储于数组中</p>
</li>
</ul>
</li>
</ul>
<h3 id="hashcode"><a class="markdownIt-Anchor" href="#hashcode"></a> <code>hashCode()</code></h3>
<ul>
<li>在存储或者查询元素时，第一步便是通过<code>hashCode()</code>方法来获得元素的<code>hash</code>值，我们需要对其进行重写
<ul>
<li>使得具有相同<code>key</code>的元素的<code>hashCode()</code></li>
<li>如果不重写的话，<code>hashCode()</code>直接返回的是元素的地址，那么所有元素的<code>hashCode</code>都不相同</li>
<li>先调用<code>hashCode()</code>，之后的<code>equals()</code>方法有可能不调用
<ul>
<li>如果只重写了<code>equals()</code>，由于先调用<code>hashCode()</code>方法，仍然会导致错误</li>
</ul>
</li>
</ul>
</li>
<li>一个类中，<code>equals()</code>方法重写<code>hashCode()</code>也必须重写
<ul>
<li><code>equals()</code>返回<code>true</code>的两个对象，它们的<code>hashCode()</code>返回值必须相同</li>
</ul>
</li>
<li>通过<code>IDEA</code>工具自动生成</li>
<li><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9ete0i7bfj306s07g3yk.jpg" alt="" /></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重写equals和hashCode之前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;user1的hashCode &quot;</span> + user1.hashCode());</span><br><span class="line">    System.out.println(<span class="string">&quot;user2的hashCode &quot;</span> + user2.hashCode());</span><br><span class="line"></span><br><span class="line">    HashSet&lt;User&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    hashSet.add(user1);</span><br><span class="line">    hashSet.add(user2);</span><br><span class="line">    System.out.println(<span class="string">&quot;HashSet中元素的数量&quot;</span> + hashSet.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9etgkkfikj30fw07zwex.jpg" alt="" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重写equals和hashCode之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  	<span class="comment">//....</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> User)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(getName(), user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9ethpt1o0j30fr08ct92.jpg" alt="" /></p>
<h2 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable"></a> Hashtable</h2>
<h3 id="hashtable的存储原理"><a class="markdownIt-Anchor" href="#hashtable的存储原理"></a> Hashtable的存储原理</h3>
<ul>
<li><code>Hashtable</code>在底层同样是哈希表，但是<code>Hashtable</code>是线程安全的
<ul>
<li><code>Hashtable</code>的初始化容量是<em>11</em>，负载因子同样是<em>0.75</em></li>
<li><code>Hashtable</code>的扩容是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>原容量</mtext><mo>×</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">原容量\times 2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">原</span><span class="mord cjk_fallback">容</span><span class="mord cjk_fallback">量</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>
<ul>
<li><code>Hashmap</code>扩容是直接：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>原容量</mtext><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">原容量\times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">原</span><span class="mord cjk_fallback">容</span><span class="mord cjk_fallback">量</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
<li><code>Hashtable</code>要求<code>key</code>和<code>value</code>都是非空的
<ul>
<li><code>Hashmap</code>是非线程安全的，允许<code>key</code>和<code>value</code>为空</li>
</ul>
</li>
</ul>
<h2 id="properties"><a class="markdownIt-Anchor" href="#properties"></a> <code>Properties</code></h2>
<h3 id="properties特点"><a class="markdownIt-Anchor" href="#properties特点"></a> <code>Properties</code>特点</h3>
<ul>
<li><code>Properties</code>是一个<code>Map</code>集合，继承<code>Hashtable</code></li>
<li><code>Properties</code>的<code>key</code>和<code>value</code>都是<code>String</code>类型
<ul>
<li>类似<code>HashMap&lt;String,String&gt; hashMap</code></li>
</ul>
</li>
<li><code>Properties</code>是线程安全的</li>
</ul>
<h3 id="properties常用方法"><a class="markdownIt-Anchor" href="#properties常用方法"></a> <code>Properties</code>常用方法</h3>
<h4 id="public-synchronized-object-setpropertystring-key-string-value"><a class="markdownIt-Anchor" href="#public-synchronized-object-setpropertystring-key-string-value"></a> <code>public synchronized Object setProperty(String key, String value)</code></h4>
<blockquote>
<p>Calls the Hashtable method put. Provided for parallelism with the getProperty method. Enforces use of strings for property keys and values. The value returned is the result of the Hashtable call to put.</p>
</blockquote>
<ul>
<li>底层调用<code>HashMap</code>的<code>put()</code>方法来实现元素的存储</li>
</ul>
<h4 id="public-object-getobject-key"><a class="markdownIt-Anchor" href="#public-object-getobject-key"></a> <code>public Object get(Object key)</code></h4>
<ul>
<li>底层调用<code>Map</code>的<code>get()</code>方法，通过<code>key</code>来返回元素的<code>value</code></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 1st Week - Summary</title>
    <url>/2022/11/23/Java/Java%20-%201st%20Week%20-%20Summary/</url>
    <content><![CDATA[<h1 id="第一周"><a class="markdownIt-Anchor" href="#第一周"></a> 第一周</h1>
<p align="right">10.26-11.05</p>
<h3 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h3>
<p>我决定从22.10.26开始重新扎实的再次学习一遍Java语言，并且计划将自己的学习过程以博客的形式记录下来。</p>
<p>由于很多知识在前期都已经学过了，因此第一周的学习还是非常容易上手的，但我在之前的学习中忽略了很多细小的知识点，或者没有弄清楚其中的原理，因此这篇博客着重回顾这些容易被我忽视的内容。</p>
<h2 id="常用的终端命令"><a class="markdownIt-Anchor" href="#常用的终端命令"></a> 常用的终端命令</h2>
<p>在Mac上快捷打开Terminal的方式：通过 <strong>聚焦搜索</strong> 快捷键 <code>command + space</code>的方式，搜索<code>ter</code>即可</p>
<h3 id="常用操作"><a class="markdownIt-Anchor" href="#常用操作"></a> 常用操作</h3>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>clear</code></td>
<td style="text-align:center">清空屏幕中的内容</td>
</tr>
<tr>
<td style="text-align:center"><code>command + q</code></td>
<td style="text-align:center">退出终端</td>
</tr>
<tr>
<td style="text-align:center"><code>command + w</code></td>
<td style="text-align:center">关闭当前窗口</td>
</tr>
<tr>
<td style="text-align:center"><code>control + c</code></td>
<td style="text-align:center">结束当前进程</td>
</tr>
</tbody>
</table>
<h3 id="与目录有关操作"><a class="markdownIt-Anchor" href="#与目录有关操作"></a> 与目录有关操作</h3>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>cd + folder_name</code></td>
<td style="text-align:center">进入名为folder_name的文件夹</td>
</tr>
<tr>
<td style="text-align:center"><code>cd + -</code></td>
<td style="text-align:center">回到上一个访问的目录</td>
</tr>
<tr>
<td style="text-align:center"><code>cd + /</code></td>
<td style="text-align:center">回到根目录</td>
</tr>
<tr>
<td style="text-align:center"><code>cd + ../</code></td>
<td style="text-align:center">回到当前目录的上一级</td>
</tr>
<tr>
<td style="text-align:center"><code>pwd</code></td>
<td style="text-align:center">显示当前目录</td>
</tr>
<tr>
<td style="text-align:center"><code>ls</code></td>
<td style="text-align:center">显示当前目录下的所有文件</td>
</tr>
</tbody>
</table>
<h2 id="java语言简介"><a class="markdownIt-Anchor" href="#java语言简介"></a> Java语言简介</h2>
<ul>
<li>
<p>Java语言三大模块</p>
<ol>
<li>Java SE 标准版</li>
<li>Java EE 企业版</li>
<li>Java ME 微型版</li>
</ol>
</li>
<li>
<p>Java特性</p>
<ol>
<li>简单：Java不再支持多继承、Java屏蔽了指针的概念、Java底层使用C++实现</li>
<li>面向对象：纯粹的面向对象编程</li>
<li>可移植性：Java可以一次编译，在多个平台上运行
<ul>
<li>Java程序运行在Java虚拟机JVM上，JVM运行在操作系统上，而不是直接运行在操作系统上，这样就可以屏蔽底层的差异</li>
</ul>
</li>
<li>多线程</li>
<li>健壮性：借助GC机制，也就是自动垃圾回收机制，Java语言运行中产生的垃圾可以自动回收，不需要程序员手动处理</li>
</ol>
</li>
<li>
<p>Java的加载与执行</p>
<ul>
<li>
<p>Java程序的长记性分为 <u>编译</u> 和 <u>运行</u> 两个阶段</p>
</li>
<li>
<p><u>编译</u>：将.java的源文件 转换为 .class的字节码文件</p>
<ul>
<li><code>javac</code> 命令是java编译器工具，可以在Terminal中直接使用</li>
<li>使用规则：<code>javac java源文件的路径</code></li>
<li>Java源文件在编译时可以生成多个字节码文件，字节码文件可以跨平台使用</li>
<li><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7wjly2gi1j31e80dw75n.jpg" alt="" /></li>
<li>使用javac命令后，在.java文件的目录下就会生成.class的字节码文件</li>
<li><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7wjps4dh6j312a0rkjum.jpg" alt="" /></li>
</ul>
</li>
<li>
<p><u>运行</u>：将.class的字节码文件 转化为 可执行的二进制文件</p>
<ul>
<li>
<p><code>java</code> 命令是java运行工具，java命令会启动JVM，JVM会启动 <code>ClassLoader</code> 类加载器，类加载器在硬盘上搜索字节码文件，然后将其装载到JVM上</p>
</li>
<li>
<p>使用规则</p>
<ol>
<li>首先将目录切换到字节码文件所在的目录下</li>
<li>输入 <code>java 类名</code>（注意不要加后缀名.class）！</li>
</ol>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7wjr20x2oj31ge0qw78b.jpg" alt="" /></p>
</li>
</ul>
</li>
<li>
<p>有关于 <code>javac</code> 与 <code>java</code>  命令</p>
<ul>
<li>这两个命令配置在JDK的bin目录下，而<code>echo $JAVA_HOME</code>指向了JDK的安装目录</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7wjyo0f32j31e80dwjtd.jpg" alt="" /></p>
<ul>
<li>
<p>我们需要了解系统是如何搜索一个命令的</p>
<ul>
<li>当我们输入一个命令 <code>ping 1.1.1.1</code>时，系统会在当前目录下搜索这个命令.如果当前目录下没有这个命令，那么系统会在环境变量PATH指定的路径中继续进行搜索（这个命令不止包含Java中的命令），如果还找不到的话系统会报错</li>
<li>也就是说 <strong>PATH 的作用是指定命令搜索路径</strong>，在命令行下面执行命令如<code>javac</code>编译时，它会到PATH变量所指定的路径中查找看是否能找到相应的命令程序</li>
</ul>
</li>
<li>
<p>我们还需要了解系统是如何搜索到一个类的</p>
<ul>
<li>CLASSPATH：指定类的搜索路径，要是用已经编写好的类时没需要通过这个路径找到它们</li>
<li>CLASSPATH下包含JDK安装目录下的lib子目录中的 <code>dt.jar</code> 以及 tools.jar 以及 当前目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>JVM &amp; JDK &amp; JRE之间的关系</p>
<ul>
<li>JVM：Java虚拟机，Java程序在JVM上运行</li>
<li>JRE：Java程序运行环境</li>
<li>JDK：Java开发工具包，包含JVM和JRE</li>
</ul>
</li>
</ul>
<h2 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h2>
<ul>
<li>
<p>Java程序中的注释仅出现在Java的源程序<code>.java</code>中，起到对源码说明的作用，不会出现在字节码<code>.class</code>文件中</p>
</li>
<li>
<p>注释类型</p>
<ol>
<li>单行注释</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//单行注释</span><br></pre></td></tr></table></figure>
<ol>
<li>多行注释</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">多行注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>javadoc注释</strong>：<code>javadoc</code>命令可以提取javadoc注释，自动生成帮助文档</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*javadoc注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="针对helloworld的程序解释"><a class="markdownIt-Anchor" href="#针对helloworld的程序解释"></a> 针对HelloWorld的程序解释</h2>
<ul>
<li>一个Java源文件可以定义多个类
<ul>
<li>每个<code>class</code>经过java命令的编译，都会生成对应的<code>.class</code>文件</li>
</ul>
</li>
<li>一个Java源文件可以不包含<code>public</code>类
<ul>
<li>但是一个Java源文件中只能有一个<code>public</code>类，并且这个类的名称必须和源文件的名称一直</li>
</ul>
</li>
<li>每一个类（不一定是公开类）都可以编写自己的<code>main</code>方法，每一个类都可以作为程序的入口
<ul>
<li>在命令窗口执行某一个类时，这个类必须有自己的<code>main</code>方法</li>
</ul>
</li>
</ul>
<h2 id="标识符"><a class="markdownIt-Anchor" href="#标识符"></a> 标识符</h2>
<ul>
<li>标识符包括：类名、方法名、变量名、接口名、常量名</li>
<li>命名规则：只能又数字、字母（<u>包括汉字</u>）、_、$组成，不能以数字开始，严格区分大小写，关键字不能作为标识符，长度不限</li>
<li>命名规范
<ol>
<li>类、接口名：首字母大写（记住HelloWorld）</li>
<li>变量名、方法名：首字母小写（记住main）</li>
<li>常量名：全部大写</li>
</ol>
</li>
</ul>
<h2 id="字面值"><a class="markdownIt-Anchor" href="#字面值"></a> 字面值</h2>
<ul>
<li>字面值即数据，也就是C语言中的常量值</li>
<li>包括 整型、浮点型、布尔型、字符型、字符串</li>
</ul>
<h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2>
<ul>
<li>
<p>内存中的一块空间，由 **数据类型 名称 字面值 **三部分组成</p>
</li>
<li>
<p>变量是内存中存储数据的最基本的单元</p>
</li>
<li>
<p>变量的声明和赋值可以一起完成，并且可以重复的赋值，但是只能声明一次</p>
<ul>
<li>这一点在for循环里需要注意，不能出现以下代码！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>变量的分类</p>
<ol>
<li>
<p>局部变量</p>
<p>在方法体中声明的变量叫做局部变量，局部变量在声明后必须手动的赋值进行初始化，否则不能使用！</p>
</li>
<li>
<p>成员变量</p>
<p>在方法体之外、类体之内声明的变量叫做成员变量，成员变量可以不用手动初始化，系统可以自动初始化</p>
</li>
</ol>
</li>
</ul>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<ul>
<li>
<p>数据类型主要用于指导JVM在运行程序时给不同的数据分配合适的内存空间</p>
</li>
<li>
<p>数据类型的分类</p>
<ol>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ol>
</li>
<li>
<p>基本数据类型</p>
<ul>
<li>四大类，八小种
<ol>
<li>整型：<code>byte short int long</code></li>
<li>浮点型：<code>float double</code></li>
<li>布尔型：<code>boolean</code></li>
<li>字符型：<code>char</code></li>
</ol>
</li>
<li>需要注意的是String不属于基本数据类型，属于引用数据类型</li>
<li>基本数据类型所占的空间大小</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">基本数据类型</th>
<th style="text-align:center">占用空间大小（字节）</th>
<th style="text-align:center">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-128~127</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2</td>
<td style="text-align:center">-32768~32797</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">8</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Char</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0~65535</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="字符型"><a class="markdownIt-Anchor" href="#字符型"></a> 字符型</h4>
<ul>
<li>
<p>字符编码是人为定义的，用来实现计算机二进制和文字之间的转换</p>
</li>
<li>
<p>常见的ASCII码：</p>
<ol>
<li>'a'=97</li>
<li>'A'=63</li>
<li>&quot;0&quot;=48</li>
</ol>
</li>
<li>
<p>Java使用Unicode编码（UTF-8），标识符支持中文等其他语言</p>
<ul>
<li>Unicode编码详见参考视频<sup><a href="#ref1">[1]</a></sup></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DataType.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataType</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">decimal</span> <span class="operator">=</span> ((<span class="type">int</span>)<span class="string">&#x27;中&#x27;</span>);<span class="comment">//获取中的unicode编码</span></span><br><span class="line">		System.out.println(decimal);</span><br><span class="line">		<span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> Integer.toHexString(decimal);</span><br><span class="line">		System.out.println(hex);</span><br><span class="line"></span><br><span class="line">		a = <span class="string">&#x27;\u4e2d&#x27;</span>;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果：</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7wm10wb5ij30my0940tc.jpg" alt="" /></p>
</li>
<li>
<p>转义字符 \</p>
<ul>
<li>转义字符可以将后面紧接着的字符 从 <u>普通含义</u> 转换成 特殊转义字符 或者 将 <u>特殊转义字符</u> 转换成 <u>普通字符</u></li>
<li>例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出转义字符</span></span><br><span class="line">System.out.println(<span class="string">&quot;\\&quot;</span>);<span class="comment">//将 特殊的转义字符 变成 普通的 \</span></span><br><span class="line"><span class="comment">//输出单引号</span></span><br><span class="line">System.out.println(<span class="string">&quot;\&#x27;&quot;</span>);<span class="comment">//将 特殊的&#x27; 变成 普通的 &#x27;</span></span><br><span class="line"><span class="comment">//输出制表符</span></span><br><span class="line">System.out.println(<span class="string">&quot;\t&quot;</span>);<span class="comment">//将 普通的t 变成 特殊的制表符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="整型"><a class="markdownIt-Anchor" href="#整型"></a> 整型</h4>
<ul>
<li>Java语言中的<u>默认整型</u>是<code>int</code>型，如果需要使用long，需要在字面值后添加L或者l，一般添加大写L以免混淆</li>
<li>整型字面值三种表达方式：十进制（默认），八进制（字面值以0开始），十六进制（字面值以0x开始）</li>
</ul>
<h4 id="数据类型转换"><a class="markdownIt-Anchor" href="#数据类型转换"></a> 数据类型转换</h4>
<ol>
<li>
<p>小容量向大容量转换</p>
<ul>
<li>
<p>小容量可以自动转换为大容量，称为自动类型转换机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="comment">//编译通过，123是系统默认的整型，即int，系统自动将小容量的int转换为大容量的long</span></span><br><span class="line"><span class="type">long</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2147483648</span>;</span><br><span class="line"><span class="comment">//编译报错，2147483648是系统默认的int型，但2147483648超过了int的范围</span></span><br><span class="line"><span class="comment">//将2147483648整型按照long进行处理，末尾加L</span></span><br><span class="line"><span class="type">long</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">2147483648L</span>;</span><br><span class="line"><span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>大容量向小容量转换</p>
<ul>
<li>
<p>大容量需要通过强制类型转换才能变成小容量</p>
</li>
<li>
<p>强制类型转换虽然可以通过编译，但是在运行时也有可能损失精度</p>
</li>
<li>
<p>强制类型转换的原理：将前面多余的位数忽略，取后面几位</p>
</li>
<li>
<p><u>例外</u></p>
<ul>
<li><code>byte short char</code> 类型在取值范围内时可以不需要强制类型转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//虽然10是默认的int型，但是10没有超过byte的取值范围，不需要强制类型转换</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="浮点型"><a class="markdownIt-Anchor" href="#浮点型"></a> 浮点型</h4>
<ul>
<li>
<p><code>float</code> 单精度，四个字节；<code>double</code> 双精度，八个字节</p>
</li>
<li>
<p>所有的浮点型字面值默认被当作<code>double</code>来处理，如果需要使用<code>float</code> 需要在字面值后面添加f/F</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.1</span>;</span><br><span class="line"><span class="comment">//编译报错，大精度转换为小精度需要强制类型转换</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="布尔类型"><a class="markdownIt-Anchor" href="#布尔类型"></a> 布尔类型</h4>
<p>关于布尔类型只需要注意的是，Java中的布尔类型不能用0或者1来表示</p>
<h2 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h2>
<h4 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h4>
<p>运算符中需要细节较多的只有逻辑运算符 以及 位运算符，有关于算术运算符以及关系运算符就不再赘述了，位运算符会在算法部分详细展开</p>
<p>逻辑运算符中需要格外关注的是 <strong>短路现象</strong></p>
<ul>
<li>逻辑运算运算符要求左右两边算子都是布尔类型，并且最后运算结果也是布尔类型</li>
<li>短路现象：因为某个事件的发生导致程序运行步骤改变
<ul>
<li>普通与&amp;：将运算符两边的算子都运算，两边都为真，结果才为真</li>
<li>短路与&amp;&amp;：一旦左边的算子为假，则忽视右边的算子，直接输出结果</li>
<li>短路或|| 和 普通或｜同理</li>
</ul>
</li>
<li>短路现象使运算更高效，但如果两边的算子都不得不计算时就无法使用短路现象了</li>
</ul>
<h4 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h4>
<p>赋值运算符包括：基本赋值运算符，以及 扩展赋值运算符</p>
<p>这里着重讨论扩展赋值运算符，包括：+= -= /= %=</p>
<p>--&gt;可以这样理解+=：先做加法运算，再做赋值运算</p>
<p>需要注意的是：拓展赋值运算符并不会修改运算结果的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">a = a + <span class="number">1</span>;<span class="comment">//编译报错，在做加法运算时需要强制类型转换</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">b += <span class="number">1</span>;<span class="comment">//编译通过，相当于 b = (byte)(b + 1);</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串连接运算符"><a class="markdownIt-Anchor" href="#字符串连接运算符"></a> 字符串连接运算符</h4>
<ul>
<li>“+”运算符有两个作用：
<ol>
<li>进行加法运算</li>
<li>字符串连接</li>
</ol>
</li>
<li>当 + 运算符两边的<u>都是</u>数字的话，进行加法运算，否则进行字符串连接</li>
<li>进行字符串连接后运算的结果还是字符串类型</li>
<li>一个表达式中出现多个+时，运算的优先级相同，按照从左到右的顺序依次运算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 + 2 + 3 --&gt; 6</span><br><span class="line">1 + 2 + &quot;3&quot; --&gt; 33</span><br><span class="line">1 + (2 + &quot;3&quot;) --&gt; 123</span><br></pre></td></tr></table></figure>
<h2 id="控制语句"><a class="markdownIt-Anchor" href="#控制语句"></a> 控制语句</h2>
<p>控制语句都是一些十分基础的语法，但是为了实现一些功能，这其中还涉及了一些相关的其他语法，这里单独列举出来</p>
<h4 id="接收用户键盘的输入"><a class="markdownIt-Anchor" href="#接收用户键盘的输入"></a> 接收用户键盘的输入</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.Scanner scanner ;= <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">uerInput</span> <span class="operator">=</span> scanner.next();<span class="comment">//接收用户字符串的输入</span></span><br><span class="line"><span class="type">int</span> <span class="variable">uerInput</span> <span class="operator">=</span> scanner.nextInt();<span class="comment">//接收用户整型的输入</span></span><br><span class="line"><span class="type">double</span> <span class="variable">uerInput</span> <span class="operator">=</span> scanner.nextDouble();<span class="comment">//接收用户浮点型的输入</span></span><br></pre></td></tr></table></figure>
<h4 id="判断两字符串是否相等"><a class="markdownIt-Anchor" href="#判断两字符串是否相等"></a> 判断两字符串是否相等</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a;</span><br><span class="line"><span class="type">boolean</span> a.equals(String b);<span class="comment">//当两字符串相等时返回true，否则返回false</span></span><br><span class="line">a == b;<span class="comment">//判断的是两个字符串的地址是否相同</span></span><br></pre></td></tr></table></figure>
<h4 id="switch中的case穿透现象"><a class="markdownIt-Anchor" href="#switch中的case穿透现象"></a> Switch中的case穿透现象</h4>
<ul>
<li><code>Switch</code>以及<code>case</code>后可以接<code>int String</code>类型，当接受byte short char类型时系统可以将它们直接自动转换成上述两类型</li>
<li><code>Siwtch</code>的<code>case</code>穿透现象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			java语句<span class="number">1</span>;</span><br><span class="line">			<span class="comment">//break;----&gt;case穿透现象:无论2是否匹配，直接执行Java语句2</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			java语句<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//------&gt;因为有break，所以只会执行Java语句2</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//case的合并</span></span><br><span class="line">			java语句<span class="number">3</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h4 id="控制循环语句"><a class="markdownIt-Anchor" href="#控制循环语句"></a> 控制循环语句</h4>
<ol>
<li>
<p><code>break</code>语句</p>
<ul>
<li><code>break</code>表示中断</li>
<li><code>break</code>可用在循环语句以及<code>switch</code>语句中</li>
<li>默认情况下<code>break</code>终止的是距离它最近的循环</li>
<li>当然<code>break</code>也可以中断指定的循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：break + 循环名字（需要前给每个循环取名字）0</span></span><br><span class="line">for1:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>: i++)&#123;</span><br><span class="line">  for2:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; k ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>)</span><br><span class="line">      <span class="keyword">break</span> for1;<span class="comment">//中断for1的循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>continue</code>语句</p>
<ul>
<li>continue表示继续，即忽略本轮循环中剩余的语句，直接进入下一轮循环</li>
</ul>
</li>
</ol>
<h2 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h2>
<h3 id="方法的作用"><a class="markdownIt-Anchor" href="#方法的作用"></a> 方法的作用</h3>
<p>提高代码的复用性，使得代码可以重复利用</p>
<h3 id="方法的定义"><a class="markdownIt-Anchor" href="#方法的定义"></a> 方法的定义</h3>
<p>方法是一段代码片段，这个代码片段可以完成某个特定的功能，并且可以被重复调用(invoke)</p>
<h3 id="方法的语法结构"><a class="markdownIt-Anchor" href="#方法的语法结构"></a> 方法的语法结构</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 返回值类型 方法名 (形式参数列表)&#123;</span><br><span class="line">	方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修饰符列表：<code>public static</code>
<ul>
<li>这部分是可选项，不是必须的</li>
</ul>
</li>
<li>返回值类型
<ul>
<li>这里着重强调返回值为<code>void</code>的类型
<ul>
<li>当方法结束后不返回任何数据时，返回值为void</li>
<li>返回值为<code>void</code>的方法中也可以编写 <code>return;</code> ，代表该方法执行结束(类似<code>break</code>的作用)</li>
</ul>
</li>
<li><code>return</code>语句
<ul>
<li>只要带有<code>return</code>关键字的语句被执行，则<code>return</code>语句所在的方法执行结束</li>
<li>在同一个作用域中，<code>return</code>语句下面不能编写任何代码，因为这些代码永远不会被执行</li>
</ul>
</li>
<li>在调用一个有返回值的方法时，我们可以选择接受这个值也可以选择不接受</li>
</ul>
</li>
<li>方法名
<ul>
<li>按照规范，方法名的首字母需要小写(参见<code>main</code>方法)，且需要遵循驼峰命名原则</li>
</ul>
</li>
<li>形参列表
<ul>
<li>形参数量可以有多个，也可以没有，多个形参之间由逗号隔开</li>
</ul>
</li>
</ul>
<h3 id="方法的调用"><a class="markdownIt-Anchor" href="#方法的调用"></a> 方法的调用</h3>
<p>方法如果只被定义而不调用的话，方法是不会被执行的</p>
<p>调用时的语法规则（修饰符列表中包含<code>static</code>关键字时）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类名.方法名.(实参列表)；</span><br></pre></td></tr></table></figure>
<p>在同一个类中类名可以省略不写，即类名省略时默认在同一个类中寻找方法</p>
<h3 id="u方法执行过程中的内存分配u"><a class="markdownIt-Anchor" href="#u方法执行过程中的内存分配u"></a> <u>方法执行过程中的内存分配</u></h3>
<p>方法如果只是定义而不调用的话，系统是不会为其分配其运行所需要的空间</p>
<p>JVM内存划分主要包含三大块内容</p>
<ol>
<li>方法区内存
<ul>
<li>方法代码片段属于字节码文件的一部分，字节码文件在类加载时将整个代码片段放到方法区内存当中</li>
<li>在JVM的三块内存区中，方法区内存是最先有数据的</li>
<li>代码片段虽然只有一份，但是可以被重复调用，每次调用都需要为其在栈内存分配新的、独立的内存空间</li>
</ul>
</li>
<li>栈内存
<ul>
<li>每次调用方法时，在栈内存中为其分配运行所需要的空间
<ul>
<li>这个栈空间中主要包含了这个方法内的局部变量等信息</li>
</ul>
</li>
<li>方法执行结束后，该方法所占用的空间全部释放</li>
<li>从一个方法的栈内存向另一个方法的栈内存通过形参列表传递值，传递的是数据的值而不是内存地址</li>
</ul>
</li>
<li>堆内存
<ul>
<li>等待学习...</li>
</ul>
</li>
</ol>
<h3 id="方法的重载overload"><a class="markdownIt-Anchor" href="#方法的重载overload"></a> 方法的重载Overload</h3>
<ul>
<li>作用：使功能近似的方法使用起来像一个方法一样，便于变成</li>
<li>使用条件：
<ol>
<li>在同一个类中</li>
<li>方法名相同</li>
<li>形参列表不同（包括数量不同、类型不同、顺序不同）</li>
</ol>
</li>
<li>方法重载与<u>方法名</u>和参数列表有关，与<u>修饰列表</u>和<u>返回值</u>无关</li>
</ul>
<p>Reference <a name="ref1"><font color="black">[1]https://share.api.weibo.cn/share/346380011,4823082769059607.html?weibo_id=4823082769059607</font></a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Integer类</title>
    <url>/2022/12/04/Java/Integer%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="integer类"><a class="markdownIt-Anchor" href="#integer类"></a> Integer类</h1>
<h2 id="八种包装类"><a class="markdownIt-Anchor" href="#八种包装类"></a> 八种包装类</h2>
<ul>
<li>
<p>Java中为8种 基本数据类型准备了8种包装类，这8种包装类属于引用数据类型，其父类是<code>Object</code></p>
</li>
<li>
<p>基本数据类型的缺陷</p>
<ul>
<li>无法作为参数传入某些方法中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无法向doSome方法中直接传入int型参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span>&#123;<span class="comment">//自己编写一个类将int封装起来</span></span><br><span class="line">    <span class="type">int</span> myInt;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInt</span><span class="params">(<span class="type">int</span> myInt)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myInt = myInt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		doSome(<span class="keyword">new</span> <span class="title class_">MyInt</span>(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>八种包装类</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">基本数据类型</th>
<th style="text-align:center">包装类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>byte</code></td>
<td style="text-align:center"><code>java.lang.Byte</code>（父类是<code>Number</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>short</code></td>
<td style="text-align:center"><code>java.lang.Short（父类是</code>Number<code>）</code></td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center"><code>java.lang.Integer</code>（父类是<code>Number</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center"><code>java.lang.Long</code>（父类是<code>Number</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center"><code>java.lang.Float</code>（父类是<code>Number</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center"><code>java.lang.Double</code>（父类是<code>Number</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>boolean</code></td>
<td style="text-align:center"><code>java.lang.Boolean</code>（父类是<code>Object</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center"><code>java.lang.Character</code>（父类是<code>Object</code>）</td>
</tr>
</tbody>
</table>
<h2 id="number类"><a class="markdownIt-Anchor" href="#number类"></a> Number类</h2>
<ul>
<li>
<p>抽象类，无法实例化对象</p>
</li>
<li>
<p>抽象方法</p>
<ul>
<li>负责拆箱</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">longValue</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">floatValue</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">doubleValue</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span> <span class="title function_">byteValue</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">short</span> <span class="title function_">shortValue</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><u>基本数据类型</u>向<u>引用数据类型</u>转换（<strong>装箱</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>引用数据类型向基本数据类型转换（<strong>拆箱</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> num.floatValue();<span class="comment">//10.0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num.intValue();<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>构造方法</p>
<ul>
<li>负责装箱</li>
</ul>
</li>
</ul>
<h2 id="integer的构造方法"><a class="markdownIt-Anchor" href="#integer的构造方法"></a> Integer的构造方法</h2>
<ol>
<li><code>public Integer(int value)</code>
<ul>
<li>在Java9之后不建议使用这种构造方法</li>
</ul>
</li>
<li><code>public Integer(String s)</code>
<ul>
<li>在Java9之后不建议使用这种构造方法</li>
</ul>
</li>
</ol>
<ul>
<li>
<p><strong>自动装箱/拆箱</strong></p>
<ul>
<li>
<p>自动装箱：基本数据类型自动转换为包装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>此时<code>i</code>指向的还是一块内存空间，等价于<code>Integer i = new Integer(100)</code></li>
</ul>
</li>
<li>
<p>自动拆箱：包装类自动转换为基本数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> i;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> i + <span class="number">100</span>;<span class="comment">//自动拆箱，将i变为基本数据类型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//==并不会引发自动拆箱机制，比较的是两个引用指向的地址是否相同</span></span><br><span class="line">a == b;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="integer中的常量"><a class="markdownIt-Anchor" href="#integer中的常量"></a> Integer中的常量</h2>
<blockquote>
<p>A constant holding the minimum value an int can have, $-2^{31} $</p>
<p>A constant holding the maximum value an int can have, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31} -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>   <span class="variable">MIN_VALUE</span> <span class="operator">=</span> <span class="number">0x80000000</span></span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>   <span class="variable">MAX_VALUE</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>;</span><br></pre></td></tr></table></figure>
<h2 id="整数型常量池"><a class="markdownIt-Anchor" href="#整数型常量池"></a> 整数型常量池</h2>
<ul>
<li>Java中为了提高程序的执行效率，将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>128</mn><mo>∼</mo><mn>127</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-128\sim 127]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mclose">]</span></span></span></span>之间所有的<u><strong>包装对象</strong></u>全部提前创建好，放到一个<u>方法区的</u>整数型常量池中</li>
<li>和<code>String</code>类似，整数型常量池在类（<code>Integer</code>类）加载时就会<u>提 前</u>注入方法区内存</li>
<li>是以静态代码块<code>static</code>的形式实现</li>
<li>只要用这个区间的数据，我们就不需要再创建新的对象，直接从整数型常量池中取出来即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="comment">//x引用指向的地址和y引用指向的地址是整数型常量池中的同一块地址</span></span><br><span class="line">x == y;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="comment">//128不再是常量池中的数据，因此x和y指向的是不同的对象</span></span><br><span class="line">x == y;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Cache to support the object identity semantics of autoboxing for values between -128 and 127 (inclusive) as required by JLS. The cache is initialized on first usage. （在程序运行的初始阶段就被初始化）The size of the cache may be controlled by the -XX:AutoBoxCacheMax=<size> option. During VM initialization, java.lang.Integer.IntegerCache.high property may be set and saved in the private system properties in the jdk.internal.misc.VM class.</p>
</blockquote>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8s09tq6otj30nt0irabx.jpg" alt="" /></p>
<h3 id="numberformatexception"><a class="markdownIt-Anchor" href="#numberformatexception"></a> <code>NumberFormatException</code></h3>
<ul>
<li>数字格式异常</li>
<li>针对<code>Integer(String str)</code>的构造方法，如果字符串中包含非数字的字符，会抛出“数字格式异常”</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = parseInt(s, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Constructs a newly allocated Integer object that represents the int value indicated by the String parameter. The string is converted to an int value in exactly the manner used by the parseInt method for radix 10.<br />
Params:<br />
s – the String to be converted to an Integer.<br />
Throws:<br />
NumberFormatException – if the String does not contain a parsable integer.</p>
</blockquote>
<h2 id="常用方法"><a class="markdownIt-Anchor" href="#常用方法"></a> 常用方法</h2>
<h3 id="public-static-int-parseintstring-s"><a class="markdownIt-Anchor" href="#public-static-int-parseintstring-s"></a> <code>public static int parseInt(String s)</code></h3>
<blockquote>
<p>Parses the string argument as a signed decimal integer. （将字符串转换为int型）The characters in the string must all be decimal digits,（字符型中一定得是十进制的数字，否则会抛出数字格式化异常） except that the first character may be an ASCII minus sign '-' ('\u002D') to indicate a negative value or an ASCII plus sign '+' ('\u002B') to indicate a positive value. The resulting integer value is returned, exactly as if the argument and the radix 10 were given as arguments to the parseInt(String, int) method.</p>
</blockquote>
<h3 id="十进制与其他进制的转换"><a class="markdownIt-Anchor" href="#十进制与其他进制的转换"></a> 十进制与其他进制的转换</h3>
<h4 id="public-static-string-tobinarystringint-i"><a class="markdownIt-Anchor" href="#public-static-string-tobinarystringint-i"></a> <code>public static String toBinaryString(int i)</code></h4>
<h4 id="public-static-string-tohexstringint-i"><a class="markdownIt-Anchor" href="#public-static-string-tohexstringint-i"></a> <code>public static String toHexString(int i)</code></h4>
<ul>
<li><code>Object</code>类中的<code>toStirng()</code>方法</li>
<li>将地址从十进制转换为十六进制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;	<span class="number">8</span></span><br></pre></td></tr></table></figure>
<h4 id="public-static-string-tooctalstringint-i"><a class="markdownIt-Anchor" href="#public-static-string-tooctalstringint-i"></a> <code>public static String toOctalString(int i)</code></h4>
<h3 id="public-static-integer-valueofstring-s"><a class="markdownIt-Anchor" href="#public-static-integer-valueofstring-s"></a> <code>public static Integer valueOf(String s)</code></h3>
<blockquote>
<p>Returns an Integer object holding the value of the specified String.（返回和字符串值相同的一个Integer对象） The argument is interpreted as representing a signed decimal integer, exactly as if the argument were given to the parseInt(String) method. The result is an Integer object that represents the integer value specified by the string.<br />
In other words, this method returns an Integer object equal to the value of:<br />
new Integer(Integer.parseInt(s))</p>
</blockquote>
<h3 id="string-integer以及int三种类型的相互转化"><a class="markdownIt-Anchor" href="#string-integer以及int三种类型的相互转化"></a> <code>String</code> <code>Integer</code>以及<code>int</code>三种类型的相互转化</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8s26d8wyfj31hn0u0q78.jpg" alt="" /></p>
<ul>
<li>
<p>转换成引用数据类型</p>
<ul>
<li>调用该引用数据类型的<code>Valueof()</code>方法</li>
</ul>
</li>
<li>
<p>转换成基本数据类型</p>
<ul>
<li>调用该基本类型的包装类的<code>parse()</code>方法</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 2nd Week - Summary</title>
    <url>/2022/11/23/Java/Java%20-%202nd%20Week%20-%20Summary/</url>
    <content><![CDATA[<h1 id="第二周"><a class="markdownIt-Anchor" href="#第二周"></a> 第二周</h1>
<p align="right">11.06-11.17</p>
<h3 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h3>
<p>这周所学习的内容主要是Java中面向对象的相关内容。虽然在前三年学习了很多相关的课程，自认为对面向对象的思想已经有些理解了，但如今再次回顾起来才发现自己有很多相关知识都已经忘记了，这周的学习相比于上周更加有难度。</p>
<h2 id="面向对象的编程"><a class="markdownIt-Anchor" href="#面向对象的编程"></a> 面向对象的编程</h2>
<p>###面向过程和面向对象的区别</p>
<ol>
<li>面向过程
<ul>
<li>面向过程强调的是整个流程中的前后因果关系，没有独立体的概念</li>
<li>一个步骤和一个步骤之间因为前后的因果关系组合成一个模块，一个模块和一个模块之间因为因果关系构成一个系统...</li>
<li>当其中一个因果关系破裂，整个系统都会受到影响</li>
<li><u>优点</u>：当业务逻辑简单时，可以达到快速开发的效果，前期投入成本低</li>
<li><u>缺点</u>：难以解决较为复杂的业务；高耦合，扩展性弱</li>
</ul>
</li>
<li>面向对象
<ul>
<li>将现实世界分割成不同的单元，每个单元都是一个独立的对象，在一个 确定的环境下，将各个单元协作起来，就可以构成一个系统</li>
<li>面向对象强调的是对象，将所需要的独立体以及它们的功能进行组合，即可完成整个流程</li>
<li><u>优点</u>：低耦合，扩展性强，可以实现更加复杂的业务</li>
<li><u>缺点</u>：前期投入成本高</li>
</ul>
</li>
</ol>
<h3 id="面向对象开发的三个步骤"><a class="markdownIt-Anchor" href="#面向对象开发的三个步骤"></a> 面向对象开发的三个步骤</h3>
<ol>
<li>面向对象的分析：Objected-Oriented Analysis</li>
<li>面向对象的设计：OOD</li>
<li>面向对象的编程：OOP</li>
</ol>
<h2 id="面向对象的三大特征封装-继承-多态"><a class="markdownIt-Anchor" href="#面向对象的三大特征封装-继承-多态"></a> 面向对象的三大特征：封装 继承 多态</h2>
<h3 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h3>
<h4 id="类与对象"><a class="markdownIt-Anchor" href="#类与对象"></a> 类与对象</h4>
<ul>
<li>对象：对客观事物的抽象</li>
<li>类：对对象的抽象，代表了一类具有共同特征的事物</li>
<li>类通过<u><strong>实例化</strong></u>创建对象，因此对象又被称作实例</li>
<li>对象通过<u>抽象</u>的到类</li>
</ul>
<h4 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h4>
<ul>
<li>
<p>类是对对象的抽象，而对象主要有两类信息</p>
<ol>
<li>状态信息：类的属性</li>
<li>动作信息：类的方法</li>
</ol>
</li>
<li>
<p>语法结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] class 类名&#123;</span><br><span class="line">	属性<span class="number">1</span>；</span><br><span class="line">	...</span><br><span class="line">	方法<span class="number">1</span>；</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Java中数据类型分为基本数据类型和引用数据类型，而所有的<code>class</code>都是引用数据类型</li>
</ul>
</li>
<li>
<p>属性</p>
<ul>
<li>用来描述对象的状态信息</li>
<li>属性一般都是各类数据，通常采用变量的方式来定义</li>
<li>属性变量是成员变量，可以在未初始化的情况下直接使用</li>
</ul>
</li>
<li>
<p>方法</p>
<ul>
<li>用来描述对象的动作信息，或者功能</li>
</ul>
</li>
</ul>
<h4 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h4>
<ul>
<li>
<p>对象的创建</p>
<ul>
<li>语法结构：<code>new 类名()</code></li>
<li>new运算符的作用是创建对象，在堆内存中开辟空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Student</code> 是数据类型，代表<code>stu</code>这个引用是学生类</li>
<li><code>stu</code> 是引用存放于栈内存中，存储的数据指向堆内存中<code>Student</code>对象的内存地址</li>
<li><code>new Student()</code> 是调用 <code>Student()</code>构造函数创建一个学生类的对象</li>
</ul>
</li>
<li>
<p>对象和引用</p>
<ol>
<li>对象：通过构造函数<code>/new</code>运算符在堆内存中开辟的内存空间称为对象</li>
<li>引用：
<ul>
<li><strong>引用</strong>也是一种变量，但存储的是另一个对象的<u>内存地址</u></li>
<li>Java中没有指针的概念，只能通过引用的方式去访问堆内存</li>
<li>当一个对象没有引用指向它时，它将会被自动回收</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="基本数据类型-和-引用数据类型的区别"><a class="markdownIt-Anchor" href="#基本数据类型-和-引用数据类型的区别"></a> <strong>基本数据类型</strong> 和 <strong>引用数据类型</strong>的区别</h5>
<ol>
<li>存储的数据不同
<ul>
<li>基本数据类型的数据保存数据本身</li>
<li>引用数据类型的数据保存<strong>引用值</strong>，引用值指向内存空间的一块地址，而非该内存空间上的数据本身</li>
</ul>
</li>
<li>初始化过程不同
<ul>
<li>基本数据类型在声明时系统就会为其分配内存空间</li>
<li>引用数据类型在声明时只是给变量分配了引用空间，而没有分配数据空间，并不会在堆内存中就开辟相关的空间</li>
</ul>
</li>
<li>数据传递方式不同
<ul>
<li>基本数据类型是<strong>值传递</strong>
<ul>
<li>方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一份拷贝，在方法中对这个拷贝的形参做修改，不改变实参的值</li>
</ul>
</li>
<li>引用数据类型是<strong>引用传递</strong>
<ul>
<li>方法调用时，实参的引用被传递给方法中相应的形参，在方法执行过程中，形参和实参指向同一块内存地址，方法执行后再访问该内存地址，会发现实参被改变了</li>
</ul>
</li>
<li><strong><u>参数传递的本质</u></strong>
<ul>
<li>方法调用涉及参数传递时，Java只遵循的其实只有一种机制：<strong>将变量中存储的“值”传递过去</strong>，只不过这个值有的时候时字面值，有的是内存地址</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="实例变量-和-静态变量"><a class="markdownIt-Anchor" href="#实例变量-和-静态变量"></a> 实例变量 和 静态变量</h5>
<p>二者都属于<u>成员变量</u>，定义在方法体之外，类体之中</p>
<ol>
<li>实例变量
<ul>
<li>一个类中，每个对象都具有同一种属性，但是属性的值会随着对象的不同而不同，例如用户类中的“账号”，这种属性称为实例变量。<u>只能通过对象去访问这种属性</u></li>
<li>只有创建了对象，才会为实例变量开辟内存空间</li>
<li>实例变量的访问：<code>引用.变量名</code></li>
</ul>
</li>
<li>静态变量
<ul>
<li>在类体中，用<code>static</code>关键字修饰的变量称为静态变量</li>
<li>一个类中，所有的对象都具有同一种属性，并且所有对象的这种属性的值都相同，这种属性称为静态变量</li>
<li>在初始化类时，就会为静态变量开辟内存空间</li>
<li>静态变量的访问：<code>类.变量名</code></li>
</ul>
</li>
</ol>
<h4 id="jvm内存空间"><a class="markdownIt-Anchor" href="#jvm内存空间"></a> JVM内存空间</h4>
<p>JVM内存一共被划分为三类，分别为：栈内存、方法区内存，以及堆内存</p>
<ol>
<li><strong>栈内存</strong>：一个线程拥有一个栈内存。栈内存中主要存储的是方法体中的局部变量。调用方法时，在栈内存中为其分配空间，称为压栈；方法调用结束时，释放栈内存中的空间，称为出栈</li>
<li><strong>方法区内存</strong>：一个JVM虚拟机只有一个方法区内存。方法的代码片段以及整个类的代码片段都存储于方法区内存中，成员变量中的静态变量也存储于方法区中</li>
<li><strong>堆内存</strong>：通过<code>new</code>运算符创建的对象存储于堆内存中，对象中的实例变量也存储于堆内存中</li>
</ol>
<h4 id="nullpointerexception"><a class="markdownIt-Anchor" href="#nullpointerexception"></a> <code>NullPointerException</code></h4>
<ul>
<li>空指针异常：<code>java.lang.NullPointerException</code></li>
<li>当空引用访问<u>实例相关</u>的数据时一定会发生空指针异常</li>
<li>实例相关的数据指的是这个数据的访问必须有对象的参与</li>
<li>空指针异常可以通过编译，但是在运行期间会报错！</li>
</ul>
<h3 id="封装-2"><a class="markdownIt-Anchor" href="#封装-2"></a> 封装</h3>
<h4 id="封装的作用"><a class="markdownIt-Anchor" href="#封装的作用"></a> 封装的作用</h4>
<ol>
<li>安全性：控制外部的访问</li>
<li>有效性：复杂性封装，对外提供简单的操作入口</li>
<li>复用性：使得对象可以被反复使用</li>
</ol>
<h4 id="访问控制权限"><a class="markdownIt-Anchor" href="#访问控制权限"></a> 访问控制权限</h4>
<ul>
<li>访问控制权限修饰符用来控制元素的访问范围</li>
<li>访问控制权限修饰符可以用来修饰类、变量以及方法
<ul>
<li>类只能用<code>public</code>和<code>缺省</code>修饰【内部类除外】</li>
</ul>
</li>
<li>修饰符包括：<code>public</code>, <code>protected</code>, <code>缺省</code> 以及 <code>private</code>
<ul>
<li><code>public</code>：公开的，在任何位置都可以访问</li>
<li><code>protected</code>：表示受保护的，在同一个包，以及子类中可以访问
<ul>
<li>当某个数据只希望子类使用时，采用<code>protected</code>修饰</li>
</ul>
</li>
<li>缺省：仅仅是同一个包的类下可以访问</li>
<li><code>private</code>：私有的，只能在本类中访问</li>
</ul>
</li>
<li>修饰的范围：<code>private &lt; 缺省 &lt; protected &lt; public</code></li>
</ul>
<h4 id="封装的步骤"><a class="markdownIt-Anchor" href="#封装的步骤"></a> 封装的步骤</h4>
<ol>
<li>
<p>属性/方法用访问修饰符进行修饰</p>
</li>
<li>
<p>对外提供简单的操作入口，通过这些简单的操作来修改/访问被封装的内容</p>
<ul>
<li>如果不提供操作入口，那么被封装的属性将永远不会被访问</li>
</ul>
</li>
<li>
<p><strong><code>set</code>和<code>get</code>方法</strong></p>
<ul>
<li>
<p>提供对私有属性的读写操作入口</p>
</li>
<li>
<p>语法格式</p>
<ul>
<li>
<pre class="highlight"><code class="java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(形参列表)</span>&#123;
  <span class="built_in">this</span>.value = value;
&#125;
&lt;!--code￼<span class="number">2</span>--&gt;

</code></pre>
</li>
</ul>
</li>
<li>
<p><code>set</code>和<code>get</code>函数的修饰符列表中不包含<code>static</code>，并且命名规范要遵循驼峰命名规则</p>
</li>
<li>
<p><code>set</code>和<code>get</code>函数可以在IntelliJ中自动生成：选中所需要生成<code>set</code>和<code>get</code>方法的实例变量，<code>command + N</code>选择<code>Getter and Setter</code>即可</p>
</li>
</ul>
</li>
</ol>
<h4 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h4>
<ul>
<li>构造方法又称为构造器/Constructor</li>
<li>语法结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 构造方法名(形参列表)&#123;</span><br><span class="line">	构造方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>与不同的方法相比较
<ol>
<li>构造方法不需要指定返回值类型
<ul>
<li>构造方法调用结束会返回堆地址中创建对象的<strong>引用</strong></li>
<li>构造方法的返回值类型唯一且固定，所以可以省略</li>
</ul>
</li>
<li>构造方法名和类名必须保持一致</li>
</ol>
</li>
<li><strong>构造方法的作用</strong>
<ul>
<li>通过调用构造方法在堆内存中创建对象，同时初始化实例变量</li>
</ul>
</li>
<li>构造方法的调用
<ul>
<li><code>new 构造方法(实参列表)</code></li>
</ul>
</li>
<li>实例变量的初始化
<ul>
<li>在类加载时，系统并不会初始化实例变量</li>
<li>通过构造函数来初始化实例变量</li>
</ul>
</li>
</ul>
<h5 id="缺省构造器"><a class="markdownIt-Anchor" href="#缺省构造器"></a> 缺省构造器</h5>
<ul>
<li>当一个类中没有定义任何构造方法时，系统默认为该类提供一个无参的构造方法，该方法称为缺省构造器</li>
<li>当类中显示的定义了其他构造方法时，系统就不会为器提供缺省构造器</li>
</ul>
<h5 id="构造方法的重载"><a class="markdownIt-Anchor" href="#构造方法的重载"></a> 构造方法的重载</h5>
<ul>
<li>在一个类中可以定义多个构造方法，通过不同的形参列表重载构造方法</li>
<li>由于无参构造方法经常被使用，所以我们当我们编写了带参数的构造方法后，需要手动的为当前类提供一个无参构造方法</li>
<li><strong>每调用一次构造方法，就会在堆内存中创建不同的对象</strong>，即使调用相同的构造方法</li>
</ul>
<h4 id="this关键字"><a class="markdownIt-Anchor" href="#this关键字"></a> this关键字</h4>
<h5 id="this关键字的作用"><a class="markdownIt-Anchor" href="#this关键字的作用"></a> this关键字的作用</h5>
<ul>
<li><code>this</code>关键字用于引用 方法或构造函数中的 当前对象</li>
<li><code>this</code>是一个<strong>引用变量</strong>，保存的是指向当前对象自身的地址</li>
<li><code>this</code>存储于堆内存中</li>
<li>初始化对象的过程中，都会初始化该对象的<code>this</code>关键字</li>
</ul>
<h5 id="this关键字的使用"><a class="markdownIt-Anchor" href="#this关键字的使用"></a> this关键字的使用</h5>
<ol>
<li>出现在实例方法中，用于指向当前正在执行这个动作的对象
<ul>
<li>一般通过<code>this</code>访问的都是实例变量/方法，而在访问这个实例变量/方法的大多都是该对象本身，所以<code>this.</code>可以省略</li>
<li><code>this</code>不能出现在带有<code>static</code>的方法中，不过静态的方法也不是实例方法</li>
</ul>
</li>
<li>用来区分局部变量和实例变量
<ul>
<li>常用于构造方法中，用于区分时，不能省略<code>this.</code></li>
</ul>
</li>
<li>用来调用其他构造方法
<ul>
<li>通过当前构造方法调用其他构造方法</li>
<li>语法结构<code>this(实参列表)；</code></li>
<li>用这种方法调用构造方法时，这条语句必须出现在构造方法的<strong>第一行</strong></li>
</ul>
</li>
</ol>
<h4 id="static关键字"><a class="markdownIt-Anchor" href="#static关键字"></a> static关键字</h4>
<ul>
<li>静态的</li>
<li><code>static</code>可以用来修饰变量和方法，所修饰的变量称为静态变量，所修饰的方法称为静态方法</li>
<li><code>static</code>所修饰的元素都是类级别的特征，与具体的对象无关</li>
<li>也因此，静态变量和静态方法在类加载时就初始化了，内存在方法区中开辟，不需要通过对象来初始化</li>
<li>直接通过<code>类名.</code>访问<code>static</code>所修饰内容</li>
</ul>
<h5 id="实例方法-和-静态方法"><a class="markdownIt-Anchor" href="#实例方法-和-静态方法"></a> 实例方法 和 静态方法</h5>
<p>与实例变量与静态变量的关系相似</p>
<ol>
<li>实例方法
<ul>
<li>每个对象都有具有这种行为，但是每个对象执行这个方法后所产生的结果<u>不同</u>，这样的方法称为实例方法</li>
<li>绝大部分的动作都被定义为实例方法，因为动作都需要具体的对象参与</li>
</ul>
</li>
<li>静态方法
<ul>
<li>每个对象都具有这种行为，并且每个对象执行这个方法后所产生的结果<u>相同</u>，这样的方法称为静态方法</li>
<li>静态方法的动作行为不属于某一个对象，而是可以提升至整个类级别</li>
<li>在静态方法中无法直接访问实例变量或者实例方法
<ul>
<li>调用静态方法时没有对象的参与，而实例变量和实例方法需要对象才能访问</li>
<li>可以在静态方法中创建一个对象，再去访问实例变量和实例方法</li>
<li>绝大部分的方法类工具都被定义为静态方法，可以在不创建对象的情况下调用，便于使用</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="静态变量和方法的访问"><a class="markdownIt-Anchor" href="#静态变量和方法的访问"></a> 静态变量和方法的访问</h5>
<ul>
<li>静态变量/方法可以通过<code>类名.静态变量名</code>来直接访问</li>
<li>所有的静态数据既可以通过类名的方式访问，也可以通过对象的方式访问
<ul>
<li>当通过引用（对象）来访问时，即使这个引用指向null，也不会出现空指针异常的情况</li>
<li>因为本质上是通过这个引用所在的类来访问静态的数据，不需要引用的存在！</li>
</ul>
</li>
</ul>
<h4 id="静态代码块"><a class="markdownIt-Anchor" href="#静态代码块"></a> 静态代码块</h4>
<ul>
<li>
<p>语法格式</p>
<ul>
<li>
<pre class="highlight"><code class="java"><span class="keyword">static</span>&#123;
	Java语句;
&#125;
&lt;!--code￼<span class="number">4</span>--&gt;

</code></pre>
</li>
</ul>
</li>
<li>
<p>实例代码块可以编写多个，遵循自上而下的顺序依次执行</p>
</li>
<li>
<p>实例代码块在构造函数之前执行，<u>构造函数</u>执行一次实例代码块就执行一次</p>
</li>
<li>
<p>作用</p>
<ul>
<li>实例代码块可以用来记录对象初始化时刻</li>
</ul>
</li>
</ul>
<h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3>
<h4 id="继承-2"><a class="markdownIt-Anchor" href="#继承-2"></a> 继承</h4>
<ul>
<li>继承的基本作用是<u>代码复用</u>，有了继承之后才有方法的<strong>覆盖和多态机制</strong></li>
<li>继承允许创建分等级层次的类</li>
<li><strong>继承的数据类型</strong>
<ol>
<li>私有的、缺省的不支持继承</li>
<li>父类的构造函数不支持继承</li>
<li>其余的都支持继承</li>
</ol>
</li>
<li>Java语言中只支持单继承，一个类不能同时继承很多个类（C++中支持多继承）</li>
<li>Java中的间接继承
<ul>
<li>D extends C, C extends B, B extends A，则D直接继承C，间接继承B和A</li>
</ul>
</li>
<li>当Java中一个类没有显示的继承任何类时，该类<strong>默认继承</strong>JavaSE中的<code>java.lang.Object</code>类</li>
</ul>
<h4 id="继承的语法结构"><a class="markdownIt-Anchor" href="#继承的语法结构"></a> 继承的语法结构</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表]class 父类&#123;</span><br><span class="line">	类体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[修饰符列表] class 子类名 extends 父类&#123;</span><br><span class="line">	类体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>父类又称为基类，超类(Superclass)</li>
<li>子类又称为派生类(Subclass)</li>
</ul>
<h4 id="方法的覆盖"><a class="markdownIt-Anchor" href="#方法的覆盖"></a> 方法的覆盖</h4>
<h5 id="方法的覆盖override"><a class="markdownIt-Anchor" href="#方法的覆盖override"></a> 方法的覆盖Override</h5>
<ul>
<li>又称为方法的重写Overwrite</li>
<li>当父类中的方法无法满足当前子类的要求时，子类有必要将父类继承过来的方法进行重写</li>
<li>方法重写发生在具有<strong>继承关系的父子类之间</strong></li>
<li>重写的方法必须和父类的方法的<u>返回值类型</u>、<u>方法名</u>、<u>形参列表</u>相同
<ul>
<li>直接复制粘贴父类的方法，然后修改<u>方法体</u>中内容即可</li>
</ul>
</li>
<li>子类重写的方法访问权限可以更低，但不能更高</li>
<li>抛出的异常可以更少，但不能更多</li>
</ul>
<h5 id="方法的重载overload"><a class="markdownIt-Anchor" href="#方法的重载overload"></a> 方法的重载Overload</h5>
<ul>
<li>在同一个类中，方法完成的功能相似时，建议方法名相同，这样方便编程</li>
<li>重载的方法必须
<ol>
<li>在同一个类中</li>
<li>方法名相同</li>
<li>参数列表不同</li>
</ol>
</li>
<li>方法重载与一下因素无关
<ol>
<li>返回值</li>
<li>修饰符列表</li>
</ol>
</li>
</ul>
<h4 id="final关键字"><a class="markdownIt-Anchor" href="#final关键字"></a> final关键字</h4>
<ul>
<li>表示最终的、不可变的</li>
<li><code>final</code>修饰的类是无法被继承的</li>
<li><code>final</code>修饰的方法是无法被覆盖的</li>
<li><code>final</code>修饰的变量只能被赋值一次
<ul>
<li><code>final</code>修饰的实例变量只能手动赋值，如果采用系统直接初始化的话，则之后永远为0不能修改</li>
</ul>
</li>
<li><code>final</code>修饰的引用确定好对象后无法再被修改
<ul>
<li>即这个引用指向的地址是不能修改的</li>
<li>被<code>final</code>修饰的引用所指向的对象无法被垃圾回收器回收</li>
<li>但是被<code>final</code>修饰的引用所指向的对象，它内存中存储的数据可以修改</li>
</ul>
</li>
</ul>
<h4 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h4>
<ul>
<li>
<p><code>final</code>修饰的实例变量都是不可变的，这种变量一般都和<code>static</code>联合使用，被称为常量</p>
<ul>
<li>不可变的实例变量如果在每个对象中都保存一份的话会造成空间浪费</li>
</ul>
</li>
<li>
<p>语法格式</p>
<p><code>public static final 数据类型 常量名 = 值;</code></p>
</li>
<li>
<p>常量名的命名规范：所有字母大写，每个单词之间通过下划线来连接</p>
</li>
<li>
<p>由于常量在声明后无法被修改，所以被<code>public</code>修饰也是十分安全的</p>
</li>
</ul>
<h4 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h4>
<ul>
<li>
<p>Java中引入包机制主要是为了方便程序管理。不同功能的类被分别放到不同的包当中，便于查找、管理和维护</p>
</li>
<li>
<p><code>package</code>的定义</p>
<ul>
<li>在Java源程序的第一行上编写<code>package</code>语句</li>
<li><code>package</code>只能编写一个语句</li>
<li>语法结构：<code>package 包名;</code></li>
</ul>
</li>
<li>
<p>包的命名规范：</p>
<ul>
<li>前缀 + 发起者名 + 项目名 + 模块名</li>
<li>包名要求<strong>全部小写</strong>，包名也是标识符，必须遵循标识符的命名规范</li>
</ul>
</li>
<li>
<p>一个包对应一个目录，目录之间用<code>.</code>分隔开</p>
<ul>
<li>例如：<code>pers.kevin.javase.day1117</code>就会生成四个目录</li>
</ul>
</li>
<li>
<p>一旦使用包机制后，<strong>类的名称就会改变</strong></p>
<ul>
<li>我们编写一个Test类，当使用如上的包后，Test类的名称就会变成<code>pers.kevin.javase.day1117.Test</code></li>
</ul>
</li>
<li>
<p>包名的省略</p>
<ul>
<li>
<p>当两个类在同一个包下时，可以省略包名</p>
</li>
<li>
<p>当两个类不在同一个包下时，一定要在类前加上完整的包名</p>
</li>
</ul>
</li>
</ul>
<h4 id="import关键字"><a class="markdownIt-Anchor" href="#import关键字"></a> <code>import</code>关键字</h4>
<ul>
<li><code>import</code>语句用来完成导入其他类，同一个包下的类不需要导入，不在同一个包下的类需要手动导入</li>
<li>语法格式：
<ul>
<li><code>import 类名;</code></li>
<li><code>import 包名.*;</code>代表引入这个包下的所有类</li>
</ul>
</li>
<li><code>import</code>语句需要编写到<code>package</code>语句之下，<code>class</code>语句之上</li>
<li><code>java.lang.*</code>不需要手动引入</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象、类与对象、空指针异常</title>
    <url>/2022/11/23/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11/</url>
    <content><![CDATA[<h1 id="java面向对象1"><a class="markdownIt-Anchor" href="#java面向对象1"></a> Java面向对象1</h1>
<h3 id="面向过程和面向对象的区别"><a class="markdownIt-Anchor" href="#面向过程和面向对象的区别"></a> 面向过程和面向对象的区别</h3>
<ul>
<li>面向过程强调整个流程中的前后因果关系，没有独立体的概念
<ul>
<li>一个步骤和一个步骤之间因为<strong>前后因果关系</strong>组合成一个模块，一个模块和一个模块之间因为因果关系构成一个系统，但是当因果关系破裂时，整个流程都会受到影响</li>
<li>优点：
<ol>
<li>业务逻辑简单时，可以达到快速开发的效果</li>
<li>前期投入较低</li>
</ol>
</li>
<li>缺点：
<ol>
<li>难以解决非常复杂的业务；</li>
<li>高耦合，当一个步骤出现问题时，整个系统都会收到影响；</li>
<li>缺少复用性的功能</li>
</ol>
</li>
</ul>
</li>
<li>面向对象强调的是对象，关心每个独立体所能带来的功能，忽略对象内功能的具体实现
<ul>
<li>将现实世界分割成不同的单元，每个单元都是一个独立的对象，在一个确定的环境下，将各个单元协作起来，就可以构成一个系统</li>
<li>将所需要的独立体以及它们的功能进行组合即可完成整个流程</li>
<li>优点：
<ol>
<li>低耦合</li>
<li>扩展性强</li>
<li>可以实现更加复杂的业务</li>
</ol>
</li>
<li>缺点：
<ol>
<li>前期投入成本高，需要进行大量的系统分析与设计</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h3>
<h5 id="三大特征"><a class="markdownIt-Anchor" href="#三大特征"></a> 三大特征</h5>
<p><strong><u>封装、继承、多态</u></strong></p>
<h5 id="基于面向对象开发设计三步骤"><a class="markdownIt-Anchor" href="#基于面向对象开发设计三步骤"></a> 基于面向对象开发设计三步骤</h5>
<ol>
<li>面向对象的分析：OOA：Object-Oriented-Analysis</li>
<li>面向对象的设计：OOD</li>
<li>面向对象的编程：OOP</li>
</ol>
<h3 id="类和对象的概念"><a class="markdownIt-Anchor" href="#类和对象的概念"></a> 类和对象的概念</h3>
<ul>
<li>对象：对客观事物的抽象</li>
<li>类：对对象的抽象，代表了一类具有共同特征的事物</li>
<li>实例化：类通过实例化得到对象，因此对象又被称作实例</li>
<li>抽象：对对象进行抽象的到类</li>
</ul>
<h3 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h3>
<h5 id="语法结构"><a class="markdownIt-Anchor" href="#语法结构"></a> 语法结构</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] class 类名&#123;</span><br><span class="line">	属性;</span><br><span class="line">	方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类主要描述的是 <strong>状态</strong> + <strong>动作</strong> 两种信息</p>
<ul>
<li>属性：描述的是类的状态信息</li>
<li>方法：描述的是类的动作信息</li>
</ul>
<h5 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h5>
<ul>
<li>属性通常采用变量的方法是来定义
<ul>
<li>因为状态一般都是数据信息，例如身高<code>int</code>、性别char、心情<code>String</code>等，而数据需要以变量的方式存储</li>
</ul>
</li>
<li>在类体当中，方法之外定义的变量称为<strong>成员变量</strong>
<ul>
<li>这里再次回顾 成员变量 和 局部变量之间的区别</li>
<li>成员变量在没有赋值的情况下可以直接使用，因为系统会自动对其进行初始化为<code>void</code>，存储于内存中的堆内存区</li>
<li>局部变量（定义在方法体中的变量）在声明后必须进行手动赋值才能使用，存储于内存中的栈区</li>
</ul>
</li>
</ul>
<h5 id="基本数据类型-和-引用数据类型的区别supa-hrefref11asup"><a class="markdownIt-Anchor" href="#基本数据类型-和-引用数据类型的区别supa-hrefref11asup"></a> <strong>基本数据类型</strong> 和 <strong>引用数据类型</strong>的区别<sup><a href="#ref1">[1]</a></sup></h5>
<ul>
<li>Java中所有的<code>class</code>都是<strong>引用类型</strong>，而非四大基础数据类型</li>
<li>Java中数据类型分为两大类，即四大类基本数据类型，以及引用数据类型</li>
</ul>
<ol>
<li>
<p>存储的数据不同</p>
<ul>
<li>基本数据类型
<ul>
<li>基本类型的数据保存原始值，即它存储的值就是数据本身</li>
</ul>
</li>
<li>引用数据类型
<ul>
<li>引用数据类型的数据保存的<strong>引用值</strong>，引用值指向内存空间的地址，代表某个对象的引用，二分该对象本身</li>
</ul>
</li>
</ul>
</li>
<li>
<p>初始化过程不同</p>
<ul>
<li>基本数据类型
<ul>
<li>基本类型在声明时系统就会为其分配内存空间</li>
</ul>
</li>
<li>引用数据类型
<ul>
<li>引用类型在声明时只给变量分配了引用空间，而没有分配数据空间</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据传递方式不同</p>
<ul>
<li>
<p>基本数据类型：<strong>值传递</strong></p>
<ul>
<li>方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一份拷贝，**后面方法中的操作都是对形参这个值的修改，不影响实际参数的值</li>
</ul>
</li>
<li>
<p>引用数据类型：<strong>引用传递</strong></p>
<ul>
<li>也称为传地址，方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数；在方法执行过程中，形参和实参指向同一块内存地址，**方法执行中对引用的操作将会影响到实际对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="对象的创建与使用"><a class="markdownIt-Anchor" href="#对象的创建与使用"></a> 对象的创建与使用</h3>
<ul>
<li>实例变量
<ul>
<li>在成员变量中存在实例变量和静态变量两种，这里先介绍实例变量
<ul>
<li>在一个类中，每个对象可能都有同一种数据。例如：在学生类中，每个学生的都有<code>int num</code>学号信息，但是每个对象的学号都不相同。因此要访问学号信息，必须先创建对象，通过对象来访问这个信息</li>
<li>如果不创建对象，则实例变量的内存空间是不存在的</li>
</ul>
</li>
<li>不能通过“类”直接访问的变量称为实例变量（或者对象变量）</li>
</ul>
</li>
<li>对象的创建
<ul>
<li>语法结构
<ul>
<li><code>new 类名( );</code></li>
<li><code>new</code>运算符的作用是创建<strong>对象</strong>，在JVM<u>堆内存</u>中开辟新的内存空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>
<ol>
<li><code>Student</code> 是一个引用数据类型</li>
<li><code>s</code> 是一个变量名，这个局部变量存放在栈内存中，它存储的是对象在堆内存的地址
<ul>
<li>区分引用类型变量和局部类型变量二者之间的关系：</li>
<li>这两种是对数据类型的不同的分类，局部变量和成员变量是一种分类，引用类型和基本数据类型是另一种分类。</li>
</ul>
</li>
<li><code>new Student( )</code> 是一个学生类的对象，这个对象存放在堆内存中</li>
</ol>
<ul>
<li>
<p>对象与引用</p>
<ul>
<li>
<p>new运算在堆内存中开辟的内存空间称为对象</p>
</li>
<li>
<p>引用也是一个变量，存储的是另一个Java对象的内存地址</p>
</li>
<li>
<p>Java中没有指针的概念，只能通过引用的方式去访问堆内存中对象内部的实例变量。</p>
</li>
<li>
<p>----&gt;进一步的，当一个对象没有引用指向它时，它就会被自动回收</p>
</li>
</ul>
</li>
<li>
<p>访问实例变量</p>
<ul>
<li>语法结构
<ul>
<li>读取数据：<code>引用.变量名</code></li>
<li>修改数据：<code>引用.变量 = 值</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>编写一个例子检验成员变量初始化的值，并对其进行修改</p>
<ul>
<li>首先写一个Student学生类，在学生类中定义了不同类型的属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">boolean</span> sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>再在Test类中实例化一个Student对象，检查其初始化后各个属性的默认值是多少；然后对其进行修改</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="comment">//通过引用的方式去访问成员变量</span></span><br><span class="line">		System.out.println(stu.age);<span class="comment">//int默认值为0</span></span><br><span class="line">		System.out.println(stu.name);<span class="comment">//String默认值为null</span></span><br><span class="line">		System.out.println(stu.sex);<span class="comment">//boolean默认值为false</span></span><br><span class="line">		<span class="comment">//通过引用的方式修改实例变量</span></span><br><span class="line">		stu.age = <span class="number">20</span>;</span><br><span class="line">		System.out.println(stu.age);</span><br><span class="line">		System.out.println(stu.name);</span><br><span class="line">		System.out.println(stu.sex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在<code>javac</code>编译过程中，需要保证先进入两个<code>class</code>文件共同的目录下，否则系统会报错，提示找不到<code>Student</code>类</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7yyhst6g2j30tc0fawg4.jpg" alt="" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7yyl6yacoj30tc0fawfv.jpg" alt="" /></p>
<h3 id="jvm内存区的回顾"><a class="markdownIt-Anchor" href="#jvm内存区的回顾"></a> JVM内存区的回顾</h3>
<ul>
<li>堆内存和方法区内存各有一个，一个线程有一个栈内存</li>
<li>**栈内存：**调用方法时，该方法所需要的内存空间在栈内存中分配，称为压栈；方法执行之后，该方法所分配到的空间释放，称为出栈。栈中主要存储的是方法体中的局部变量</li>
<li>**方法区内存：**方法的代码片段以及<u>整个类的代码片段</u>都被存储到方法区内存中，在类加载时这些代码会载入JVM；<u>成员变量中的静态变量也存储与方法区内存中</u></li>
<li>**栈内存：**程序执行过程中使用<code>new</code>运算符创建的对象存储在堆内存中，对象中的实例变量也存储与堆内存中</li>
</ul>
<h3 id="空指针异常"><a class="markdownIt-Anchor" href="#空指针异常"></a> 空指针异常</h3>
<ul>
<li>
<p><code>java.lang.NullPointerException</code></p>
</li>
<li>
<p>当空引用访问<u>实例相关</u>的数据时一定会发生空指针异常！</p>
</li>
<li>
<p>实例相关的数据：这个数据的访问必须有对象的参与</p>
</li>
<li>
<p>例子：</p>
<ul>
<li>编写一个丈夫类和妻子类，他们有自己的姓名，以及对方的姓名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span>&#123;</span><br><span class="line">	String name;<span class="comment">//丈夫的姓名</span></span><br><span class="line">	Wife wife;<span class="comment">//丈夫的妻子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wife</span>&#123;</span><br><span class="line">	String name;<span class="comment">//妻子的姓名</span></span><br><span class="line">	Husband husband;<span class="comment">//妻子的丈夫</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写一个结婚类使他们结婚</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Marry</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Husband</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Husband</span>();</span><br><span class="line">		h.name = <span class="string">&quot;张三&quot;</span>;<span class="comment">//初始化一个名叫张三的丈夫</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Wife</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wife</span>();</span><br><span class="line">		w.name = <span class="string">&quot;李四&quot;</span>;<span class="comment">//初始化一个名叫李四的妻子</span></span><br><span class="line">		<span class="comment">//展示初始化之前对方的伴侣的名字</span></span><br><span class="line">		printName(h);</span><br><span class="line">		printName(w);</span><br><span class="line">    <span class="comment">//结婚</span></span><br><span class="line">		marry(h,w);</span><br><span class="line">    <span class="comment">//展示结婚后对方伴侣的名字</span></span><br><span class="line">		printName(h);</span><br><span class="line">		printName(w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//使 h 和 w 结婚</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Husband h, Wife w)</span>&#123;</span><br><span class="line">		h.wife = w;</span><br><span class="line">		w.husband = h;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//展示丈夫妻子的名字</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(Husband h)</span>&#123;</span><br><span class="line">		System.out.println(h.wife.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//展示妻子丈夫的名字</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(Wife w)</span>&#123;</span><br><span class="line">		System.out.println(w.husband.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7z0hcsug4j30tc0famxw.jpg" alt="" /></p>
<ul>
<li>在注释掉 展示初始化之前对方的伴侣的名字 这两行代码后，程序正常运行！</li>
<li>空指针异常可以通过编译，因为其语法没有任何问题，但是在运行期间会报错！</li>
<li>当<code>Husband h = new Husband();</code>时，会初始化一个为空的<code>Husband</code>对象，同时初始化了该<code>Husband</code>对象中wife这个引用成员变量，这个<code>wife</code>引用成员变量会被初始化为<code>null</code>。当在程序第9行时，我们用该空的引用变量去访问了<code>Wife</code>这个类中的实例变量<code>name</code>，因此程序报错！</li>
</ul>
</li>
</ul>
<p>Reference <a name="ref1"><font color="black">[1]https://zycode1561.github.io/2019/12/07/基本类型和引用类型的区别</font></a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数组练习</title>
    <url>/2022/11/30/Java/Java%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="java练习"><a class="markdownIt-Anchor" href="#java练习"></a> Java练习</h1>
<h2 id="用数组模拟栈"><a class="markdownIt-Anchor" href="#用数组模拟栈"></a> 用数组模拟栈</h2>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<ul>
<li>使用一个一维数组模拟栈的数据结构</li>
<li>这个栈可以存储Java中任何的引用类型的数据</li>
<li>在栈中提供push方法模拟压栈（栈满有提示）</li>
<li>在栈中提供pop方法模拟弹栈（栈空有提示）</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] mySatck;<span class="comment">//Object数据类型就可以存储任何类型的引用数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;<span class="comment">//指向栈顶的指针(下一个压栈元素要进入的位置)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> len;<span class="comment">//栈的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (check() &gt; <span class="number">0</span>)&#123;<span class="comment">//栈满则不能在入栈</span></span><br><span class="line">            System.out.println(<span class="string">&quot;栈满，无法入栈&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(obj + <span class="string">&quot;  成功入栈&quot;</span>);<span class="comment">//调用Object的toString方法</span></span><br><span class="line">        mySatck[top++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (check() &lt; <span class="number">0</span>)&#123;<span class="comment">//栈空则不能出栈</span></span><br><span class="line">            System.out.println(<span class="string">&quot;栈空，无法出栈&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> mySatck[--top];</span><br><span class="line">        System.out.println(obj + <span class="string">&quot; 成功出栈&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">(Object[] mySatck)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mySatck = mySatck;</span><br><span class="line">        <span class="built_in">this</span>.top = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.len = mySatck.length;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//判断栈状态的方法</span></span><br><span class="line">  	<span class="comment">//栈满返回1，栈空返回-1，正常返回0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == len)&#123;<span class="comment">//栈满</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (top == <span class="number">0</span>) &#123;<span class="comment">//栈空</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Animal[] animals = <span class="keyword">new</span> <span class="title class_">Animal</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">MyStack</span> <span class="variable">myStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStack</span>(animals);</span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Husky&quot;</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fish</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&quot;Mary&quot;</span>,<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//将每个元素如栈</span></span><br><span class="line">        myStack.push(animal1);</span><br><span class="line">        myStack.push(animal2);</span><br><span class="line">        myStack.push(animal3);</span><br><span class="line">        myStack.push(animal4);<span class="comment">//此时应该有提示</span></span><br><span class="line"></span><br><span class="line">      	<span class="comment">//将栈中所有元素弹出</span></span><br><span class="line">        <span class="keyword">while</span> (myStack.check() != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> myStack.pop();</span><br><span class="line">          	<span class="comment">//弹出并调用该对象的特殊方法</span></span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Animal)&#123;</span><br><span class="line">                <span class="type">Animal</span> <span class="variable">ani</span> <span class="operator">=</span> (Animal) obj;</span><br><span class="line">                display(ani);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;EORROR&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Animal animal)</span>&#123;</span><br><span class="line">        animal.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is moving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//每写一个类都要重载其toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name + <span class="string">&quot; is a &quot;</span> + type + <span class="string">&quot; dog and it&#x27;s running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, String type)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);<span class="comment">//调用父类构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name + <span class="string">&quot; is swimming at the speed of &quot;</span> + speed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fish</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fish</span><span class="params">(String name, <span class="type">int</span> speed)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name + <span class="string">&quot; in &quot;</span> + color + <span class="string">&quot; is flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bird</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bird</span><span class="params">(String name, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8naazq8g9j30fv0e5mxr.jpg" alt="" /></p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<ul>
<li><code>Object</code>类型的数组可以存储任何类型的引用类型数据
<ul>
<li><code>Object[] arr = &#123;new Animal(), new Uer(), &quot;abc&quot;&#125;</code></li>
<li>这些元素之间
<ul>
<li>可以有关系：所有的元素都是同一个类，或者它们之间有继承关系</li>
<li>也可以没有关系</li>
</ul>
</li>
</ul>
</li>
<li>调用一个对象时，默认调用的是该对象所在类的<code>toString()</code>方法</li>
<li>当方法必须有返回值时，又需要返回一个空或者错误信息
<ul>
<li>返回<code>null</code></li>
</ul>
</li>
<li>每写一个类都要重载其<code>toString()</code>和<code>equals()</code>方法</li>
</ul>
<h2 id="模拟酒店预定系统"><a class="markdownIt-Anchor" href="#模拟酒店预定系统"></a> 模拟酒店预定系统</h2>
<h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3>
<ul>
<li>为某个酒店编写程序：酒店管理系统，模拟退房、订房、打印所有房间状态</li>
<li>酒店使用一个二维数组来模拟：<code>Room[][] rooms</code></li>
<li>酒店中每一个房间应该是一个对象<code>Room</code></li>
<li>每个房间应该有：房间号、房间类型、房间状态</li>
<li>对外提供的功能：
<ul>
<li>预定房间：输入房间号，订房</li>
<li>退房：输入房间号，退房</li>
<li>查看所有房间状态</li>
</ul>
</li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHotel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Room[][] rooms;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> floorNum;<span class="comment">//楼层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> roomNum;<span class="comment">//每一层的房间数</span></span><br><span class="line">		<span class="comment">//预定房间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reserve</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] locate = check(number);<span class="comment">//通过房间号获得房间的楼层、房间信息</span></span><br><span class="line">        <span class="keyword">if</span> (locate[<span class="number">0</span>] &lt; <span class="number">0</span> || locate[<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号码错误！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].getState())&#123;<span class="comment">//房间如果还未预定出去</span></span><br><span class="line">            rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].setState(<span class="literal">true</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号为：&quot;</span> + number + <span class="string">&quot;的房间预定成功！&quot;</span>);</span><br><span class="line">            System.out.println(rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].toString());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号为：&quot;</span> + number + <span class="string">&quot;的房间已经被预订！&quot;</span>);</span><br><span class="line">          	System.out.println(rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//退房</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkOut</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] locate = check(number);</span><br><span class="line">        <span class="keyword">if</span> (locate[<span class="number">0</span>] &lt; <span class="number">0</span> || locate[<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号码错误！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].getState())&#123;<span class="comment">//房间如果已经被预定出去</span></span><br><span class="line">            rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].setState(<span class="literal">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号为：&quot;</span> + number + <span class="string">&quot;的房间归还成功！&quot;</span>);</span><br><span class="line">            System.out.println(rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].toString());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号为：&quot;</span> + number + <span class="string">&quot;的房间还为被预订！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//显示酒店里所有房间的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; floorNum; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; roomNum; j++)&#123;</span><br><span class="line">                System.out.println(rooms[i][j].toString());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入房间号，返回它的楼层和房间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] check(<span class="type">int</span> num)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>)<span class="comment">//房间号不能为负</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">room</span> <span class="operator">=</span> <span class="number">0</span>, floor = <span class="number">0</span>;</span><br><span class="line">        room = num % <span class="number">100</span>;<span class="comment">//房间号是号码的后两位</span></span><br><span class="line">        <span class="keyword">if</span> (room &gt; roomNum)<span class="comment">//房间号非法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        floor = num / <span class="number">100</span>;<span class="comment">//楼层号是号码的前几位</span></span><br><span class="line">        <span class="keyword">if</span> (floor &gt; floorNum)<span class="comment">//楼层号非法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;--floor,--room&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHotel</span><span class="params">(Room[][] rooms)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rooms = rooms;</span><br><span class="line">        <span class="built_in">this</span>.floorNum = rooms.length;</span><br><span class="line">        <span class="built_in">this</span>.roomNum = rooms[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> floor;<span class="comment">//楼层</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> room;<span class="comment">//房间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> state;<span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">private</span> String type;<span class="comment">//类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Room</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Room</span><span class="params">(<span class="type">int</span> floor, <span class="type">int</span> room, String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.floor = floor-<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.room = room-<span class="number">1</span>;</span><br><span class="line">      	<span class="comment">//通过楼层和房间获取编号</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        stringBuffer.append(floor);</span><br><span class="line">      	<span class="comment">//如果房间号只有一位，则需要补一个0，例如509</span></span><br><span class="line">        <span class="keyword">if</span> (room &lt; <span class="number">10</span>)</span><br><span class="line">            stringBuffer.append(<span class="number">0</span>);</span><br><span class="line">        stringBuffer.append(room);</span><br><span class="line">      	<span class="comment">//房间编号是楼层号和房间号好的拼接</span></span><br><span class="line">        <span class="built_in">this</span>.num = Integer.valueOf(stringBuffer.toString());</span><br><span class="line">      	<span class="comment">//默认没有人住</span></span><br><span class="line">        <span class="built_in">this</span>.state = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//重载toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot; [房间号： &quot;</span> + <span class="built_in">this</span>.getNum() + <span class="string">&quot; 类型： &quot;</span> + <span class="built_in">this</span>.getType() + <span class="string">&quot; 状态： &quot;</span> + <span class="built_in">this</span>.getState() + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//重载equals</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || !(obj <span class="keyword">instanceof</span> Room))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> (Room) obj;</span><br><span class="line">        <span class="keyword">return</span> room.getNum()==<span class="built_in">this</span>.num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">boolean</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">//此时rooms还是为空引用，不能用于构造MyHotel</span></span><br><span class="line">        Room[][] rooms = <span class="keyword">new</span> <span class="title class_">Room</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">              	<span class="comment">//前五个房间为单人间，后五个房间为双人间</span></span><br><span class="line">                <span class="keyword">if</span>(j &lt; <span class="number">5</span>)&#123;</span><br><span class="line">                    rooms[i][j] = <span class="keyword">new</span> <span class="title class_">Room</span>(i+<span class="number">1</span>,j+<span class="number">1</span>,<span class="string">&quot;单人间&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    rooms[i][j] = <span class="keyword">new</span> <span class="title class_">Room</span>(i+<span class="number">1</span>,j+<span class="number">1</span>,<span class="string">&quot;双人间&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyHotel</span> <span class="variable">myHotel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHotel</span>(rooms);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎使用酒店管理系统，请选择相关功能&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\t1:显示所有房间信息&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\t2:预定房间&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\t3:退房&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\t4:退出系统&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fun</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (fun)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;显示所有房间信息&quot;</span>);</span><br><span class="line">                    myHotel.display();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;预定房间\t请输入房间编号&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    myHotel.reserve(num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;退房\t请输入房间编号&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    myHotel.checkOut(num2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;谢谢&quot;</span>);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;请重新输入&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8nay8el91j30jk1b9diy.jpg" alt="" /></p>
<h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
<ul>
<li>
<p><code>equals</code>方法的重载格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">      	<span class="comment">//先判断是否为空或者是否类型相匹配</span></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || !(obj <span class="keyword">instanceof</span> Room))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      	<span class="comment">//在判断引用是否指向同一块空间</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      	<span class="comment">//强制类型转换</span></span><br><span class="line">        <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> (Room) obj;</span><br><span class="line">      	<span class="comment">//直接返回判定的结果</span></span><br><span class="line">        <span class="keyword">return</span> room.getNum()==<span class="built_in">this</span>.num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多态2</title>
    <url>/2022/11/23/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111/</url>
    <content><![CDATA[<h1 id="多态2"><a class="markdownIt-Anchor" href="#多态2"></a> 多态2</h1>
<h3 id="方法覆盖"><a class="markdownIt-Anchor" href="#方法覆盖"></a> 方法覆盖</h3>
<ol>
<li>
<p>私有方法无法覆盖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father&#x27;s Private Method is Exucted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        father.Print();<span class="comment">//只有在Father类中才能访问私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="comment">//继承的方法访问权限不能低于父类方法</span></span><br><span class="line">    <span class="comment">//子类可以扩展父类的功能，但不能改变父类的功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son&#x27;s Public Method is Exucted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">      	<span class="comment">//在外部类中无法访问私有方法</span></span><br><span class="line">        <span class="comment">//father.Print();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8a8za5eeoj30u80bi0tj.jpg" alt="" /></p>
</li>
<li>
<p>方法覆盖中的返回值类型</p>
<ul>
<li>方法覆盖的条件
<ol>
<li>具有继承关系的两个类</li>
<li>子类方法和父类方法具有相同的：方法名、形参列表，和相同的返回值类型</li>
</ol>
</li>
<li>当返回值类型是基本数据类型时，不允许修改</li>
<li>当返回值类型是引用数据类型时，子类可以的返回值可以变小，但不能变大
<ul>
<li>父类返回一个<code>Animal</code>类时，子类可以返回<code>Animal</code>或者<code>Cat</code>类，但不能返回<code>Animal</code>的父类</li>
</ul>
</li>
</ul>
</li>
<li>
<p>不能被继承的方法也不能被覆盖</p>
<ul>
<li>继承：子类可以使用父类的一些成员变量和方法</li>
<li>覆盖：子类方法覆盖父类方法，要求覆盖的方法必须和父类的方法<u>方法名</u>和<u>参数</u>都相同</li>
<li>覆盖就是因为原来父类中的方法不能满足子类的要求，所以在子类中要重写父类的方法</li>
<li>如果无法继承，即子类无法使用父类的方法，那何谈重写呢，直接在子类中<u>重新定义</u>一个方法即可</li>
</ul>
</li>
<li>
<p>方法覆盖只针对实例方法，<strong>静态方法的覆盖没有意义</strong></p>
<ul>
<li><u>方法覆盖和多态机制联合起来使用才有意义</u>
<ul>
<li><code>Animal animal = new Cat()</code></li>
<li><code>animal.move()</code></li>
<li>如果没有覆盖，则<code>animal</code>这个父类引用即使指向了子类对象，它调用的<code>move()</code>方法还都是一个结果</li>
</ul>
</li>
<li>多态需要子类对象的参与，然而静态方法的执行与对象无关</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal doSome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat doSome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">//通过引用调用静态方法也可以</span></span><br><span class="line">        <span class="comment">//但本质上是通过引用所在的类调用该静态方法</span></span><br><span class="line">        animal.Print();</span><br><span class="line">        Cat.Print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8a8i56935j30ua0cqdgl.jpg" alt="" /></p>
</li>
</ol>
<h2 id="super关键字"><a class="markdownIt-Anchor" href="#super关键字"></a> <code>super</code>关键字</h2>
<ul>
<li>
<p><code>this</code>关键字</p>
<ul>
<li><code>this</code>只能用于构造方法和实例方法中
<ul>
<li>出现在构造方法中用于调用其他构造方法</li>
<li>出现在实例方法中用于指向调用该实例方法的对象</li>
</ul>
</li>
<li><code>this</code>不能在静态方法中使用</li>
<li>语法格式
<ul>
<li><code>this.</code> 用于区分局部变量和实例变量时不能省略</li>
<li><code>this()</code> 只能出现在构造方法的第一行，用于调用本类中其他的构造函数</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>super</code>关键字</p>
<ul>
<li><code>super</code>只能出现在实例方法和构造方法中</li>
<li><code>super</code>不能在静态方法中使用</li>
</ul>
</li>
<li>
<p><code>super()</code></p>
<ul>
<li>表示通过子类的构造方法去调用父类的构造方法</li>
<li>当子类的构造方法第一个行没有显示的说明调用父类<code>super()</code>或者本类<code>this()</code> 哪种构造方法时，默认调用<code>super()</code>
<ul>
<li>表示通过当前子类的构造方法去调用父类无参数的构造方法</li>
<li>此时必须保证父类的无参构造方法是存在的</li>
</ul>
</li>
<li><code>super()</code>必须出现在子类构造函数的第一行
<ul>
<li>这也意味着一个构造方法中只能出现一个<code>super()</code>，否则第二个就只能出现在第二行</li>
<li><code>this()</code> 和<code>super()</code>不能共存，因为它们都要求出现在构造方法的第一行</li>
</ul>
</li>
<li><strong>无论什么情况，父类的构造方法都会执行！！</strong>
<ul>
<li>先有父亲，才会有儿子</li>
<li>在构造任何方法时，都会第一个执行（非调用Object类的构造方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">        <span class="comment">//super();省略调用Object的构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;父类无参数构造方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//super();省略调用Father的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>);<span class="comment">//调用本类其他的构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类无参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="comment">//super();省略调用Father的构造方法</span></span><br><span class="line">      	<span class="comment">//只是省略无参的super()，如果需要调用有参数的super需要手动声明</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类有参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8agwv67ipj30vk0gcwfv.jpg" alt="" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="number">10</span>);</span><br><span class="line">      	<span class="comment">//因为在子类有参构造方法中采用了默认的无参数的super()，所以不会调用有参数的super(int i)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ah06h88nj30vs0feq46.jpg" alt="" /></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;<span class="comment">//第五个被调用</span></span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//第四个被调用</span></span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;<span class="comment">//第一个被调用</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//第二个被调用</span></span><br><span class="line">        <span class="built_in">this</span>(i,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;<span class="comment">//第三个被调用</span></span><br><span class="line">        <span class="built_in">super</span>(j);</span><br><span class="line">        System.out.println(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      	<span class="comment">//后被调用的先执行</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ahjs5w5gj30u20e23z3.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>访问控制权限&quot;</title>
    <url>/2022/11/23/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110/</url>
    <content><![CDATA[<h1 id="访问控制权限"><a class="markdownIt-Anchor" href="#访问控制权限"></a> 访问控制权限</h1>
<h3 id="访问控制权限修饰符"><a class="markdownIt-Anchor" href="#访问控制权限修饰符"></a> 访问控制权限修饰符</h3>
<ul>
<li>访问控制权限修饰符用来控制元素的访问范围</li>
<li>修饰符包括：<code>public</code>, <code>protected</code>, <code>缺省</code> 以及 <code>private</code></li>
<li>访问控制权限可以修饰 类 变量 方法</li>
<li>修饰的范围：<code>private &lt; 缺省 &lt; protected &lt; public</code></li>
<li>类只能用<code>public</code>和<code>缺省</code>修饰【内部类除外】</li>
</ul>
<h4 id="public"><a class="markdownIt-Anchor" href="#public"></a> public</h4>
<ul>
<li>表示公开的，在任何位置都可以访问</li>
</ul>
<h4 id="protected"><a class="markdownIt-Anchor" href="#protected"></a> protected</h4>
<ul>
<li>表示受保护的，在同一个包，以及子类中可以访问</li>
<li>当某个数据只希望子类使用时，采用<code>protected</code>修饰</li>
</ul>
<h4 id="缺省"><a class="markdownIt-Anchor" href="#缺省"></a> 缺省</h4>
<ul>
<li>仅仅是同一个包下可以访问</li>
</ul>
<h4 id="private"><a class="markdownIt-Anchor" href="#private"></a> private</h4>
<ul>
<li>私有的，只能在本类中访问</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数组练习</title>
    <url>/2022/11/30/Java/Java%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="java练习"><a class="markdownIt-Anchor" href="#java练习"></a> Java练习</h1>
<h2 id="用数组模拟栈"><a class="markdownIt-Anchor" href="#用数组模拟栈"></a> 用数组模拟栈</h2>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<ul>
<li>使用一个一维数组模拟栈的数据结构</li>
<li>这个栈可以存储Java中任何的引用类型的数据</li>
<li>在栈中提供push方法模拟压栈（栈满有提示）</li>
<li>在栈中提供pop方法模拟弹栈（栈空有提示）</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] mySatck;<span class="comment">//Object数据类型就可以存储任何类型的引用数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;<span class="comment">//指向栈顶的指针(下一个压栈元素要进入的位置)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> len;<span class="comment">//栈的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (check() &gt; <span class="number">0</span>)&#123;<span class="comment">//栈满则不能在入栈</span></span><br><span class="line">            System.out.println(<span class="string">&quot;栈满，无法入栈&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(obj + <span class="string">&quot;  成功入栈&quot;</span>);<span class="comment">//调用Object的toString方法</span></span><br><span class="line">        mySatck[top++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (check() &lt; <span class="number">0</span>)&#123;<span class="comment">//栈空则不能出栈</span></span><br><span class="line">            System.out.println(<span class="string">&quot;栈空，无法出栈&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> mySatck[--top];</span><br><span class="line">        System.out.println(obj + <span class="string">&quot; 成功出栈&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">(Object[] mySatck)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mySatck = mySatck;</span><br><span class="line">        <span class="built_in">this</span>.top = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.len = mySatck.length;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//判断栈状态的方法</span></span><br><span class="line">  	<span class="comment">//栈满返回1，栈空返回-1，正常返回0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top == len)&#123;<span class="comment">//栈满</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (top == <span class="number">0</span>) &#123;<span class="comment">//栈空</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Animal[] animals = <span class="keyword">new</span> <span class="title class_">Animal</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">MyStack</span> <span class="variable">myStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStack</span>(animals);</span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Husky&quot;</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fish</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&quot;Mary&quot;</span>,<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"></span><br><span class="line">      	<span class="comment">//将每个元素如栈</span></span><br><span class="line">        myStack.push(animal1);</span><br><span class="line">        myStack.push(animal2);</span><br><span class="line">        myStack.push(animal3);</span><br><span class="line">        myStack.push(animal4);<span class="comment">//此时应该有提示</span></span><br><span class="line"></span><br><span class="line">      	<span class="comment">//将栈中所有元素弹出</span></span><br><span class="line">        <span class="keyword">while</span> (myStack.check() != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> myStack.pop();</span><br><span class="line">          	<span class="comment">//弹出并调用该对象的特殊方法</span></span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Animal)&#123;</span><br><span class="line">                <span class="type">Animal</span> <span class="variable">ani</span> <span class="operator">=</span> (Animal) obj;</span><br><span class="line">                display(ani);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;EORROR&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Animal animal)</span>&#123;</span><br><span class="line">        animal.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is moving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//每写一个类都要重载其toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name + <span class="string">&quot; is a &quot;</span> + type + <span class="string">&quot; dog and it&#x27;s running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, String type)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);<span class="comment">//调用父类构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name + <span class="string">&quot; is swimming at the speed of &quot;</span> + speed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fish</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fish</span><span class="params">(String name, <span class="type">int</span> speed)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name + <span class="string">&quot; in &quot;</span> + color + <span class="string">&quot; is flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bird</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bird</span><span class="params">(String name, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8naazq8g9j30fv0e5mxr.jpg" alt="" /></p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<ul>
<li><code>Object</code>类型的数组可以存储任何类型的引用类型数据
<ul>
<li><code>Object[] arr = &#123;new Animal(), new Uer(), &quot;abc&quot;&#125;</code></li>
<li>这些元素之间
<ul>
<li>可以有关系：所有的元素都是同一个类，或者它们之间有继承关系</li>
<li>也可以没有关系</li>
</ul>
</li>
</ul>
</li>
<li>调用一个对象时，默认调用的是该对象所在类的<code>toString()</code>方法</li>
<li>当方法必须有返回值时，又需要返回一个空或者错误信息
<ul>
<li>返回<code>null</code></li>
</ul>
</li>
<li>每写一个类都要重载其<code>toString()</code>和<code>equals()</code>方法</li>
</ul>
<h2 id="模拟酒店预定系统"><a class="markdownIt-Anchor" href="#模拟酒店预定系统"></a> 模拟酒店预定系统</h2>
<h3 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h3>
<ul>
<li>为某个酒店编写程序：酒店管理系统，模拟退房、订房、打印所有房间状态</li>
<li>酒店使用一个二维数组来模拟：<code>Room[][] rooms</code></li>
<li>酒店中每一个房间应该是一个对象<code>Room</code></li>
<li>每个房间应该有：房间号、房间类型、房间状态</li>
<li>对外提供的功能：
<ul>
<li>预定房间：输入房间号，订房</li>
<li>退房：输入房间号，退房</li>
<li>查看所有房间状态</li>
</ul>
</li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHotel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Room[][] rooms;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> floorNum;<span class="comment">//楼层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> roomNum;<span class="comment">//每一层的房间数</span></span><br><span class="line">		<span class="comment">//预定房间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reserve</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] locate = check(number);<span class="comment">//通过房间号获得房间的楼层、房间信息</span></span><br><span class="line">        <span class="keyword">if</span> (locate[<span class="number">0</span>] &lt; <span class="number">0</span> || locate[<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号码错误！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].getState())&#123;<span class="comment">//房间如果还未预定出去</span></span><br><span class="line">            rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].setState(<span class="literal">true</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号为：&quot;</span> + number + <span class="string">&quot;的房间预定成功！&quot;</span>);</span><br><span class="line">            System.out.println(rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].toString());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号为：&quot;</span> + number + <span class="string">&quot;的房间已经被预订！&quot;</span>);</span><br><span class="line">          	System.out.println(rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//退房</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkOut</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] locate = check(number);</span><br><span class="line">        <span class="keyword">if</span> (locate[<span class="number">0</span>] &lt; <span class="number">0</span> || locate[<span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号码错误！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].getState())&#123;<span class="comment">//房间如果已经被预定出去</span></span><br><span class="line">            rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].setState(<span class="literal">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号为：&quot;</span> + number + <span class="string">&quot;的房间归还成功！&quot;</span>);</span><br><span class="line">            System.out.println(rooms[locate[<span class="number">0</span>]][locate[<span class="number">1</span>]].toString());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;房间号为：&quot;</span> + number + <span class="string">&quot;的房间还为被预订！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//显示酒店里所有房间的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; floorNum; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; roomNum; j++)&#123;</span><br><span class="line">                System.out.println(rooms[i][j].toString());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入房间号，返回它的楼层和房间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] check(<span class="type">int</span> num)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>)<span class="comment">//房间号不能为负</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">room</span> <span class="operator">=</span> <span class="number">0</span>, floor = <span class="number">0</span>;</span><br><span class="line">        room = num % <span class="number">100</span>;<span class="comment">//房间号是号码的后两位</span></span><br><span class="line">        <span class="keyword">if</span> (room &gt; roomNum)<span class="comment">//房间号非法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        floor = num / <span class="number">100</span>;<span class="comment">//楼层号是号码的前几位</span></span><br><span class="line">        <span class="keyword">if</span> (floor &gt; floorNum)<span class="comment">//楼层号非法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;--floor,--room&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHotel</span><span class="params">(Room[][] rooms)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rooms = rooms;</span><br><span class="line">        <span class="built_in">this</span>.floorNum = rooms.length;</span><br><span class="line">        <span class="built_in">this</span>.roomNum = rooms[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> floor;<span class="comment">//楼层</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> room;<span class="comment">//房间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> state;<span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">private</span> String type;<span class="comment">//类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Room</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Room</span><span class="params">(<span class="type">int</span> floor, <span class="type">int</span> room, String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.floor = floor-<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.room = room-<span class="number">1</span>;</span><br><span class="line">      	<span class="comment">//通过楼层和房间获取编号</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        stringBuffer.append(floor);</span><br><span class="line">      	<span class="comment">//如果房间号只有一位，则需要补一个0，例如509</span></span><br><span class="line">        <span class="keyword">if</span> (room &lt; <span class="number">10</span>)</span><br><span class="line">            stringBuffer.append(<span class="number">0</span>);</span><br><span class="line">        stringBuffer.append(room);</span><br><span class="line">      	<span class="comment">//房间编号是楼层号和房间号好的拼接</span></span><br><span class="line">        <span class="built_in">this</span>.num = Integer.valueOf(stringBuffer.toString());</span><br><span class="line">      	<span class="comment">//默认没有人住</span></span><br><span class="line">        <span class="built_in">this</span>.state = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//重载toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot; [房间号： &quot;</span> + <span class="built_in">this</span>.getNum() + <span class="string">&quot; 类型： &quot;</span> + <span class="built_in">this</span>.getType() + <span class="string">&quot; 状态： &quot;</span> + <span class="built_in">this</span>.getState() + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//重载equals</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || !(obj <span class="keyword">instanceof</span> Room))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> (Room) obj;</span><br><span class="line">        <span class="keyword">return</span> room.getNum()==<span class="built_in">this</span>.num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">boolean</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">//此时rooms还是为空引用，不能用于构造MyHotel</span></span><br><span class="line">        Room[][] rooms = <span class="keyword">new</span> <span class="title class_">Room</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">              	<span class="comment">//前五个房间为单人间，后五个房间为双人间</span></span><br><span class="line">                <span class="keyword">if</span>(j &lt; <span class="number">5</span>)&#123;</span><br><span class="line">                    rooms[i][j] = <span class="keyword">new</span> <span class="title class_">Room</span>(i+<span class="number">1</span>,j+<span class="number">1</span>,<span class="string">&quot;单人间&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    rooms[i][j] = <span class="keyword">new</span> <span class="title class_">Room</span>(i+<span class="number">1</span>,j+<span class="number">1</span>,<span class="string">&quot;双人间&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyHotel</span> <span class="variable">myHotel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHotel</span>(rooms);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎使用酒店管理系统，请选择相关功能&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\t1:显示所有房间信息&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\t2:预定房间&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\t3:退房&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;\t4:退出系统&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fun</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (fun)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;显示所有房间信息&quot;</span>);</span><br><span class="line">                    myHotel.display();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;预定房间\t请输入房间编号&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    myHotel.reserve(num1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;退房\t请输入房间编号&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    myHotel.checkOut(num2);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;谢谢&quot;</span>);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;请重新输入&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8nay8el91j30jk1b9diy.jpg" alt="" /></p>
<h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
<ul>
<li>
<p><code>equals</code>方法的重载格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">      	<span class="comment">//先判断是否为空或者是否类型相匹配</span></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || !(obj <span class="keyword">instanceof</span> Room))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      	<span class="comment">//在判断引用是否指向同一块空间</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      	<span class="comment">//强制类型转换</span></span><br><span class="line">        <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> (Room) obj;</span><br><span class="line">      	<span class="comment">//直接返回判定的结果</span></span><br><span class="line">        <span class="keyword">return</span> room.getNum()==<span class="built_in">this</span>.num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>封装、构造、对象与引用、参数传递</title>
    <url>/2022/11/23/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/</url>
    <content><![CDATA[<h1 id="java面向对象2"><a class="markdownIt-Anchor" href="#java面向对象2"></a> Java面向对象2</h1>
<h3 id="集成开发环境"><a class="markdownIt-Anchor" href="#集成开发环境"></a> 集成开发环境</h3>
<ul>
<li>IDE:Integrated Development Environment</li>
<li>在IDE中不需要额外下载JDK、不需要手动配置环境变量、不需要手动编译生成字节码文件</li>
<li>IDE提供语法检查、提供丰富的代码工具</li>
<li>IntelliJ IDEA的快捷键详见参考文献<sup><a href="#ref1">[1]</a></sup></li>
</ul>
<h3 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h3>
<h5 id="封装的作用"><a class="markdownIt-Anchor" href="#封装的作用"></a> 封装的作用</h5>
<ol>
<li>安全性：控制外部的访问</li>
<li>有效性：复杂性封装，提供简单的操作入口</li>
<li>复用性：使得对象可以被反复使用</li>
</ol>
<h5 id="封装的步骤"><a class="markdownIt-Anchor" href="#封装的步骤"></a> 封装的步骤</h5>
<ol>
<li>
<p>所有属性私有化，使用private关键字进行修饰</p>
<ul>
<li>private表示私有的，所修饰的数据只能在本类中访问</li>
</ul>
</li>
<li>
<p>对外提供简单的操作入口，通过这些简单的操作入口来修改私有属性</p>
<ul>
<li>如果不提供操作入口，私有属性将永远无法被访问</li>
<li>数据的访问存在 读 和 写 两种，因此对外提供两个公开的方法<code>set</code>和<code>get</code>，用于读写私有数据</li>
</ul>
</li>
<li>
<p>关于<code>set</code>和<code>get</code>的细节</p>
<ul>
<li><code>set</code>方法命名规范</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> set属性名(形参列表)&#123;<span class="comment">//形参不能和私有属性的名字相同</span></span><br><span class="line">	<span class="comment">//进行安全过滤</span></span><br><span class="line">  属性名 = 形式参数;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>get</code>方法命名规范</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 返回类型 get属性名()&#123;</span><br><span class="line">  <span class="comment">//进行安全控制</span></span><br><span class="line">	<span class="keyword">return</span> 属性;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>set</code>和<code>get</code>函数的修饰符列表中没有<code>static</code>关键字，直接使用 <code>引用.方法名(实参列表)</code> 来调用</li>
<li><code>set</code>和<code>get</code>函数可以在IntelliJ中自动生成：选中所需要生成<code>set</code>和<code>get</code>方法的实例变量，<code>command + N</code>选择<code>Getter and Setter</code>即可</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h81578xz2pj310a0n0acn.jpg" alt="" /></p>
</li>
</ol>
<h3 id="构造方法"><a class="markdownIt-Anchor" href="#构造方法"></a> 构造方法</h3>
<ul>
<li>构造方法又被称作构造函数/构造器/Constructor</li>
<li>构造方法语法结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 构造方法名(形参列表)&#123;</span><br><span class="line">	构造方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>与普通的方法相比较</p>
<ol>
<li>构造方法不需要指定<u>返回值类型</u>， 也不需要为其指定<code>void</code>返回值类型</li>
<li>构造方法名必须和<u>类名</u>保持一致</li>
</ol>
</li>
</ul>
<h5 id="构造方法的作用"><a class="markdownIt-Anchor" href="#构造方法的作用"></a> 构造方法的作用</h5>
<ol>
<li>通过调用构造函数用于在堆内存中<strong>创建对象</strong></li>
<li>创建对象的同时，<strong>初始化实例变量</strong></li>
</ol>
<h5 id="构造方法的调用"><a class="markdownIt-Anchor" href="#构造方法的调用"></a> 构造方法的调用</h5>
<ul>
<li>普通方法的调用
<ul>
<li>修饰符列表含有<code>static</code>关键字时：<code>类名.方法名(实参列表)</code> (在同一个类中类名可以省略)</li>
<li>修饰符列表不含<code>static</code>关键字时：<code>引用.方法名(实参列表)</code></li>
</ul>
</li>
<li>构造方法的调用
<ul>
<li><code>new 构造方法(实参列表)</code></li>
</ul>
</li>
</ul>
<h5 id="有关于构造方法的返回值"><a class="markdownIt-Anchor" href="#有关于构造方法的返回值"></a> 有关于构造方法的返回值</h5>
<ul>
<li>构造方法调用结束会返回堆地址中创建的对象的<strong>地址</strong></li>
<li>构造方法的返回值类型<strong>非常固定</strong>，永远是该类的类型，故可以它的省略返回值类型</li>
</ul>
<h5 id="缺省构造器"><a class="markdownIt-Anchor" href="#缺省构造器"></a> 缺省构造器</h5>
<ul>
<li>
<p>当一个类中没有定义任何构造方法时，系统默认给该类提供一个无参数的构造方法，该方法称为缺省构造器</p>
</li>
<li>
<p>当类中显示的定义了构造方法时，系统就不会再提供缺省构造器</p>
</li>
<li>
<p>构造方法支持重载</p>
<ul>
<li>在一个类中可以编写多个构造方法</li>
<li>由于无参数构造方法的常用性，手动的为当前类提供一个无参数的构造方法，避免其之后被省略</li>
<li>每调用一次构造方法就会调用一个对象，<u>调用不同的重载方法，就会创建不同的对象</u></li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8159g1t1pj310u0k0ac5.jpg" alt="" /></p>
</li>
</ul>
<h5 id="初始化实例变量"><a class="markdownIt-Anchor" href="#初始化实例变量"></a> 初始化实例变量</h5>
<ul>
<li>在类加载时，系统并不会初始化实例变量，因为实例变量需要通过对象去访问</li>
<li>在通过构造函数初始化对象时进行实例变量的初始化工作</li>
</ul>
<h3 id="对象和引用"><a class="markdownIt-Anchor" href="#对象和引用"></a> 对象和引用</h3>
<h5 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h5>
<ul>
<li>通过构造函数在堆内存中开辟的内存空间称为对象</li>
</ul>
<h5 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h5>
<ul>
<li>一个指向堆内存中对象地址的变量</li>
<li>可能是局部变量(在方法中声明)；也可能是实例变量(在类中声明)</li>
<li>所有访问实例相关的数据，都需要通过引用的方式进行访问</li>
<li>一个空引用访问实例相关的数据时运行时会出现“空指针异常”</li>
</ul>
<h3 id="参数传递"><a class="markdownIt-Anchor" href="#参数传递"></a> 参数传递</h3>
<h5 id="按值传递"><a class="markdownIt-Anchor" href="#按值传递"></a> 按值传递</h5>
<ul>
<li>方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一份拷贝，在方法中对这个拷贝的形参做修改，不改变实参的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transfer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//num是一个存放在栈区的普通变量，存储的是数据1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用前num = &quot;</span> + num);</span><br><span class="line">        add(num);<span class="comment">//传递的是num的拷贝，等价于add(10)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用后num = &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按值传递</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//n = 10</span></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="按引用传递"><a class="markdownIt-Anchor" href="#按引用传递"></a> 按引用传递</h5>
<ul>
<li>方法调用时，实参的引用被传递给方法中相应的形参，在方法执行过程中，形参和实参指向同一块内存地址，方法执行后再访问该内存地址，会发现实参被改变了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transfer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="number">1</span>);<span class="comment">//test是一个存放在栈中的引用变量，它存储的是一个Test的对象的地址0x6324</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用前test.num = &quot;</span> + test.getNum());</span><br><span class="line">        add(test);<span class="comment">//传递的是Test对象的引用,等价于add(0x6324)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用后test.num = &quot;</span> + test.getNum());<span class="comment">//方法执行后，再访问同一个地址</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按引用传递</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Test t)</span> &#123;<span class="comment">//t = 0x6324</span></span><br><span class="line">      <span class="comment">//注意这里，t = 0x6324， 而不是t = test，本质上传递的还是值，t和test两个引用指向了同一个堆内存空间</span></span><br><span class="line">        test.setNum(test.getNum() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//对num进行了封装</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        num = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        num = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8164xm21tj30vk0ludi2.jpg" alt="" /></p>
<h5 id="参数传递的本质"><a class="markdownIt-Anchor" href="#参数传递的本质"></a> 参数传递的本质</h5>
<ul>
<li>方法调用涉及参数传递时，Java只遵循的其实只有一种机制：<strong>将变量中存储的“值”传递过去</strong>，只不过这个值有的时候时字面值，有的是内存地址</li>
<li>理解以下这个例子更能明白“传值”的含义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transfer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用前t1.num = &quot;</span> + t1.getNum());</span><br><span class="line">        System.out.println(<span class="string">&quot;调用前t2.num = &quot;</span> + t2.getNum());</span><br><span class="line"></span><br><span class="line">        swap(t1, t2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;调用后t1.num = &quot;</span> + t1.getNum());</span><br><span class="line">        System.out.println(<span class="string">&quot;调用后t2.num = &quot;</span> + t2.getNum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Test test1, Test test2)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        temp = test1;</span><br><span class="line">        test1 = test2;</span><br><span class="line">        test2 = temp;</span><br><span class="line">      <span class="comment">//方法执行后，形参test1和test2的值交换了，实参t1和t2并没有收到改变</span></span><br><span class="line">      <span class="comment">//如果在主函数里访问test1和test2的地址，会发现受到了真正的影响</span></span><br><span class="line">      <span class="comment">//如果在主函数里访问t1和t2的地址，会发现没有任何影响</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        num = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        num = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h816vu4tjej31ik0m4q5n.jpg" alt="" /></p>
<ul>
<li>我们会发现，调用前后<code>t1</code>和<code>t2</code>的值并没有改变，因为方法调用时，只是将<code>t1</code>和<code>t2</code>的值（也就是两个地址）传进去了，而不是把这两个值真正的传进去</li>
</ul>
<p>Reference <a name="ref1"><font color="black">[1]<a href="https://dancon.gitbooks.io/intellij-idea/content/keymap-mac-introduce.html">https://dancon.gitbooks.io/intellij-idea/content/keymap-mac-introduce.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Super关键字</title>
    <url>/2022/11/23/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A112/</url>
    <content><![CDATA[<h1 id="super关键字"><a class="markdownIt-Anchor" href="#super关键字"></a> super关键字</h1>
<h3 id="super的原理"><a class="markdownIt-Anchor" href="#super的原理"></a> <code>super()</code>的原理</h3>
<ul>
<li>在构造方法执行过程中，调用了一连串父类的构造方法，父类的构造方法又继续向上调用它的构造方法，但实际上对象只创建了一个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="comment">//super()省略</span></span><br><span class="line">  <span class="comment">//A()&#123;&#125;</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  String b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="comment">//super()省略</span></span><br><span class="line">  <span class="comment">//B()&#123;&#125;</span></span><br><span class="line">  <span class="type">double</span> c;</span><br><span class="line">  String d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8chljmt9bj31990lzmys.jpg" alt="" /></p>
<ul>
<li><code>super(实参)</code>的作用是：<strong>初始化当前对象的父类特征</strong></li>
<li>调用<code>super()</code>时并<strong>不会创建一个父类的对象</strong>，从始至终只创建了<strong>一个</strong>对象。通过<code>super()</code>将父类的特征<strong>继承</strong>下来，变成子类自己的。也就是说，子类和它通过<code>super()</code>创建的父类之间的关系是<strong>包含关系</strong>，子类包含了父类的特征。<strong>而<code>super</code>指向的就是当前对象的那部分父类特征</strong>
<ul>
<li>在上述列子中，<code>super</code>代表的就是<code>a</code>和<code>b</code></li>
<li>虽然<code>a</code>和<code>b</code>是父类<code>A</code>的特征（属性），但子类<code>B</code>一旦继承下来就是属于它自己的了</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vip</span> <span class="keyword">extends</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; is shopping&quot;</span>);<span class="comment">//this指向vip自己</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name + <span class="string">&quot; is shopping&quot;</span>);<span class="comment">//super指向子类中的父类特征属性</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot; is shopping&quot;</span>);<span class="comment">//this可以省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Vip</span> <span class="variable">vip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vip</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        vip.shopping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8cifgs87pj30vs0fw75e.jpg" alt="" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8cij8eqqvj317n0o5taj.jpg" alt="" /></p>
<ul>
<li>
<p>当通过<code>this</code>来访问<code>name</code>这个属性时，因为<code>name</code>在Vip这个对象的内存中，所以可以访问到</p>
</li>
<li>
<p>当通过<code>super</code>来访问<code>name</code>这个属性时，因为<code>name</code>是Vip这个对象的父类属性，所以也可以访问到</p>
</li>
<li>
<p><strong><code>super</code>是<code>this</code>指向对象的一块空间</strong></p>
</li>
<li>
<p>当我们在Vip类中也添加一个名为<code>name</code>的属性</p>
<ul>
<li>Java允许子类中出现和父类一样的同名属性</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vip2</span> <span class="keyword">extends</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    String name;<span class="comment">//子类中的name属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip2</span><span class="params">()</span>&#123;</span><br><span class="line">      	<span class="comment">//super();</span></span><br><span class="line">      	<span class="comment">//this.name = null;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip2</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);<span class="comment">//将name初始化给了父类的name，而子类中的name没有初始化</span></span><br><span class="line">      	<span class="comment">//this.name = null;在一个构造方法中如果没有给属性手动初始化，系统将会自动为其赋默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; is shopping&quot;</span>);<span class="comment">//this指向的子类的name</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name + <span class="string">&quot; is shopping&quot;</span>);<span class="comment">//super指向父类的name</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot; is shopping&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8cizu8qcfj30vu0lcac3.jpg" alt="" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8cj0c63umj31dx0shju5.jpg" alt="" /></p>
<h3 id="super的使用情况"><a class="markdownIt-Anchor" href="#super的使用情况"></a> <code>super.</code>的使用情况</h3>
<ul>
<li><code>super.</code>既可以访问父类的属性，也能访问父类的方法</li>
<li>大部分情况下<code>super.</code>都是可以省略的</li>
<li>如果父类和自类具有同名属性/方法，并且想要通过子类去访问父类的属性/方法，则<code>super.</code>不能省略</li>
<li>Java通过<code>super.</code>来区分同名的子类和父类的属性/方法</li>
</ul>
<h3 id="super单独使用"><a class="markdownIt-Anchor" href="#super单独使用"></a> <code>super</code>单独使用</h3>
<ul>
<li>
<p><code>this</code>是可以直接单独使用</p>
<ul>
<li><code>this</code>是一个指向当前对象自己的引用</li>
<li>输出引用时，会自动调用引用的<code>toString()</code>方法，输出该引用地址的一个哈希</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Test2</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line">        test.doSome();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ck5gqjquj30vs0fk757.jpg" alt="" /></p>
</li>
<li>
<p><code>super</code>不能单独引用</p>
<ul>
<li><code>super</code>不是引用，不保存内存地址，也不指向任何对象</li>
<li>它只代表当前对象内部的那一块父类型特征</li>
</ul>
</li>
</ul>
<h3 id="super不能用于静态方法中"><a class="markdownIt-Anchor" href="#super不能用于静态方法中"></a> <code>super</code>不能用于静态方法中</h3>
<ul>
<li><code>this</code>和<code>super</code>的使用需要对象的参与，只能用于实例方法中</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>this关键字</title>
    <url>/2022/11/23/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13/</url>
    <content><![CDATA[<h1 id="this关键字"><a class="markdownIt-Anchor" href="#this关键字"></a> this关键字</h1>
<h3 id="this关键字-2"><a class="markdownIt-Anchor" href="#this关键字-2"></a> this关键字</h3>
<h5 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h5>
<p><code>this</code>关键字用于引用方法或构造函数中的当前对象</p>
<ul>
<li><code>this</code>是一个引用变量，this中保存的内存地址指向自身</li>
<li><code>this</code>存储在堆内存中</li>
<li>在初始化对象过程中，都会初始化该对象的<code>this</code>关键字</li>
</ul>
<h5 id="this的使用情况"><a class="markdownIt-Anchor" href="#this的使用情况"></a> <code>this</code>的使用情况</h5>
<ol>
<li>出现在实例方法中，用于指向当前正在执行这个动作的对象
<ul>
<li>一般通过<code>this</code>访问的都是实例变量/方法，而在访问这个实例变量/方法的大多都是该对象本身，所以<code>this.</code>可以省略</li>
<li><code>this</code>不能出现在带有<code>static</code>的方法中</li>
<li>在<code>static</code>修饰的方法中通过手动创建一个对象来访问实例变量/方法</li>
</ul>
</li>
<li>用来区分局部变量和实例变量
<ul>
<li>用于区分时，不能省略<code>this.</code></li>
</ul>
</li>
<li>用来调用其他构造方法</li>
</ol>
<h5 id="实例方法-实例变量"><a class="markdownIt-Anchor" href="#实例方法-实例变量"></a> 实例方法 &amp; 实例变量</h5>
<ol>
<li>
<p>实例变量</p>
<ul>
<li>不带<code>static</code>关键字的变量被称为实例变量，通过<code>引用.变量</code>来访问</li>
<li>当一个变量会因为不同的对象而不同时，这个变量需要被定义为实例变量，不能用<code>static</code>来修饰</li>
</ul>
</li>
<li>
<p>实例方法</p>
<ul>
<li>不带<code>static</code>关键字的方法被称为实例方法，通过<code>引用.方法名(形参列表)</code>来访问</li>
<li>当一个行为/动作执行的过程中需要对象参与时，这个方法需要定义为实例方法，不能用<code>static</code>来修饰</li>
</ul>
</li>
<li>
<p>实例</p>
<ul>
<li>实例代表这个方法/变量时对象级别的，而不是类级别的</li>
<li>访问实例对象/方法一定得通过引用来访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;<span class="comment">//实例对象</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String n)</span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span>&#123; <span class="comment">//实例方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例方法，代表shop这个行为是对象级别的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//实例对象的访问应该通过引用来访问！</span></span><br><span class="line"><span class="comment">//        System.out.println(name + &quot;正在购物&quot;);//省略了引用</span></span><br><span class="line">        <span class="comment">//完整写法</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;正在购物&quot;</span>);<span class="comment">//this代表当前正在执行这个行为的对象</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//实例方法的调用也应该通过引用来访问！</span></span><br><span class="line"><span class="comment">//        pay();//省略了引用</span></span><br><span class="line">      	<span class="comment">//完整写法</span></span><br><span class="line">        <span class="built_in">this</span>.pay();<span class="comment">//this代表了当前调用这个行为的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在static修饰的方法中访问实例变量/方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">  	<span class="type">int</span> num;<span class="comment">//实例对象</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span>&#123; <span class="comment">//实例方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//在静态方法中访问实例变量的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNum</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(num);//访问失败，必须通过引用.实例变量才能访问，但是this不能出现在static的方法中</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//自己手动创建一个对象即可</span></span><br><span class="line">        System.out.println(u.num);</span><br><span class="line"><span class="comment">//				pay()；//调用失败</span></span><br><span class="line">      	u.pay();<span class="comment">//通过手动创建的对象调用</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="用于区分局部变量和实例变量"><a class="markdownIt-Anchor" href="#用于区分局部变量和实例变量"></a> 用于区分局部变量和实例变量</h5>
<ul>
<li>在用于区分局部变量和实例变量时，<code>this</code>不能省略</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//封装</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="comment">//        name = name;//编译报错，无法区分两个变量</span></span><br><span class="line">        <span class="comment">//通过this来区分实例变量和局部变量</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;<span class="comment">//等号左边的为实例变量，右边的为局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">      	<span class="comment">//此时this可以省略，因为返回的name是实例变量，不需要区分</span></span><br><span class="line">      	<span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用来调用其他构造方法"><a class="markdownIt-Anchor" href="#用来调用其他构造方法"></a> 用来调用其他构造方法</h3>
<ul>
<li>出现在构造方法中，通过当前构造方法调用其他构造方法</li>
<li>语法结构<code>this(实参列表)；</code></li>
<li>用这种方法调用构造方法时，这条语句必须出现在构造方法的<strong>第一行</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> year;</span><br><span class="line">  <span class="keyword">private</span> month;</span><br><span class="line">  <span class="keyword">private</span> day;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Constructor</span></span><br><span class="line">    <span class="comment">//要求：在调用无参数的构造方法时，默认创建的日期是&quot;2000-10-25&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">      setYear(year);</span><br><span class="line">      setMonth(month);</span><br><span class="line">      setDay(day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//这样的方式会创建两个对象</span></span><br><span class="line">      <span class="comment">//调用无参的构造函数会生成一个对象，无参构造函数中又调用一个有参的构造函数再生成一个对象</span></span><br><span class="line">  <span class="comment">//        new Date(2000, 10, 25);//调用构造函数只能通过new的方式</span></span><br><span class="line">      <span class="comment">//采用以下的方式来调用构造函数</span></span><br><span class="line">      <span class="built_in">this</span>(<span class="number">2000</span>,<span class="number">10</span>,<span class="number">25</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">      <span class="type">Date</span> <span class="variable">day1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">      System.out.print(<span class="string">&quot;采用无参数的构造函数&quot;</span>);</span><br><span class="line">      day1.printDate();</span><br><span class="line">      </span><br><span class="line">      <span class="type">Date</span> <span class="variable">day2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2022</span>,<span class="number">11</span>,<span class="number">12</span>);</span><br><span class="line">      System.out.print(<span class="string">&quot;采用带参数的构造函数&quot;</span>);</span><br><span class="line">      day2.printDate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h827qci8k8j312e0kcac7.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>static关键字</title>
    <url>/2022/11/23/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14/</url>
    <content><![CDATA[<h1 id="static"><a class="markdownIt-Anchor" href="#static"></a> static</h1>
<h3 id="static-2"><a class="markdownIt-Anchor" href="#static-2"></a> static</h3>
<ul>
<li>静态的</li>
<li><code>static</code>可以用来修饰变量和方法，所修饰的变量称为静态变量，所修饰的方法称为静态方法</li>
<li><code>static</code>所修饰的元素都是类级别的特征，与具体的对象无关</li>
<li>直接通过<code>类名.</code>访问<code>static</code>所修饰内容</li>
<li>静态变量/方法在类加载时就初始化了，<strong>内存在方法区中开辟</strong>，不需要通过创建对象来初始化</li>
</ul>
<h3 id="成员变量的类型"><a class="markdownIt-Anchor" href="#成员变量的类型"></a> 成员变量的类型</h3>
<ol>
<li>实例变量
<ul>
<li>所有的对象都拥有的属性，但是这个属性随着对象的不同而不同</li>
</ul>
</li>
<li>静态变量
<ul>
<li>用<code>static</code>关键字声明的变量称为静态成员变量</li>
<li>所有的对象同样拥有这个属性，但是所有对象的这个属性值都相同</li>
<li>节省内存空间
<ul>
<li>当所有的对象都拥有相同的属性值，如果在堆内存中给每个属性都开辟一块空间存储冗余的数据会造成空间浪费</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="成员方法的类型"><a class="markdownIt-Anchor" href="#成员方法的类型"></a> 成员方法的类型</h3>
<ol>
<li>实例方法
<ul>
<li>方法描述的是动作，每个对象执行实例动作后产生的结果不同</li>
</ul>
</li>
<li>静态方法
<ul>
<li>一个类中所有的对象执行静态方法后产生的结果都相同</li>
<li>静态方法的动作不属于对象，而是可以提升至类这个级别</li>
<li>静态方法中无法直接访问实例变量以及实例方法</li>
</ul>
</li>
<li>绝大部分动作都定义为实例方法，因为大部分动作的执行都需要对象的参与</li>
<li>大部分工具类的方法都可以被定义为静态方法，为了方便编程，大部分工具类的方法都不需要对象的参与</li>
</ol>
<h3 id="static的访问"><a class="markdownIt-Anchor" href="#static的访问"></a> static的访问</h3>
<ul>
<li>
<p>静态变量可以通过<code>类名.静态变量名</code>来直接访问</p>
<ul>
<li>所有的静态数据既可以通过类名的方式访问，也可以通过引用的方式访问</li>
<li>当通过引用来访问时，即使这个引用指向null，也不会出现空指针异常的情况</li>
<li>因为本质上是通过这个引用所在的类来访问静态的数据，不需要引用的存在！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chinese</span> &#123;</span><br><span class="line">    <span class="type">int</span> ID;<span class="comment">//实例变量</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;China&quot;</span>;<span class="comment">//静态变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//静态变量无需在创建对象时就初始化</span></span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">people1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">people2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">people3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态变量通过类名直接访问</span></span><br><span class="line">        System.out.println(people1.ID + <span class="string">&quot; &quot;</span> + people1.name + <span class="string">&quot; &quot;</span> + Chinese.country);</span><br><span class="line">        <span class="comment">//静态变量也可以通过对象访问，但是编译器会警告</span></span><br><span class="line">        System.out.println(people2.ID + <span class="string">&quot; &quot;</span> + people2.name + <span class="string">&quot; &quot;</span> + people2.country);</span><br><span class="line">        <span class="comment">//即使是一个空对象，他的静态变量也会被初始化</span></span><br><span class="line">        System.out.println(people3.ID + <span class="string">&quot; &quot;</span> + people3.name + <span class="string">&quot; &quot;</span> + people3.country);</span><br><span class="line">        <span class="comment">//即使是一个指向空的引用，也能正常访问其静态变量</span></span><br><span class="line">        <span class="comment">//也就是说，静态变量和对象没有任何关系，只和类有关系</span></span><br><span class="line">        people3 = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(people3.country);</span><br><span class="line">        <span class="comment">//但是访问people.ID会出现空指针异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h83arj3rk4j30vq0gw3zi.jpg" alt="" /></p>
</li>
</ul>
<h3 id="静态代码块"><a class="markdownIt-Anchor" href="#静态代码块"></a> 静态代码块</h3>
<ul>
<li>语法格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	Java语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>静态代码块在类加载时执行，并且只执行一次</li>
<li>静态代码块在类中可以编写多个，遵循自上而下依次执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCode</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块1的执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块2的执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h83bcjet5gj30um0eujsg.jpg" alt="" /></p>
<ul>
<li>
<p>静态代码块在加载<code>StaticCode</code>时就执行了，比主函数执行的还要提前</p>
</li>
<li>
<p><strong>静态代码块的作用</strong></p>
<ol>
<li>静态代码块可以用来<u>记录类加载时刻</u>，可以在类加载时刻执行一些特定的动作</li>
<li>可以在静态代码块中记录日志、完成初始化工作以及一些准备工作</li>
</ol>
</li>
</ul>
<h3 id="实例代码块"><a class="markdownIt-Anchor" href="#实例代码块"></a> 实例代码块</h3>
<ul>
<li>语法格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	Java语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实例代码块可以编写多个，遵循自上而下的顺序依次执行</li>
<li>实例代码块在构造函数之前执行，构造函数执行一次实例代码块就执行一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InstanceCode</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例块1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例块2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">InstanceCode</span> <span class="variable">ins1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstanceCode</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;主函数执行&quot;</span>);</span><br><span class="line">        <span class="type">InstanceCode</span> <span class="variable">ins2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstanceCode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h83bjdcoxaj30ua0leabf.jpg" alt="" /></p>
<ul>
<li>实例代码块的作用：实例代码块可以用来记录对象初始化时刻</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection接口</title>
    <url>/2022/12/20/Java/Collection%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="collection接口"><a class="markdownIt-Anchor" href="#collection接口"></a> <code>Collection</code>接口</h1>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<blockquote>
<p>The root interface in the <em>collection hierarchy</em>（在集合的继承结构中的根接口）. A collection represents a group of objects, known as its <em>elements</em>（代表了多个元素的集合）. Some collections allow duplicate elements and others do not. Some are ordered and others unordered（<code>Collection</code>集合中有的集合中元素有序、且允许有重复元素（<code>List</code>），有的集合中元素无序、且不允许有重复元素（<code>Map</code>））. The JDK does not provide any <em>direct</em> implementations of this interface（没有对这个接口的直接实现）: it provides implementations of more specific subinterfaces like <code>Set</code> and <code>List</code>. This interface is typically used to pass collections around and manipulate （传递和操作集合）them where maximum generality（最大共性） is desired.</p>
</blockquote>
<ul>
<li><code>Collection</code>集合中如果不使用泛型可以存储任何Object类型的引用
<ul>
<li>是用来泛型后只能存储某个具体类型的引用</li>
</ul>
</li>
<li><code>Collection</code>集合中只能存储Java对象的引用
<ul>
<li>不能存储基本数据类型
<ul>
<li>当要存储基本数据100时，将100自动装箱成<code>Integer</code>类的引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="常用方法"><a class="markdownIt-Anchor" href="#常用方法"></a> 常用方法</h2>
<h3 id="boolean-adde-e"><a class="markdownIt-Anchor" href="#boolean-adde-e"></a> <code>boolean add(E e)</code></h3>
<blockquote>
<p>Ensures that this collection contains the specified element (optional operation). Returns <code>true</code> if this collection changed as a result of the call. (Returns <code>false</code> if this collection does not permit duplicates and already contains the specified element.)</p>
<p>Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add <code>null</code> elements（不能加入空元素）, and others will impose restrictions on the type of elements that may be added（可能会限制加入元素的类型）. Collection classes should clearly specify in their documentation any restrictions on what elements may be added.</p>
</blockquote>
<ul>
<li>向集合中加入一个元素</li>
<li>当元素加入成功时返回<code>true</code>，否则返回<code>false</code>
<ul>
<li>有的集合不允许重复元素的存在，所以可能会导致加入元素失败</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于无法实例化一个接口，所以在这里实例化一个实现Collection接口的子类</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">c.add(<span class="number">10.1</span>);<span class="comment">//自动装箱，等价于c.add(new Double(10.1));</span></span><br><span class="line">c.add(<span class="literal">true</span>);<span class="comment">//自动装箱</span></span><br><span class="line">c.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">c.add(<span class="literal">null</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="int-size"><a class="markdownIt-Anchor" href="#int-size"></a> <code>int size()</code></h3>
<blockquote>
<p>Returns the number of elements in this collection. If this collection contains more than <code>Integer.MAX_VALUE</code> elements, returns <code>Integer.MAX_VALUE</code>.</p>
</blockquote>
<ul>
<li>返回集合中元素的个数
<ul>
<li>当集合中元素个数大于<code>Integer.MAX_VALUE</code>时，返回<code>Integer.MAX_VALUE</code></li>
</ul>
</li>
</ul>
<h3 id="void-clear"><a class="markdownIt-Anchor" href="#void-clear"></a> <code>void clear()</code></h3>
<blockquote>
<p>Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.</p>
</blockquote>
<ul>
<li>清空集合中的所有元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">c.add(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">10.2</span>));</span><br><span class="line">c.add(<span class="literal">true</span>);</span><br><span class="line">c.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">c.add(<span class="literal">null</span>);</span><br><span class="line">System.out.println(c.size());</span><br><span class="line">c.clear();</span><br><span class="line">System.out.println(c.size());</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9aeh5mmilj30fv05at8t.jpg" alt="" /></p>
<h3 id="boolean-containsobject-o"><a class="markdownIt-Anchor" href="#boolean-containsobject-o"></a> <code>boolean contains(Object o)</code></h3>
<blockquote>
<p>Returns <code>true</code> if this collection contains the specified element. More formally, returns <code>true</code> if and only if this collection contains at least one element <code>e</code> such that <code>(o==null ? e==null : o.equals(e))</code>.</p>
</blockquote>
<ul>
<li>判断集合中是否包含某一个元素</li>
<li>在底层<code>contains</code>通过<code>.equals()</code>方法来判断是否包含某个元素
<ul>
<li><strong>是通过内容来判断是否包含</strong>，而非地址</li>
<li>如果一个类没有重写<code>.equals()</code>方法，那就还是按照地址来判断是否包含</li>
<li>放在集合里的元素需要重写<code>.equals()</code>方法</li>
</ul>
</li>
</ul>
<h3 id="boolean-removeobject-o"><a class="markdownIt-Anchor" href="#boolean-removeobject-o"></a> <code>boolean remove(Object o)</code></h3>
<blockquote>
<p>Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element <code>e</code> such that <code>(o==null ? e==null : o.equals(e))</code>, if this collection contains one or more such elements. Returns <code>true</code> if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).</p>
</blockquote>
<ul>
<li>删除集合中<u>一个</u><em>o</em>元素</li>
<li>同样通过<code>.equals()</code>方法来查找要删除的那个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">c.add(<span class="number">1</span>);c.add(<span class="number">1</span>);c.add(<span class="number">1</span>);c.add(<span class="number">1</span>);c.add(<span class="number">1</span>);</span><br><span class="line">System.out.println(c.size());<span class="comment">//5</span></span><br><span class="line">c.remove(<span class="number">1</span>);<span class="comment">//只删除一个1</span></span><br><span class="line">System.out.println(c.size());<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<h3 id="boolean-isempty"><a class="markdownIt-Anchor" href="#boolean-isempty"></a> <code>boolean isEmpty()</code></h3>
<blockquote>
<p>Returns <code>true</code> if this collection contains no elements.</p>
</blockquote>
<ul>
<li>判断集合是否为空</li>
</ul>
<h3 id="object-toarray"><a class="markdownIt-Anchor" href="#object-toarray"></a> <code>Object[] toArray()</code></h3>
<blockquote>
<p>Returns an array containing all of the elements in this collection（返回包含集合中所有元素的数组）. If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order.（数组中元素的顺序和迭代器中元素的顺序一致）</p>
</blockquote>
<ul>
<li>将集合转化成数组</li>
</ul>
<h2 id="集合的迭代"><a class="markdownIt-Anchor" href="#集合的迭代"></a> 集合的迭代</h2>
<h3 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h3>
<ul>
<li><code>Collection</code>接口继承了<code>Iterator</code>接口，所以<code>Collection</code>中有<code>Iterator&lt;E&gt; iterator()</code>方法
<ul>
<li>该方法返回一个迭代器，用于遍历整个集合</li>
</ul>
</li>
<li>所有实现了<code>Collection</code>接口的子类都可以使用这个方法来遍历整个集合
<ul>
<li>在<code>Map</code>集合中不可以使用这个方法</li>
</ul>
</li>
<li>迭代器负责遍历/迭代集合中的元素
<ul>
<li>类似指针，迭代器指向一个元素就代表遍历到了它</li>
<li>迭代器并不是初始化直接指向第一个元素，而是有点类似于指向下标为-1</li>
</ul>
</li>
</ul>
<h3 id="interface-iterator"><a class="markdownIt-Anchor" href="#interface-iterator"></a> <code>Interface Iterator</code></h3>
<ul>
<li>迭代器中的方法</li>
</ul>
<h4 id="boolean-hasnext"><a class="markdownIt-Anchor" href="#boolean-hasnext"></a> <code>boolean hasNext()</code></h4>
<blockquote>
<p>Returns <code>true</code> if the iteration has more elements. (In other words, returns <code>true</code> if <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html#next--"><code>next()</code></a> would return an element rather than throwing an exception.)</p>
</blockquote>
<ul>
<li>当还有元素可以迭代时，返回<code>true</code></li>
<li>返回<code>false</code>时代表没有更多的元素可以迭代了</li>
</ul>
<h4 id="object-next"><a class="markdownIt-Anchor" href="#object-next"></a> <code>Object next()</code></h4>
<blockquote>
<p>Returns the next element in the iteration.</p>
</blockquote>
<ul>
<li>迭代器前进一位，并且返回迭代器新指向的元素</li>
</ul>
<h3 id="iteratore-iterator"><a class="markdownIt-Anchor" href="#iteratore-iterator"></a> <code>Iterator&lt;E&gt; iterator()</code></h3>
<blockquote>
<p>Returns an iterator over the elements in this collection. There are no guarantees concerning the order in which the elements are returned (unless this collection is an instance of some class that provides a guarantee).</p>
</blockquote>
<ul>
<li>返回集合的迭代器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    c.add(<span class="number">1</span>);c.add(<span class="number">2</span>);c.add(<span class="number">3</span>);c.add(<span class="number">4</span>);c.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> c.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    		System.out.println(iterator.next());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>方法的覆盖</title>
    <url>/2022/11/23/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A16/</url>
    <content><![CDATA[<h1 id="方法的覆盖override"><a class="markdownIt-Anchor" href="#方法的覆盖override"></a> 方法的覆盖Override</h1>
<h3 id="方法的重载overload"><a class="markdownIt-Anchor" href="#方法的重载overload"></a> 方法的重载Overload</h3>
<ul>
<li>适用情况
<ul>
<li>在同一个类中，方法完成的功能相似时，建议方法名相同，这样方便编程、代码美观</li>
</ul>
</li>
<li>使用条件
<ul>
<li>在同一个类中</li>
<li>方法名相同</li>
<li>参数列表不同：类型不同、顺序不同、个数不同</li>
</ul>
</li>
<li>方法重载
<ul>
<li>与方法返回值无关</li>
<li>与方法的修饰符列表无关</li>
</ul>
</li>
</ul>
<h3 id="方法覆盖overide"><a class="markdownIt-Anchor" href="#方法覆盖overide"></a> 方法覆盖Overide</h3>
<ul>
<li>
<p>又称为方法重写Overwrite</p>
</li>
<li>
<p>适用情况</p>
<ul>
<li>当父类中的方法无法满足当前子类的要求时，子类有必要将父类继承过来的方法进行重写</li>
<li>举一个例子：父类Animal有一个动作move可以输出“动物在移动”，子类Cat和Bird继承了这两个方法，若不重写的话，两个子类调用move方法还是会输出同样的内容</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在移动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;<span class="comment">//Cat类继承动物类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;<span class="comment">//Bird继承动物类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Animal类：&quot;</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        animal.move();</span><br><span class="line">        System.out.print(<span class="string">&quot;Cat类：&quot;</span>);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.move();</span><br><span class="line">        System.out.print(<span class="string">&quot;Bird类：&quot;</span>);</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        bird.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h84e0pyl50j30uc0feq42.jpg" alt="" /></p>
</li>
<li>
<p>使用条件</p>
<ul>
<li>方法重写发生在具有继承关系的父子类之间</li>
<li>重写的方法必须和父类的方法的<u>返回值类型</u>、<u>方法名</u>、<u>形参列表</u>相同
<ul>
<li>直接复制粘贴父类的方法，然后修改方法体中内容即可</li>
</ul>
</li>
<li>修饰符列表：子类重写的方法访问权限可以更低，但不能更高</li>
<li>抛出的异常可以更少，但不能更多</li>
<li>同样针对上述例子，进行方法重写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在移动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟在飞翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Animal类：&quot;</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        animal.move();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Cat类：&quot;</span>);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.move();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Bird类：&quot;</span>);</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        bird.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h84ee8k3tjj30u20dydgt.jpg" alt="" /></p>
</li>
<li>
<p>注意</p>
<ol>
<li>私有方法不能继承，所以不能覆盖</li>
<li>构造方法不能继承，所以不能覆盖</li>
<li>静态方法不存在覆盖</li>
<li>覆盖只针对方法，不针对属性</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2022/11/23/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A15/</url>
    <content><![CDATA[<h1 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h1>
<h3 id="继承的概念"><a class="markdownIt-Anchor" href="#继承的概念"></a> 继承的概念</h3>
<ul>
<li>继承是面向对象三大特征之一（封装、继承、多态）</li>
<li>继承的基本作用是<u>代码复用</u>，有了继承之后才有方法的覆盖和多态机制</li>
<li>继承允许创建分等级层次的类</li>
<li>语法结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表]class 父类&#123;</span><br><span class="line">	类体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[修饰符列表] class 类名 extends 父类&#123;</span><br><span class="line">	类体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>继承的数据类型</strong>
<ol>
<li>私有的不支持继承</li>
<li>构造函数不支持继承</li>
<li>其余的都支持继承</li>
</ol>
</li>
<li>Java语言中只支持单继承，一个类不能同时继承很多个类（C++中支持多继承）</li>
<li>Java中的间接继承
<ul>
<li>D extends C, C extends B, B extends A，则D直接继承C，间接继承B和A</li>
</ul>
</li>
<li>当Java中一个类没有显示的继承任何类时，该类<strong>默认继承</strong>JavaSE中的java.lang.Object类</li>
</ul>
<h3 id="继承的术语"><a class="markdownIt-Anchor" href="#继承的术语"></a> 继承的术语</h3>
<p>B类继承A类</p>
<ul>
<li>A类称为：父类，基类，超类(Superclass)</li>
<li>B类称为：子类、派生类(Subclass)</li>
</ul>
<p>一个简单的继承的例子</p>
<ul>
<li>银行账户类有自己的账户号码和账户余额</li>
<li>信用卡类继承账类，这样信用卡类就可以继承账户类中对于封装实例变量的set和get方法</li>
<li>在测试类中设置信用卡的账号和余额并获取其中的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//账户类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//封装的账户号码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> balance;<span class="comment">//封装的余额</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> num, <span class="type">float</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//一定得有这个缺省的构造函数</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">float</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CredictCard</span> <span class="keyword">extends</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> credit;</span><br><span class="line">  	<span class="comment">//省略自己的set和get方法，直接调用父类的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExtends</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">CredictCard</span> <span class="variable">cre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CredictCard</span>();</span><br><span class="line">        cre.setNum(<span class="number">123</span>);<span class="comment">//调用继承的方法</span></span><br><span class="line">        cre.setBalance(<span class="number">100.1f</span>);<span class="comment">//调用继承的方法</span></span><br><span class="line">        System.out.println(cre.getNum() + <span class="string">&quot; &quot;</span> + cre.getBalance());<span class="comment">//调用继承的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多态</title>
    <url>/2022/11/23/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A17/</url>
    <content><![CDATA[<h1 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h1>
<h3 id="多态中的几个概念"><a class="markdownIt-Anchor" href="#多态中的几个概念"></a> 多态中的几个概念</h3>
<ul>
<li>向上转型upcasting：子类型转向父类型，又被称为自动类型转换</li>
<li>向下转型downcasting：父类型转向子类型，又被称为强制类型转换</li>
<li>无论是向上转型还是向下转型，两种类型之间都要<u>满足继承</u>的关系才能转型</li>
</ul>
<h3 id="分析一个例子"><a class="markdownIt-Anchor" href="#分析一个例子"></a> 分析一个例子</h3>
<ul>
<li>有一个动物类，动物类中有移动的方法，动物在移动时输出“动物在移动”</li>
<li>有一个鸟类，鸟类继承动物类，并且覆盖了移动的方法，鸟在移动时输出“鸟在飞翔”</li>
<li>在主函数中声明一个指向鸟的动物类引用，试分析整个程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在移动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟在飞翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//父类型的引用指向一个子类型的对象</span></span><br><span class="line">        <span class="comment">//编译时animal是动物</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//鸟是动物</span></span><br><span class="line">        <span class="comment">//animal是动物类的引用，但指向的是鸟类的堆地址</span></span><br><span class="line">        <span class="comment">//在底层animal还是一个鸟类的引用</span></span><br><span class="line">        <span class="comment">//运行时animal是鸟</span></span><br><span class="line">        animal.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h84g7y3y5zj30u40bcmxt.jpg" alt="" /></p>
<ul>
<li>Java程序分为<u>编译</u>和<u>运行</u>两个阶段</li>
<li>在编译阶段
<ul>
<li>如果编译报错，则程序无法运行；编译阶段只检查语法，不会开辟内存空间，也不会运行程序</li>
<li>编译阶段编译器检查animal这个引用，它声明时的数据类型为Animal</li>
<li>在Animal.class字节码文件中有move()这个方法，所以调用animal.move()时编译通过</li>
<li>这个过程我们称为<strong>静态绑定</strong>，也就是在编译阶段绑定</li>
</ul>
</li>
<li>在运行阶段
<ul>
<li>运行时animal这个引用指向的堆内存存储的是一个Bird类型的数据</li>
<li>也就是说在JVM的堆内存中真实创建的对象是一个Bird类型的对象</li>
<li>那么在运行时调用的就是Bird类中的move()方法</li>
<li>这个过程我们称为程序的<strong>动态绑定</strong>，在运行阶段绑定</li>
</ul>
</li>
<li>更进一步的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="comment">//    public void move()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;鸟在飞翔&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hatch</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;鸟在孵蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//父类型的引用指向一个子类型的对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//鸟是动物</span></span><br><span class="line">        animal.move();</span><br><span class="line">      	<span class="comment">//animal.hatch();//编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h84ggx8rmdj30u60bkgmd.jpg" alt="" /></p>
<ul>
<li>此时animal.move()调用的还是Bird中的move()方法，只不过Bird中的move()方法直接继承了Animal中的方法，没有进行重写</li>
<li>当animal尝试调用Bird中的hatch()方法时，程序在编译阶段就会报错，因为在Animal.class字节码文件中Animal类没有hatch()方法，静态绑定失败！</li>
<li>总结
<ol>
<li>编译时只检查语法</li>
<li><strong>运行时引用指向的是什么对象就调用该对象的方法</strong></li>
</ol>
</li>
</ul>
<h3 id="向下转型"><a class="markdownIt-Anchor" href="#向下转型"></a> 向下转型</h3>
<ul>
<li>
<p>当调用的方法/属性是<u>子类独有</u>的，在父类中不存在，则必须通过向下转型才能实现调用/访问</p>
<ul>
<li><code>animal.hatch()</code></li>
</ul>
</li>
<li>
<p>将父类的引用强制转换为子类</p>
</li>
<li>
<p>强制类型转换语法格式</p>
<ul>
<li>
<p>子类 引用 = (父类) 引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//animal.hatch()编译报错</span></span><br><span class="line"><span class="comment">//编译通过</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line"><span class="type">Bird</span> <span class="variable">animal2</span> <span class="operator">=</span> (Bird) animal1;</span><br><span class="line">animal2.hatch();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong><code>java.lang.ClassCastException</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> (Cat) animal3;</span><br><span class="line"><span class="comment">//编译通过，但是运行时出错</span></span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.ClassCastException: class Animal.Bird cannot be cast to class Animal.Cat</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>编译期</p>
<ul>
<li><code>animal3</code>是一个父类的引用，声明时指向子类<code>Bird</code>的对象，编译通过</li>
<li>将<code>animal3</code>这个父类的引用向下转型，转换为子类<code>Cat</code>的引用，编译通过</li>
</ul>
</li>
<li>
<p>运行期</p>
<ul>
<li>运行期间，<code>animal3</code>这个引用初始化时指向的是堆内存中<code>Bird</code>类对象</li>
<li>在进行强制类型转换时，由于<code>Cat</code>类和<code>Bird</code>类之间不存在继承关系，<code>Bird</code>类对象无法转换成<code>Cat</code>类对象</li>
<li>出现<code>java.lang.ClassCastException</code>异常</li>
</ul>
</li>
<li>
<p><strong>这种异常总是在“向下转型”时发生</strong></p>
</li>
<li>
<p>向上转型：只要编译通过了，运行一定不会出现异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//父类型引用指向子类型对象</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>向下转型：存在安全隐患，即使编译通过，运行时也可能出现类型转换异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> (Cat) animal3;<span class="comment">//父类引用被强制转换为子类引用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="instanceof运算符"><a class="markdownIt-Anchor" href="#instanceof运算符"></a> instanceof运算符</h3>
<ul>
<li>
<p>解决向下转型时出现的安全风险</p>
</li>
<li>
<p>语法格式</p>
<ul>
<li><code>引用 instanceof 数据类型</code></li>
<li>例如：<code>a instanceof Animal</code></li>
<li>以上表达式的运算结果类型是布尔类型
<ul>
<li>当返回值是<code>true</code>时表示这个引用是当前的数据类型</li>
<li>当返回值是<code>false</code>时表示这个引用不是当前的数据类型</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Java规范中要求：在强制类型转换之前，使用<code>instanceof</code>运算符进行判断，避免<code>ClassCastException</code>的发生</p>
<ul>
<li>避免上述例子的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//父类型引用指向子类型对象</span></span><br><span class="line"><span class="keyword">if</span> (animal3 <span class="keyword">instanceof</span> Cat)&#123;<span class="comment">//判断父类引用在底层是否指向需要的类</span></span><br><span class="line">  <span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> (Cat) animal3;<span class="comment">//如果是，再进行强制类型转换</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;不能进行强制类型转换&quot;</span>);<span class="comment">//否则报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多态的作用"><a class="markdownIt-Anchor" href="#多态的作用"></a> 多态的作用</h3>
<ul>
<li>
<p>以主人饲养宠物为例</p>
<ul>
<li>主人可以饲养多种类型的宠物，给不同类型的宠物喂食，不同的宠物会有不同的反应</li>
</ul>
</li>
<li>
<p>不采用多态的方法</p>
<ul>
<li>针对每一种类型的宠物，都要单独在主人<code>Owner</code>类中编写一个<code>feed(宠物类型 宠物)</code>的方法</li>
</ul>
</li>
<li>
<p>采用多态的方法</p>
<ul>
<li>让所有猫、狗等不同的宠物类型继承<code>Pet</code>的父类，在Owner中只用编写一个<code>feed(Pet pet)</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Owner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//主人的姓名</span></span><br><span class="line">    <span class="keyword">private</span> Pet pet;<span class="comment">//主人拥有的宠物</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">//主人喂食</span></span><br><span class="line">  	<span class="comment">//主人面向的是抽象的Pet类，而不是具体的某一种宠物，降低耦合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Pet pet)</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;正在喂东西&quot;</span>);</span><br><span class="line">        pet.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;宠物正在吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">  	<span class="comment">//覆盖父类的eat方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗正在吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小猫正在吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只用在这里不停的添加新的宠物类型，而不用修改Owner类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//小狗类型的宠物</span></span><br><span class="line">        <span class="type">Owner</span> <span class="variable">owner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Owner</span>(<span class="string">&quot;张三&quot;</span>,pet);<span class="comment">//张三养的宠物是小狗类型</span></span><br><span class="line">        owner.feed(pet);</span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//张三养的宠物是小狗类型</span></span><br><span class="line">        owner.setPet(pet2);</span><br><span class="line">        owner.feed(pet2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多态的作用：<strong>降低程序的耦合度，提高程序的扩展力</strong></p>
</li>
<li>
<p>尽力多使用多态语法，父类型引用指向子类型对象</p>
</li>
<li>
<p><strong>面向抽象编程，而不要面向具体编程</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>final关键字</title>
    <url>/2022/11/23/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A18/</url>
    <content><![CDATA[<h1 id="final关键字"><a class="markdownIt-Anchor" href="#final关键字"></a> final关键字</h1>
<ul>
<li>
<p><code>final</code>关键字的作用</p>
<ul>
<li><code>final</code>是一个关键字，表示<u>最终的、不可变的</u></li>
<li><code>final</code>修饰的类是无法被继承的</li>
<li><code>final</code>修饰的方法无法被覆盖</li>
<li><code>final</code>修饰的变量一旦被赋值后，不可重新被赋值</li>
<li><code>final</code>修饰的实例变量，必须手动赋值，不能采用系统默认值</li>
<li><code>final</code>修饰的引用一旦指向一个堆内存中的对象后，不可重新指向其他对象</li>
</ul>
</li>
<li>
<p><code>final</code>修饰类时，被修饰的类无法再被继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> <span class="keyword">extends</span> <span class="title class_">test1</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h86z6voe8fj314a0dkgmr.jpg" alt="" /></p>
</li>
<li>
<p><code>final</code>修饰的方法无法被覆盖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> <span class="keyword">extends</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h86zbb1qijj31ba0eu0uo.jpg" alt="" /></p>
</li>
<li>
<p><code>final</code>修饰的变量一旦被赋值后，不能重新被赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        num1 = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        num2 = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h86zh8bkrpj30xe0pumzh.jpg" alt="" /></p>
</li>
<li>
<p><code>final</code>修饰的实例变量，必须在声明时就手动赋值</p>
<ul>
<li>实例变量在声明时，如果不手动初始化，系统将会自动为其初始化为0</li>
<li>但是被<code>final</code>修饰的变量只能被赋值一次，所以如果初始化时不对其进行手动赋值，则它永远也不能被赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> <span class="keyword">extends</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> c;<span class="comment">//编译错误</span></span><br><span class="line">  	<span class="keyword">final</span> <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//编译通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h86zz7zq7lj30ve0n8gno.jpg" alt="" /></p>
</li>
<li>
<p><code>final</code>修饰的引用一旦指向一个对象后，就不能再指向其他对象</p>
<ul>
<li>这也意味着，被<code>final</code>修饰的引用指向的对象无法被垃圾回收器回收</li>
<li>但是被<code>final</code>修饰的引用指向的对象的内存是可以被修改的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">test = <span class="keyword">new</span> <span class="title class_">Test</span>();<span class="comment">//编译报错</span></span><br><span class="line">test.num = <span class="number">10</span>;<span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h3>
<ul>
<li>
<p>final修饰的实例变量都是不可变的，这种变量一般都和static联合使用，被称为常量</p>
<ul>
<li>不可变的实例变量如果在每个对象中都保存一份的话会造成空间浪费</li>
</ul>
</li>
<li>
<p>语法格式</p>
<p><code>public static final 数据类型 常量名 = 值;</code></p>
</li>
<li>
<p>常量名的命名规范：所有字母大写，每个单词之间通过下划线来连接</p>
</li>
<li>
<p>由于常量在声明后无法被修改，所以被<code>public</code>修饰也是十分安全的</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>包</title>
    <url>/2022/11/23/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A19/</url>
    <content><![CDATA[<h1 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h1>
<h3 id="包机制"><a class="markdownIt-Anchor" href="#包机制"></a> 包机制</h3>
<ul>
<li>
<p>包<code>package</code>，Java中引入包机制主要是为了方便程序管理。不同功能的类被分门别类的放到不同的软件包当中，便于查找、管理依旧维护</p>
</li>
<li>
<p><code>package</code>的定义</p>
<ul>
<li>在Java源程序的第一行上编写<code>package</code>语句</li>
<li><code>package</code>只能编写一个语句</li>
<li>语法结构：<code>package 包名;</code></li>
</ul>
</li>
<li>
<p>包的命名规范：</p>
<ul>
<li>前缀 + 发起者名 + 项目名 + 模块名
<ul>
<li>前缀：
<ul>
<li><code>pers</code>个人项目，独自开发</li>
<li><code>priv</code>私有项目</li>
<li><code>team</code>团队项目</li>
<li><code>com</code>公司项目</li>
</ul>
</li>
</ul>
</li>
<li>包名要求<u>全部小写</u>，包名也是标识符，必须遵循标识符的命名规范</li>
</ul>
</li>
<li>
<p>一个包对应一个目录，目录之间用<code>.</code>分隔开</p>
<ul>
<li>例如：<code>pers.kevin.javase.day1117</code>就会生成四个目录</li>
</ul>
</li>
<li>
<p>一旦使用包机制后，<strong>类的名称就会改变</strong></p>
<ul>
<li>我们编写一个Test类，当使用如上的包后，Test类的名称就会变成<code>pers.kevin.javase.day1117.Test</code></li>
<li>当使用<code>javac</code>进行编译时，由于<code>javac</code>后面接的是文件的路径，所以使用包机制后带来的类名的变化影响不大</li>
<li>我们将<code>java</code>源程序放在<u>其他目录</u>下进行编译</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h87v6qn5vcj30nm09xwez.jpg" alt="" /></p>
<ul>
<li>编译通过，并且在同一个目录下生成了相应的字节码文件</li>
<li>那么我们尝试在这个目录下对其使用<code>java</code>命令</li>
</ul>
<p>![image-20221117092753802](/Users/hewenkai/Library/Application Support/typora-user-images/image-20221117092753802.png)</p>
<ul>
<li>编译器报错，提示找不到或无法加载主类</li>
<li>那么我们修改相应的类名</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h87vbgvw9kj30pq0gl40m.jpg" alt="" /></p>
<ul>
<li>编译器同样报错，提示相同的原因</li>
<li>我们将字节码文件移动到包所对应的目录下，再次尝试运行</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h87wdcf69nj30pq0gldgm.jpg" alt="" /></p>
</li>
<li>
<p>包名的省略</p>
<ul>
<li>
<p>当两个类在同一个包下时，可以省略包名</p>
</li>
<li>
<p>当两个类不在同一个包下时，一定要在类前加上完整的包名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		pers.kevin.javase.day1117.<span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">pers</span>.kevin.javase.day1117.Test();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="import关键字"><a class="markdownIt-Anchor" href="#import关键字"></a> <code>import</code>关键字</h3>
<ul>
<li>import语句用来完成导入其他类，同一个包下的类不需要倒入，不在同一个包下的类需要手动导入</li>
<li>语法格式：
<ul>
<li><code>import 类名;</code></li>
<li><code>import 包名.*;</code>代表引入这个包下的所有类</li>
</ul>
</li>
<li><code>import</code>语句需要编写到<code>package</code>语句之下，<code>class</code>语句之上</li>
<li>同样是上面的例子：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pers.kevin.javase.day1117.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>java.lang.*不需要手动引入</li>
</ul>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>List接口</title>
    <url>/2022/12/22/Java/List%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="迭代器的补充"><a class="markdownIt-Anchor" href="#迭代器的补充"></a> 迭代器的补充</h2>
<h3 id="迭代器是对集合当前状态的一个快照"><a class="markdownIt-Anchor" href="#迭代器是对集合当前状态的一个快照"></a> 迭代器是对集合当前状态的一个快照</h3>
<ul>
<li><code>Iterator it = collection.iterator()</code>
<ul>
<li>获取集合<code>collection</code>的迭代器对象，迭代器用来遍历集合</li>
<li>迭代器相当于给当前集合状态拍了一个快照</li>
<li>迭代器通过参考这个快照来对集合进行迭代</li>
<li>迭代器在遍历集合时会不停的检查快照的有效性</li>
</ul>
</li>
<li>当集合状态发生改变时，之前的快照（迭代器）就会失效，导致无法迭代
<ul>
<li>抛出<code>ConcurrentModificationException</code>异常</li>
<li>集合状态的改变包括
<ul>
<li>元素的增加</li>
<li>元素的删除</li>
<li>等等</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    collection.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;ghi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">      	<span class="comment">//通过集合进行修改 </span></span><br><span class="line">      	<span class="comment">//对集合进行了修改，导致迭代器（快照）失效</span></span><br><span class="line">        collection.remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9cehgyfn4j30pb0a0wfx.jpg" alt="" /></p>
<ul>
<li>通过迭代器来对集合进行修改
<ul>
<li>通过迭代器进行修改，会直接修改这个快照以及快照所对应的集合，保持快照和集合的对应</li>
<li>通过迭代器进行修改会更新迭代器</li>
<li>不会报错</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    collection.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;789&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">      	<span class="comment">//通过迭代器进行修改，可以直接修改快照和集合</span></span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="list接口"><a class="markdownIt-Anchor" href="#list接口"></a> <code>List</code>接口</h2>
<h3 id="list集合存储特点"><a class="markdownIt-Anchor" href="#list集合存储特点"></a> <code>List</code>集合存储特点</h3>
<blockquote>
<p>An ordered collection (also known as a <em>sequence</em>). （有序的集合）The user of this interface has precise control over where in the list each element is inserted（能够控制List中每一个元素）. The user can access elements by their integer index (position in the list), and search for elements in the list.（通过元素下标来访问控制元素）</p>
</blockquote>
<ol>
<li>有序
<ul>
<li><code>List</code>集合中的元素有下标，下标从0开始，以1递增</li>
</ul>
</li>
<li>可重复
<ul>
<li><code>List</code>集合中允许有重复元素</li>
</ul>
</li>
</ol>
<h3 id="list接口的特有方法"><a class="markdownIt-Anchor" href="#list接口的特有方法"></a> <code>List</code>接口的特有方法</h3>
<h4 id="void-addint-index-e-element"><a class="markdownIt-Anchor" href="#void-addint-index-e-element"></a> <code>void add(int index, E element)</code></h4>
<blockquote>
<p>Inserts the specified element at the specified position in this list (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).</p>
</blockquote>
<ul>
<li>将元素插入List中的特定位置
<ul>
<li>如果原来的位置上有元素的话就将其替代，然后后续元素向后移动</li>
</ul>
</li>
<li>效率较低，涉及到大量元素的移动
<ul>
<li>底层是数组实现</li>
</ul>
</li>
<li><code>boolean add(E e)</code>
<ul>
<li>默认向集合尾部插入元素</li>
<li>效率较高</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    list1.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">    list1.add(<span class="string">&quot;789&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list1.add(<span class="number">1</span>,<span class="string">&quot;def&quot;</span>);<span class="comment">//在下标为1处插入</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list1.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    		System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="e-getint-index"><a class="markdownIt-Anchor" href="#e-getint-index"></a> <code>E get(int index)</code></h4>
<blockquote>
<p>Returns the element at the specified position in this list.</p>
</blockquote>
<ul>
<li>通过下标来获取元素</li>
<li>可以通过这个方法来遍历<code>List</code>集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list1.size();i ++)&#123;</span><br><span class="line">		System.out.println(list1.get(i));	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="int-indexofobject-o"><a class="markdownIt-Anchor" href="#int-indexofobject-o"></a> <code>int indexOf(Object o)</code></h4>
<blockquote>
<p>Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index <code>i</code> such that<code>(o==null ? get(i)==null : o.equals(get(i)))</code>, or -1 if there is no such index.</p>
</blockquote>
<ul>
<li>返回对象<em>o</em>第一次出现的下标
<ul>
<li>当<code>List</code>中不存在对象<em>o</em>时返回*-1*</li>
</ul>
</li>
<li><code>int lastIndexOf(Object o)</code>
<ul>
<li>返回对象最后一次出现的下标</li>
</ul>
</li>
</ul>
<h4 id="e-removeint-index"><a class="markdownIt-Anchor" href="#e-removeint-index"></a> <code>E remove(int index)</code></h4>
<blockquote>
<p>Removes the element at the specified position in this list (optional operation). Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.</p>
</blockquote>
<ul>
<li>删除指定下标处的元素
<ul>
<li>然后后续元素向前移动</li>
</ul>
</li>
</ul>
<h4 id="e-setint-index-e-element"><a class="markdownIt-Anchor" href="#e-setint-index-e-element"></a> <code>E set(int index, E element)</code></h4>
<blockquote>
<p>Replaces the element at the specified position in this list with the specified element (optional operation).</p>
</blockquote>
<ul>
<li>修改指定下标处的元素</li>
</ul>
<h2 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> <code>ArrayList</code></h2>
<h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3>
<blockquote>
<p>Resizable-array implementation of the <code>List</code> interface. Implements all optional list operations, and permits all elements, including <code>null</code>. In addition to implementing the <code>List</code> interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to <code>Vector</code>, except that it is unsynchronized.)</p>
</blockquote>
<ul>
<li><code>ArrayList</code>底层使用数组实现的
<ul>
<li><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9cg908dw3j30lx04sjru.jpg" alt="" /></li>
<li><code>ArrayList</code>集合初始化容量是10
<ul>
<li>底层先创建了一个长度为0的数组，当有元素加入时再把它扩容到初始容量</li>
</ul>
</li>
<li><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9cg861vicj30ha08t0tb.jpg" alt="" /></li>
<li>默认是一个<code>Object</code>类型的数组</li>
</ul>
</li>
<li>可以通过初始化的方式确定<code>ArrayList</code>数组的大小
<ul>
<li><code>public ArrayList(int initialCapacity)</code></li>
<li>通过<code>size()</code>方法获得的是当前集合元素的个数，而非集合的大小</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定初始化一个数组大小为20的ArrayList</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">arrayList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">arrayList2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="number">40</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;arrayList1: &quot;</span> + arrayList1.size());</span><br><span class="line">    System.out.println(<span class="string">&quot;arrayList2: &quot;</span> + arrayList2.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9cghu7c3dj30fz06oaad.jpg" alt="" /></p>
<h3 id="扩容"><a class="markdownIt-Anchor" href="#扩容"></a> 扩容</h3>
<ul>
<li>当原来的ArrayList集合已经满了的时候，如果我们继续向其中增加元素，集合会自动扩容</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> s;</span><br><span class="line">    Object[] elementData;</span><br><span class="line">    <span class="keyword">if</span> ((s = size) == (elementData = <span class="built_in">this</span>.elementData).length)</span><br><span class="line">    		elementData = grow();</span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">        elementData, index + <span class="number">1</span>,</span><br><span class="line">        s - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class="line">                    minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">                    <span class="comment">//增长原来的一半</span></span><br><span class="line">                    oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);</span><br><span class="line">            <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>扩容的容量是之前容量的</strong>$\frac{1}{2} $
<ul>
<li>旧容量是<em>10</em>，如果此时集合已经满了</li>
<li>增长<em>5</em></li>
<li>新的容量是<em>15</em></li>
</ul>
</li>
<li>尽可能减少扩容的次数</li>
</ul>
<h2 id="linklist"><a class="markdownIt-Anchor" href="#linklist"></a> <code>LinkList</code></h2>
<h3 id="链表的优缺点"><a class="markdownIt-Anchor" href="#链表的优缺点"></a> 链表的优缺点</h3>
<ul>
<li>优点：随机增删元素的效率高</li>
<li>缺点：查询效率低</li>
</ul>
<h3 id="初始化-2"><a class="markdownIt-Anchor" href="#初始化-2"></a> 初始化</h3>
<ul>
<li><code>LinkList</code>在底层是一个双向链表
<ul>
<li><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9cpk7bmprj30hc0bdwex.jpg" alt="" /></li>
<li>初始化了两个指针<code>first</code>和<code>last</code>，分别用于指向链表中的头节点和尾节点
<ul>
<li><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9cprno1kvj309o06jjrf.jpg" alt="" /></li>
</ul>
</li>
</ul>
</li>
<li><code>LinkList</code>底层不是数组，没有初始化容量一说
<ul>
<li><code>first</code>和<code>last</code>初始值都为<code>null</code></li>
</ul>
</li>
</ul>
<h3 id="元素的增加"><a class="markdownIt-Anchor" href="#元素的增加"></a> 元素的增加</h3>
<h4 id="public-boolean-adde-e"><a class="markdownIt-Anchor" href="#public-boolean-adde-e"></a> <code>public boolean add(E e)</code></h4>
<blockquote>
<p>Appends the specified element to the end of this list.</p>
</blockquote>
<ul>
<li>在双链表的末尾增添元素</li>
<li>等价于<code>public void addLast(E e)</code></li>
</ul>
<h4 id="public-void-addfirste-e"><a class="markdownIt-Anchor" href="#public-void-addfirste-e"></a> <code>public void addFirst(E e)</code></h4>
<blockquote>
<p>Inserts the specified element at the beginning of this list.</p>
</blockquote>
<ul>
<li>在链表的头部添加元素</li>
</ul>
<h2 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> <code>Vector</code></h2>
<ul>
<li>底层是一个数组</li>
<li>初始化容量是10</li>
<li>每次成倍的增长</li>
</ul>
<h3 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h3>
<ul>
<li><code>Vector</code>是线程安全的</li>
<li>将<code>ArrayListh</code>和<code>LinkList</code>转化为线程安全的方法
<ul>
<li><code>Collections</code>类下的<code>synchronizedList()</code>方法
<ul>
<li><code>Collections</code>是一个集合工具类</li>
<li><code>Collection</code>是一个集合接口</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Map接口</title>
    <url>/2022/12/23/Java/Map/</url>
    <content><![CDATA[<h1 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h1>
<h2 id="map接口"><a class="markdownIt-Anchor" href="#map接口"></a> Map接口</h2>
<ul>
<li><code>Map</code>集合和<code>Collection</code>集合没有关系
<ul>
<li><code>Map</code>集合以键值对（<code>key</code>和<code>vlaue</code>）存储元素
<ul>
<li>其中<code>key</code>和<code>value</code>存储的都是对象的引用</li>
<li><code>key</code>起主导作用，<code>value</code>只是其附属品</li>
</ul>
</li>
<li>Map集合的特点
<ul>
<li>无序不可重复</li>
</ul>
</li>
</ul>
</li>
<li>有三个类直接实现了<code>Map</code>接口
<ul>
<li><code>HashMap</code>：底层是哈希表数据结构</li>
<li><code>Hashtable</code>：底层同样是哈希表数据结构，但是因为其是线程安全的，效率较低
<ul>
<li><code>Properties</code>：继承<code>Hashtable</code>，但是<code>key</code>和<code>value</code>存储的对象都是字符串</li>
</ul>
</li>
<li><code>SortedMap</code>：集合key部分元素会自动排序
<ul>
<li><code>TreeMap</code>：底层数据结构是一个二叉树</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="map接口中的常用方法"><a class="markdownIt-Anchor" href="#map接口中的常用方法"></a> Map接口中的常用方法</h2>
<h3 id="v-putk-key-v-value"><a class="markdownIt-Anchor" href="#v-putk-key-v-value"></a> <code>V put(K key, V value)</code></h3>
<blockquote>
<p>Associates the specified value with the specified key in this map (optional operation). If the map previously contained a mapping for the key, the old value is replaced by the specified value. (A map <code>m</code> is said to contain a mapping for a key <code>k</code> if and only if <code>m.containsKey(k)</code> would return <code>true</code>.</p>
<p>Returns:</p>
<p>the previous value associated with <code>key</code>, or <code>null</code> if there was no mapping for <code>key</code>. (A <code>null</code> return can also indicate that the map previously associated <code>null</code> with <code>key</code>, if the implementation supports <code>null</code> values.)</p>
</blockquote>
<ul>
<li>向Map集合添加键值对</li>
<li>返回值：
<ul>
<li>返回的是这个<code>key</code><u>之前</u>绑定的<code>value</code></li>
<li>如果之前没有绑定过<code>value</code>则返回<code>null</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="number">1</span>,<span class="string">&quot;123&quot;</span>);<span class="comment">//null</span></span><br><span class="line">map.put(<span class="number">1</span>,<span class="string">&quot;123&quot;</span>);<span class="comment">//123</span></span><br></pre></td></tr></table></figure>
<h3 id="v-getobject-key"><a class="markdownIt-Anchor" href="#v-getobject-key"></a> <code>V get(Object key)</code></h3>
<blockquote>
<p>Returns the value to which the specified key is mapped, or <code>null</code> if this map contains no mapping for the key.</p>
</blockquote>
<ul>
<li>通过<code>key</code>去获得<code>value</code></li>
</ul>
<h3 id="void-clear"><a class="markdownIt-Anchor" href="#void-clear"></a> <code>void clear()</code></h3>
<blockquote>
<p>Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.</p>
</blockquote>
<ul>
<li>清空Map集合</li>
</ul>
<h3 id="v-removeobject-key"><a class="markdownIt-Anchor" href="#v-removeobject-key"></a> <code>V remove(Object key)</code></h3>
<blockquote>
<p>Removes the mapping for a key from this map if it is present (optional operation). More formally, if this map contains a mapping from key <code>k</code> to value <code>v</code> such that <code>(key==null ? k==null : key.equals(k))</code>, that mapping is removed. (The map can contain at most one such mapping.)</p>
<p>Returns:</p>
<p>the previous value associated with <code>key</code>, or <code>null</code> if there was no mapping for <code>key</code>.</p>
</blockquote>
<ul>
<li>通过<code>key</code>来删除<code>Map</code>中的键值对</li>
<li>返回删除的<code>key</code>所对应的<code>value</code>，如果不存在<code>key</code>时返回<code>null</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="number">1</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">map.remove(<span class="number">1</span>);<span class="comment">//123</span></span><br><span class="line">map.remove(<span class="number">1</span>);<span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<h3 id="boolean-containskeyobject-key"><a class="markdownIt-Anchor" href="#boolean-containskeyobject-key"></a> <code>boolean containsKey(Object key)</code></h3>
<blockquote>
<p>Returns <code>true</code> if this map contains a mapping for the specified key. More formally, returns <code>true</code> if and only if this map contains a mapping for a key <code>k</code> such that <code>(key==null ? k==null : key.equals(k))</code>. (There can be at most one such mapping.)</p>
</blockquote>
<ul>
<li>判断<code>Map</code>中是否包含某个<code>key</code></li>
</ul>
<h3 id="boolean-containsvalueobject-value"><a class="markdownIt-Anchor" href="#boolean-containsvalueobject-value"></a> <code>boolean containsValue(Object value)</code></h3>
<blockquote>
<p>Returns <code>true</code> if this map maps one or more keys to the specified value. More formally, returns <code>true</code> if and only if this map contains at least one mapping to a value <code>v</code> such that <code>(value==null ? v==null : value.equals(v))</code>. This operation will probably require time linear in the map size for most implementations of the <code>Map</code> interface.</p>
</blockquote>
<ul>
<li>判断<code>Map</code>中是否包含某个<code>value</code></li>
<li>底层是用<code>equals</code>方法
<ul>
<li>需要重写<code>equals</code>方法</li>
</ul>
</li>
</ul>
<h3 id="boolean-isempty"><a class="markdownIt-Anchor" href="#boolean-isempty"></a> <code>boolean isEmpty()</code></h3>
<blockquote>
<p>Returns <code>true</code> if this map contains no key-value mappings.</p>
</blockquote>
<ul>
<li>判断某个Map是否为空</li>
</ul>
<h3 id="int-size"><a class="markdownIt-Anchor" href="#int-size"></a> <code>int size()</code></h3>
<blockquote>
<p>Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.</p>
</blockquote>
<ul>
<li>返回Map中键值对的个数</li>
</ul>
<h3 id="collectionv-values"><a class="markdownIt-Anchor" href="#collectionv-values"></a> <code>Collection&lt;V&gt; values()</code></h3>
<blockquote>
<p>Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own <code>remove</code> operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the <code>Iterator.remove</code>, <code>Collection.remove</code>, <code>removeAll</code>, <code>retainAll</code> and <code>clear</code> operations. It does not support the <code>add</code> or <code>addAll</code> operations.</p>
</blockquote>
<ul>
<li>获取Map集合中所有的<code>vlaue</code>，返回一个<code>Collction</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="number">1</span>,<span class="string">&quot;123&quot;</span>);map.put(<span class="number">2</span>,<span class="string">&quot;456&quot;</span>);map.put(<span class="number">3</span>,<span class="string">&quot;789&quot;</span>);</span><br><span class="line"><span class="comment">//用一个集合去接受map所有的value</span></span><br><span class="line">Collection&lt;String&gt; collection = map.values();</span><br></pre></td></tr></table></figure>
<h3 id="setk-keyset"><a class="markdownIt-Anchor" href="#setk-keyset"></a> <code>Set&lt;K&gt; keySet()</code></h3>
<blockquote>
<p>Returns a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Set.html"><code>Set</code></a> view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own <code>remove</code> operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the <code>Iterator.remove</code>, <code>Set.remove</code>, <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code> operations. It does not support the <code>add</code> or <code>addAll</code> operations.</p>
</blockquote>
<ul>
<li>获取<code>Map</code>集合中所有的<code>key</code></li>
</ul>
<h3 id="setmapentrykv-entryset"><a class="markdownIt-Anchor" href="#setmapentrykv-entryset"></a> <code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></h3>
<blockquote>
<p>Returns a <code>Set</code> view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own <code>remove</code> operation, or through the <code>setValue</code> operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the <code>Iterator.remove</code>, <code>Set.remove</code>, <code>removeAll</code>, <code>retainAll</code> and <code>clear</code> operations. It does not support the <code>add</code> or <code>addAll</code> operations.</p>
</blockquote>
<ul>
<li>将整个<code>Map</code>变成一个<code>Set</code>集合
<ul>
<li>这个集合中的数据类型是<code>Map.Entry&lt;K,V&gt;</code></li>
</ul>
</li>
</ul>
<h3 id="遍历map的方法"><a class="markdownIt-Anchor" href="#遍历map的方法"></a> 遍历Map的方法</h3>
<h4 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h4>
<ul>
<li>先通过<code>Set&lt;K&gt; keySet()</code>获得<code>Map</code>所有的<code>key</code>，然后再通过<code>get()</code>方法，用<code>key</code>获得对应的<code>value</code></li>
<li>通过遍历<code>Set</code>集合中的<code>key</code>，来遍历整个<code>Map</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; keySet = map.keySet();<span class="comment">//获得所有的key</span></span><br><span class="line">Iterator&lt;Integer&gt; interator = keySet.iterator();<span class="comment">//用迭代器进行遍历</span></span><br><span class="line"><span class="keyword">while</span> (interator.hasNext())&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> interator.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h4>
<ul>
<li>直接用<code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>方法，将整个<code>Map</code>变成集合</li>
<li>然后再遍历这个集合
<ul>
<li>集合中的每一项称为节点<code>node</code></li>
<li>通过<code>getKey()</code>方法获得节点的<code>key</code></li>
<li>通过<code>getValue()</code>方法获得节点的<code>value</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">		Map.Entry&lt;Integer,String&gt; node = iterator.next();<span class="comment">//每一项称为一个节点</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> node.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> node.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">  	<span class="comment">//System.out.println(node);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeMap集合</title>
    <url>/2022/12/25/Java/TreeMap%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="treemap集合"><a class="markdownIt-Anchor" href="#treemap集合"></a> TreeMap集合</h1>
<h2 id="treemap的存储"><a class="markdownIt-Anchor" href="#treemap的存储"></a> TreeMap的存储</h2>
<ul>
<li><code>TreeMap</code>是实现了<code>Map</code>接口下的<code>SortedMap</code>接口</li>
<li><code>TreeMap</code>集合中元素的存储特点
<ul>
<li>无序不可重复</li>
<li>集合<code>key</code>部分的元素会自动按照从大到小的顺序排序</li>
</ul>
</li>
<li><code>TreeMap</code>集合底层是一个二叉树</li>
<li>放到<code>TreeSet</code>集合中的元素等同于放到<code>TreeMap</code>集合的<code>key</code>部分
<ul>
<li>那么直接按照集合中的元素进行排序</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeSet&lt;String&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//乱序插入</span></span><br><span class="line">    treeSet.add(<span class="string">&quot;444&quot;</span>);treeSet.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">  	treeSet.add(<span class="string">&quot;333&quot;</span>);treeSet.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    Iterator&lt;String&gt; iterator = treeSet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">      System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9fuqqnv18j30fs08wq36.jpg" alt="" /></p>
<h2 id="自平衡二叉树"><a class="markdownIt-Anchor" href="#自平衡二叉树"></a> 自平衡二叉树</h2>
<ul>
<li>遵循左孩子&lt;根节点&lt;右孩子</li>
<li><code>TreeSet</code>和<code>Treemap</code>集合采用的是中序遍历
<ul>
<li>左孩子-&gt;根节点-&gt;右孩子</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  	 <span class="comment">//如果有比较器，则通过比较器来实现比较</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">    		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  	 <span class="comment">//否则通过该类所实现的Comparable接口来比较</span></span><br><span class="line">  	 Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;<span class="comment">//从根结点开始向下寻找</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key);</span><br><span class="line">      <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)<span class="comment">//小于根节点，则寻找左孩子</span></span><br><span class="line">      		p = p.left;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//大于根结点，则寻找右孩子</span></span><br><span class="line">     	 	p = p.right;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      		<span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因此我们得到，实现<code>TreeMap</code>或者<code>TreeSet</code>集合中比较功能有<u>两种方法</u>
<ol>
<li>该类实现<code>Comparable</code>接口
<ul>
<li>一个类只能实现一次<code>Comparable</code>接口，其比较规则不能再改变</li>
</ul>
</li>
<li>重写编写一个<code>Comparator</code>类实现比较器
<ul>
<li>可以编写多个规则的多个比较器的类，使用不同的比较规则就可以传不同的比较器到集合中</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="comparable接口"><a class="markdownIt-Anchor" href="#comparable接口"></a> Comparable接口</h2>
<h3 id="comparable接口的实现"><a class="markdownIt-Anchor" href="#comparable接口的实现"></a> <code>Comparable</code>接口的实现</h3>
<ul>
<li>
<p><u>放在<code>TreeMap</code>或者<code>TreeSet</code>集合中的元素需要实现<code>java.lang.Comparable</code>接口</u></p>
<ul>
<li>这两个集合通过<code>Comparable</code>接口中<code>compareTo()</code>方法进行排序</li>
</ul>
</li>
<li>
<p>设计类如果没有实现<code>Comparable</code>接口</p>
<ul>
<li>会抛出<code>ClassCastException</code>异常</li>
</ul>
</li>
<li>
<p>直接让设计的类实现（<code>implements</code>）<code>Comparable</code>接口即可</p>
<ul>
<li>然后在类中重写<code>compareTo()</code>方法</li>
<li>在实现接口时可以使用泛型，避免之后在重写方法时还需要向下转型</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">10</span>,<span class="string">&quot;aaa&quot;</span>);<span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">50</span>,<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">20</span>,<span class="string">&quot;ccc&quot;</span>);<span class="type">User</span> <span class="variable">user4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">30</span>,<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;User&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        treeSet.add(user1);treeSet.add(user2);</span><br><span class="line">        treeSet.add(user3);treeSet.add(user4);</span><br><span class="line"></span><br><span class="line">        test1(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(TreeSet&lt;User&gt; treeSet)</span>&#123;</span><br><span class="line">        Iterator&lt;User&gt; iterator = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现<code>Comparable</code>接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;User&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;的年龄是&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(User o)</span> &#123;</span><br><span class="line">      	<span class="comment">//按照年龄升序排列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9fvsngmwlj30fy07u3yv.jpg" alt="" /></p>
<h3 id="comparable比较规则"><a class="markdownIt-Anchor" href="#comparable比较规则"></a> <code>Comparable</code>比较规则</h3>
<ul>
<li>
<p><code>compareTo()</code>方法</p>
<ul>
<li><code>obj1.compareTo(Object obj2)</code></li>
<li>当<code>obj1</code>的某个属性值<u>大于</u><code>obj2</code>的属性值时，返回正数</li>
<li>当<code>obj1</code>的某个属性值<u>等于</u><code>obj2</code>的属性值时，返回0</li>
<li>当<code>obj1</code>的某个属性值<u>小于</u><code>obj2</code>的属性值时，返回负数</li>
</ul>
</li>
<li>
<p><code>this-obj</code>就是升序，<code>obj-this</code>就是降序</p>
</li>
<li>
<p>更复杂的</p>
<ul>
<li>按照年龄降序排列，年龄相同的按照姓名升序排列</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">//由于在声明实现接口时已经使用了泛型，所以方法的形参直接是User</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(User o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.age == o.age)&#123;</span><br><span class="line">      	<span class="comment">//String类已经实现了compareTo()方法，直接调用即可</span></span><br><span class="line">    		<span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(o.name);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//降序排序</span></span><br><span class="line">    		<span class="keyword">return</span> o.age - <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9fwhoa1v1j30fy08bglz.jpg" alt="" /></p>
<h2 id="comparator比较器"><a class="markdownIt-Anchor" href="#comparator比较器"></a> Comparator比较器</h2>
<ul>
<li>实现<code>TreeSet</code>和<code>TreeMap</code>中比较的第二种方法：单独实现比较器</li>
<li>比较器实现的是<code>java.util.Comparator</code>，比较接口<code>Comparable</code>是<code>java.lang</code>包下的</li>
<li>当比较规则比较多变时，可以编写多个比较器
<ul>
<li>需要哪种比较规则时，就将某一种比较器作为参数传入到集合中</li>
</ul>
</li>
</ul>
<h3 id="treeset的构造方法"><a class="markdownIt-Anchor" href="#treeset的构造方法"></a> <code>TreeSet</code>的构造方法</h3>
<h4 id="public-treeset"><a class="markdownIt-Anchor" href="#public-treeset"></a> <code>public TreeSet()</code></h4>
<ul>
<li>有无参的构造方法</li>
</ul>
<h4 id="public-treesetcomparator-super-e-comparator"><a class="markdownIt-Anchor" href="#public-treesetcomparator-super-e-comparator"></a> <code>public TreeSet(Comparator&lt;? super E&gt; comparator)</code></h4>
<ul>
<li>有有参的构造方法
<ul>
<li>参数需要一个比较器</li>
</ul>
</li>
<li>比较器<code>Comparator</code><u>是一个单独的类</u>
<ul>
<li>而不是类似实现<code>Comparable</code>接口时，只需要原本的类实现该接口即可</li>
</ul>
</li>
</ul>
<h3 id="comparator比较器的实现"><a class="markdownIt-Anchor" href="#comparator比较器的实现"></a> <code>Comparator</code>比较器的实现</h3>
<ul>
<li>单独编写一个比较器的类来实现<code>Comparator</code>接口
<ul>
<li>这个比较器是专门针对需要比较的类（即存储于<code>TreeMap</code>或者<code>TreeSet</code>中的元素)来实现的</li>
<li>并不能在多个类之间通用</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;动物的名字是 &quot;</span> + name + <span class="string">&quot; 年龄是 &quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独编写一个比较器类，实现比较器的接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Animal&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Animal o1, Animal o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1.age == o2.age) <span class="keyword">return</span> o1.name.compareTo(o2.name);</span><br><span class="line">        <span class="keyword">return</span> o1.age- o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="number">50</span>,<span class="string">&quot;111&quot;</span>);<span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="number">20</span>,<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="number">40</span>,<span class="string">&quot;333&quot;</span>);<span class="type">Animal</span> <span class="variable">animal4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="number">40</span>,<span class="string">&quot;444&quot;</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="number">50</span>,<span class="string">&quot;555&quot;</span>);</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">//在声明集合时，就需要用构造器的有参构造方法来申请集合</span></span><br><span class="line">        TreeSet&lt;Animal&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">AnimalComparator</span>());</span><br><span class="line">        treeSet.add(animal1);treeSet.add(animal2);</span><br><span class="line">        treeSet.add(animal3);treeSet.add(animal4);</span><br><span class="line">        treeSet.add(animal5);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Animal animal: treeSet)&#123;</span><br><span class="line">            System.out.println(animal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9fy1rvzcfj30ft07jaaj.jpg" alt="" /></p>
<h3 id="comparator比较器的匿名类实现"><a class="markdownIt-Anchor" href="#comparator比较器的匿名类实现"></a> Comparator比较器的匿名类实现</h3>
<ul>
<li>直接通过匿名类的方式来创造一个比较器
<ul>
<li>一个比较器只用于一个类的比较，没有必要做到复用</li>
</ul>
</li>
<li>匿名类不需要<code>implements</code>关键字
<ul>
<li>在匿名类中直接重写<code>compare()</code>方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;Animal&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Animal&gt;() &#123;</span><br><span class="line">  	<span class="comment">//大括号中是对这个匿名类的实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Animal o1, Animal o2)</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="collections工具类常用方法"><a class="markdownIt-Anchor" href="#collections工具类常用方法"></a> Collections工具类常用方法</h2>
<h3 id="public-static-t-extends-comparable-super-t-void-sortlistt-list"><a class="markdownIt-Anchor" href="#public-static-t-extends-comparable-super-t-void-sortlistt-list"></a> <code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</code></h3>
<blockquote>
<p>Sorts the specified list into ascending order, according to the natural ordering of its elements. All elements in the list must implement the <code>Comparable</code> interface. Furthermore, all elements in the list must be <em>mutually comparable</em> (that is, <code>e1.compareTo(e2)</code>must not throw a <code>ClassCastException</code> for any elements <code>e1</code> and <code>e2</code> in the list).</p>
</blockquote>
<ul>
<li>用于对集合中的元素进行排序
<ul>
<li>待排序的元素需要实现 <code>Comparable</code>接口</li>
</ul>
</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code></li>
<li>类似的，也可以通过参数的方式传入一个比较器用于比较</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;小狗的名字是 &quot;</span> + name + <span class="string">&quot;年龄是 &quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age == o.age) <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(o.name);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Dog&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;aaa&quot;</span>,<span class="number">10</span>));list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;bbb&quot;</span>,<span class="number">35</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;ccc&quot;</span>,<span class="number">25</span>));list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;ddd&quot;</span>,<span class="number">10</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;eee&quot;</span>,<span class="number">15</span>));</span><br><span class="line">				<span class="comment">//调用Collections工具类的静态方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Dog dog: list)&#123;</span><br><span class="line">            System.out.println(dog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h9fzpgb7hhj30fs08q3z2.jpg" alt="" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;小猫的名字是 &quot;</span> + name + <span class="string">&quot; 年龄是 &quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CatComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Cat&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Cat o1, Cat o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.age - o2.age;<span class="comment">//按照年龄升序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Cat&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      	<span class="comment">//随机产生10个元素</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> random.nextInt(num);</span><br><span class="line">            <span class="type">String</span> <span class="variable">randomName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(random.nextInt(num)));</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Cat</span>(randomName,randomNum));</span><br><span class="line">            num --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">CatComparator</span>());</span><br><span class="line">        <span class="keyword">for</span> (Cat cat: list)&#123;</span><br><span class="line">            System.out.println(cat);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Object类</title>
    <url>/2022/11/26/Java/Object%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="object类"><a class="markdownIt-Anchor" href="#object类"></a> Object类</h1>
<h2 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h2>
<ul>
<li>Application Program Interface</li>
<li>整个JDK的类库就是一个JavaSE的API</li>
<li>每一个API都会配置一套API的帮助文档
<ul>
<li><a href="https://www.oracle.com/cn/java/technologies/java-se-api-doc.html">https://www.oracle.com/cn/java/technologies/java-se-api-doc.html</a></li>
</ul>
</li>
</ul>
<h2 id="protected-object-clone"><a class="markdownIt-Anchor" href="#protected-object-clone"></a> <code>protected Object clone()</code></h2>
<blockquote>
<p>Creates and returns a copy of this object. The precise meaning of &quot;copy&quot; may depend on the class of the object.</p>
<p>The general intent is that, for any object <code>x</code>, the expression:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;x.clone() != x<span class="comment">//克隆的对象和原对象的地址不同</span></span><br></pre></td></tr></table></figure>
<p>will be true, and that the expression:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;x.clone().getClass() == x.getClass()<span class="comment">//克隆的对象和原对象属于同一类</span></span><br></pre></td></tr></table></figure>
<p>will be <code>true</code>, but these are not absolute requirements. While it is typically the case that:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;x.clone().equals(x)<span class="comment">//克隆的对象和原对象的内容相同</span></span><br></pre></td></tr></table></figure>
<p>will be <code>true</code>, this is not an absolute requirement.</p>
</blockquote>
<ul>
<li>
<p><code>protected Object clone()</code>‘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="int-hascode"><a class="markdownIt-Anchor" href="#int-hascode"></a> <code>int hasCode()</code></h2>
<blockquote>
<p>Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by HashMap</p>
<p>The general contract of <code>hashCode</code> is:</p>
<ul>
<li>Whenever it is invoked on the same object more than once during an execution of a Java application, the <code>hashCode</code>method must consistently return the same integer, provided no information used in <code>equals</code> comparisons on the object is modified.（在一次程序的执行中每个对象的哈希值都相同） This integer need not remain consistent from one execution of an application to another execution of the same application.（但是不同的执行中，一个对象的哈希值可能不同）</li>
<li>If two objects are equal according to the <code>equals(Object)</code> method, then calling the <code>hashCode</code> method on each of the two objects must produce the same integer result.（通过equals方法判断相等两个对象，它们的哈希值相同）</li>
<li>It is <em>not</em> required that if two objects are unequal according to the <code>equals(java.lang.Object)</code> method, then calling the <code>hashCode</code> method on each of the two objects must produce distinct integer results. （如果equals方法判断不等的两个对象，它们的hash值可能仍然相同）However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.（每个对象有不同的hash值可以提高程序的性能）</li>
</ul>
<p>As much as is reasonably practical, the hashCode method defined by class <code>Object</code> does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java™ programming language.)</p>
</blockquote>
<ul>
<li>
<p><code>int hasCode()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;<span class="comment">//调用了底层C++的方法</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>hasCode()</code>的作用</p>
<ul>
<li>一个Java对象的内存地址，经过哈希算法得到的一个整数值</li>
<li><strong>等价于返回一个Java对象的内存地址</strong></li>
<li></li>
</ul>
</li>
</ul>
<h2 id="boolean-equalsobject-obj"><a class="markdownIt-Anchor" href="#boolean-equalsobject-obj"></a> <code>boolean equals(Object obj)</code></h2>
<blockquote>
<p>Indicates whether some other object is &quot;equal to&quot; this one.</p>
<p>The <code>equals</code> method implements an equivalence relation on non-null object references:</p>
<ul>
<li>It is <em>reflexive</em>（子反性）: for any non-null reference value <code>x</code>, <code>x.equals(x)</code> should return <code>true</code>.</li>
<li>It is <em>symmetric</em>（对称性）: for any non-null reference values <code>x</code> and <code>y</code>, <code>x.equals(y)</code> should return <code>true</code> if and only if <code>y.equals(x)</code>returns <code>true</code>.</li>
<li>It is <em>transitive</em>（传递性）: for any non-null reference values <code>x</code>, <code>y</code>, and <code>z</code>, if <code>x.equals(y)</code> returns <code>true</code> and <code>y.equals(z)</code> returns <code>true</code>, then <code>x.equals(z)</code> should return <code>true</code>.</li>
<li>It is <em>consistent</em>（不变性）: for any non-null reference values <code>x</code> and <code>y</code>, multiple invocations of <code>x.equals(y)</code> consistently return <code>true</code> or consistently return <code>false</code>, provided no information used in <code>equals</code> comparisons on the objects is modified.</li>
<li>For any non-null reference v、ue <code>x</code>, <code>x.equals(null)</code> should return <code>false</code>.</li>
</ul>
<p>The <code>equals</code> method for class <code>Object</code> implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values <code>x</code> and <code>y</code>, this method returns <code>true</code> if and only if <code>x</code> and <code>y</code> refer to the same object (<code>x == y</code> has the value <code>true</code>).</p>
<p>Note that it is generally necessary to override the <code>hashCode</code> method whenever this method is overridden, so as to maintain the general contract for the <code>hashCode</code> method, which states that equal objects must have equal hash codes.</p>
<ul>
<li>
<p><strong>Parameters:</strong></p>
<p><code>obj</code> - the reference object with which to compare.</p>
</li>
<li>
<p><strong>Returns:</strong></p>
<p><code>true</code> if this object is the same as the obj argument; <code>false</code> otherwise.</p>
</li>
</ul>
</blockquote>
<ul>
<li>
<p><code>equals(Object obj)</code>的默认实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>equals(Object obj)</code>的作用</p>
<ul>
<li>判断两个对象（<code>this</code>和<code>obj</code>）是否相等</li>
<li><strong>两个基本数据类型数据相等的判断用</strong><code>==</code></li>
<li><strong>两个引用数据类型数据相等的判断用</strong><code>equals()</code>
<ul>
<li><code>==</code>只能判断两个引用指向的地址是否相同</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> ID)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ID = ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;a == b &quot;</span> + (a==b));</span><br><span class="line">        System.out.println(<span class="string">&quot;stu1 == stu2 &quot;</span> + (stu1==stu2));</span><br><span class="line">        System.out.println(<span class="string">&quot;没有重写的equals：stu1.equals(stu2) &quot;</span> + stu1.equals(stu2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ibz3y6zwj30vq0g875h.jpg" alt="" /></p>
</li>
<li>
<p><code>equals(Object obj)</code>的重写</p>
<ul>
<li>默认的<code>equals(Object obj)</code>实现还是在用<code>==</code>来判断两个引用数据类型是否相等</li>
<li>我们需要对其进行重写来满足自己的需求
<ul>
<li><strong>比较的不再是地址，而是两个引用指向的内容</strong></li>
<li>可以自定义相等的标准</li>
<li>重写<code>equals(Object obj)</code>的技巧
<ul>
<li>先判断<code>obj</code>是否为空指针，因为调用<code>equals(Object obj)</code>方法的<code>this</code>不可能是空（否则发生空指针异常）</li>
<li>再通过<code>instanceof</code>判断<code>obj</code>是否可以向下强制类型转换</li>
<li>这样做的好处是可以省略很多多余的判断</li>
</ul>
</li>
</ul>
</li>
<li>需要对每一个类都要重写<code>equals</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> ID)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ID = ID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//方法重写时，形参列表要完全一样</span></span><br><span class="line">    <span class="comment">//不可以写equals(Student stu)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="comment">//提前判断，避免多余的操作</span></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span> ||!(obj <span class="keyword">instanceof</span> Student))<span class="comment">//向下强制类型转换时需要判断类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//obj中没有ID的属性</span></span><br><span class="line">        <span class="comment">//向下强制类型转化</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line">        <span class="keyword">return</span> stu.ID == <span class="built_in">this</span>.ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ic8cdsumj30vs0g4wfs.jpg" alt="" /></p>
</li>
</ul>
<h2 id="string-tostring"><a class="markdownIt-Anchor" href="#string-tostring"></a> <code>String toString()</code></h2>
<blockquote>
<p>Returns a string representation of the object（返回一个对象的字符串表示形式）. In general, the <code>toString</code> method returns a string that &quot;textually represents&quot; （以文本的形式）this object. The result should be a concise but informative representation（简洁但是详实的信息） that is easy for a person to read. It is recommended that all subclasses override this method（建议所有子类都去重写该方法）.</p>
<p>The <code>toString</code> method for class <code>Object</code> returns a string consisting of the name of the class of which the object is an instance, the at-sign character ``@`', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getClass().getName() + <span class="string">&#x27;@&#x27;</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>Returns:</strong></p>
<p>a string representation of the object.</p>
</blockquote>
<ul>
<li>
<p><code>toString()</code>的返回值是</p>
<ul>
<li>“<u>类名</u>@对象内存地址的十六进制形式”</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认继承了Object</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTime</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mon;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> day;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTime</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> mon, <span class="type">int</span> day)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.year = year;</span><br><span class="line">        <span class="built_in">this</span>.mon = mon;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyTime time= <span class="keyword">new</span> <span class="title class_">MyTime</span>(<span class="number">2022</span>,<span class="number">11</span>,<span class="number">26</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> time.toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8iailk1arj30vq0ds0tr.jpg" alt="" /></p>
</li>
<li>
<p><code>toString()</code>的作用</p>
<ul>
<li><strong>将一个Java对象转化成字符串表示形式</strong></li>
<li>这个字符串必须能简洁而且详实的说明该对象的信息</li>
</ul>
</li>
<li>
<p><code>toString()</code><strong>重写</strong></p>
<ul>
<li>因为默认方法不能做到简洁详实的说明自己编写的类的信息</li>
<li>因此我们最好在自己编写的每一个类中重写该方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.year + <span class="string">&quot;年&quot;</span> + <span class="built_in">this</span>.mon + <span class="string">&quot;月&quot;</span> + <span class="built_in">this</span>.day + <span class="string">&quot;日&quot;</span>;<span class="comment">//简洁详实的输出对象信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8iaz66be7j30vi0euaaw.jpg" alt="" /></p>
</li>
</ul>
<h2 id="protected-void-finalized"><a class="markdownIt-Anchor" href="#protected-void-finalized"></a> <code>protected void finalized()</code></h2>
<blockquote>
<p>Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the <code>finalize</code> method to dispose of system resources or to perform other cleanup.</p>
<p>The <code>finalize</code> method of class <code>Object</code> performs no special action; it simply returns normally. Subclasses of <code>Object</code> may override this definition.</p>
</blockquote>
<ul>
<li>
<p><code>finalized()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalized</span><span class="params">()</span> <span class="keyword">throws</span> Throwable&#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由<code>protected</code>修饰，只有一对大括号，方法体中没有代码</li>
<li>该方法不需要手动调用，JVM的垃圾回收器GC自动调用该方法
<ul>
<li><strong>当一个对象即将被垃圾回收器回收时，垃圾回收器负责调用该方法</strong></li>
</ul>
</li>
<li>该方法提供一个**<u>时机</u>**，即垃圾销毁时机
<ul>
<li>如果希望在对象销毁时执行一些操作的话，可以将这些操作放到<code>finalized()</code>的方法体中</li>
<li>类似<u>静态代码块</u>，提供类加载时机，可以在类加载时进行一些操作</li>
</ul>
</li>
<li><strong>该方法不需要手动调用，如果有特殊要求，我们只用重写该方法即可</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="comment">//重写之后需要调用</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;一个名叫&quot;</span> + name + <span class="string">&quot;的宠物&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="comment">//只用重写，不用调用</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.toString() + <span class="string">&quot;即将被销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">//垃圾回收器不是每次都能启动，需要一定的数量、在一定的时间下才会启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">999999</span>; i ++)&#123;</span><br><span class="line">            <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">            pet = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8iq1kt7hfj30ek0k2gmx.jpg" alt="" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    pet = <span class="literal">null</span>;</span><br><span class="line">    System.gc();<span class="comment">//建议JVM启动垃圾回收器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  	System.out.println(<span class="built_in">this</span> + <span class="string">&quot;即将被销毁&quot;</span>);<span class="comment">//输出每个引用的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8iq9fnh8cj30ee0isdhe.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2022/11/28/Java/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h1>
<h2 id="内部类-2"><a class="markdownIt-Anchor" href="#内部类-2"></a> 内部类</h2>
<ul>
<li>
<p>在类的内部又定义类一个新的类，称为内部类</p>
</li>
<li>
<p>编译后生成<code>$Inner.class文</code>件</p>
</li>
<li>
<p>内部类的分类</p>
<ol>
<li>静态内部类：由<code>static</code>修饰</li>
<li>实例内部类：没有<code>static</code>修饰，需要先创建一个外部类的对象才能访问</li>
<li>局部内部类：在方法体中定义的类，只能在该方法体中访问</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">//在类里面定义的类</span></span><br><span class="line">  	<span class="comment">//编译后生成$Inner文件</span></span><br><span class="line">    <span class="comment">//由关键字static修饰，称为静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner1</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//没有static修饰，称为实例内部类</span></span><br><span class="line">    <span class="comment">//new Test1().new Inner2()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner2</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//在方法体中，称为局部内部类</span></span><br><span class="line">        <span class="comment">//只能在该方法中访问</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner3</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8kkk9cly1j30dk0fq3yw.jpg" alt="" /></p>
</li>
<li>
<p>使用内部类编写的代码可读性很差</p>
</li>
</ul>
<h2 id="匿名类"><a class="markdownIt-Anchor" href="#匿名类"></a> 匿名类</h2>
<ul>
<li>
<p>局部内部类的一种，由于这个类没有名字而得名</p>
</li>
<li>
<p><strong>接口作为方法的形参时</strong></p>
<ul>
<li>不采用匿名类技术</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyMath</span> <span class="variable">math</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyMath</span>();</span><br><span class="line">        <span class="comment">//无法直接创建一个Compute的实例当作实参传入myMath()</span></span><br><span class="line">        <span class="comment">//接口无法实例化对象</span></span><br><span class="line">        <span class="comment">//math.myMath(new Compute(),10,20);</span></span><br><span class="line">        <span class="comment">//我们需要编写一个类来实现接口</span></span><br><span class="line">        <span class="comment">//将这个类实例化一个对象当作实参传入方法的形参列表</span></span><br><span class="line">        math.myMath(<span class="keyword">new</span> <span class="title class_">ComputeImp</span>(),<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Compute</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputeImp</span> <span class="keyword">implements</span> <span class="title class_">Compute</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMath</span>&#123;</span><br><span class="line">    <span class="comment">//传入的参数是一个接口</span></span><br><span class="line">    <span class="comment">//将接口看成一个引用数据类型即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMath</span><span class="params">(Compute c, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="comment">//Compute c = new ComputeImp()</span></span><br><span class="line">        <span class="comment">//父类型引用指向子类型对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> c.sum(a,b);</span><br><span class="line">        System.out.println(a + <span class="string">&quot; + &quot;</span> + b + <span class="string">&quot; = &quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>采用匿名类技术</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyMath</span> <span class="variable">math</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyMath</span>();</span><br><span class="line">        <span class="comment">//匿名类，即ComputeImp这个类没有名字</span></span><br><span class="line">        <span class="comment">//不需要单独写一个类去实现接口</span></span><br><span class="line">        <span class="comment">//在形式上似乎可以直接new一个接口</span></span><br><span class="line">        <span class="comment">//但其实在后面的&#123;&#125;中是对接口的实现</span></span><br><span class="line">        math.myMath(<span class="keyword">new</span> <span class="title class_">Compute</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>匿名类由于没有名字，<strong>无法重复使用</strong></p>
</li>
<li>
<p>代码太乱，<strong>可读性太差</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>String类</title>
    <url>/2022/12/03/Java/String%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="string类"><a class="markdownIt-Anchor" href="#string类"></a> String类</h1>
<h2 id="string的存储原理"><a class="markdownIt-Anchor" href="#string的存储原理"></a> String的存储原理</h2>
<blockquote>
<p>The <code>String</code> class represents character strings. All string literals in Java programs, such as <code>&quot;abc&quot;</code>, are implemented as instances of this class.</p>
<p>Strings are constant; their values cannot be changed after they are created（String是常量，创建之后无法修改）. String buffers support mutable strings. Because String objects are immutable they can be shared.</p>
</blockquote>
<ul>
<li>
<p><code>String</code>表示字符串类型，属于引用数据类型</p>
<ul>
<li>在Java中所有用双引号修饰的都是<code>String</code>对象</li>
</ul>
</li>
<li>
<p>在Java中，字符串对象在创建后是不可以改变的</p>
<ul>
<li><code>String str = &quot;abc&quot;</code>，则在程序中<code>str</code>不会变成&quot;def&quot;，也不会变成&quot;ab&quot;等</li>
</ul>
</li>
<li>
<p>所有的字符串直接存储在<u>方法区内存</u>的<strong>字符串常量池</strong>中</p>
<ul>
<li>字符串的使用非常频繁，为了提高执行效率，所以把字符串放到字符串常量池中</li>
<li><u>字符串常量池不会被垃圾回收器回收</u></li>
<li>方法区内存中还存储了字节码文件、代码片段、静态变量等等信息</li>
<li>常量池也意味着字符串在创建后无法再修改</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下两行代码在字符串常量池中一共创建了三个对象</span></span><br><span class="line"><span class="comment">//其中&quot;abc&quot;和“”abcdef&quot;有引用指向，&quot;def&quot;没有引用指向</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span> + <span class="string">&quot;def&quot;</span>；</span><br></pre></td></tr></table></figure>
<ul>
<li>特殊情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>new</code>方法创建的对象一定都在堆内存中，但是字符串都在方法区内存中</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8phld6700j31ol0tkdj9.jpg" alt="" /></p>
<ul>
<li>字符串&quot;abc&quot;仍然存储在方法区的字符串常量池中，通过<code>new</code>方式在堆内存中创建了一个String对象，但是这个对象不存储字符串信息，<u>而是存储着&quot;abc&quot;在方法区内存的地址</u>，而栈内存中的<code>str</code>引用存储着堆内存中String对象的地址</li>
<li>更进一步的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//str1和str2都指向方法区内存中的同一块地址</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//s1和s2分别在堆内存中创建了两个不同的对象，两个不同的对象地址当然不同</span></span><br><span class="line"><span class="comment">//但是这两个对象中存储的方法区地址都是相同的</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="equalsobject-anobject方法"><a class="markdownIt-Anchor" href="#equalsobject-anobject方法"></a> <code>equals(Object anObject)</code>方法</h3>
<ul>
<li>String类重写了<code>equals()</code>方法</li>
</ul>
<blockquote>
<p>Compares this string to the specified object. The result is true if and only if the argument is not null and is a String object that represents the same sequence of characters as this object（只有当两个字符串都包含相同的字符次序时才会返回真）.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">aString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">    <span class="keyword">if</span> (!COMPACT_STRINGS || <span class="built_in">this</span>.coder == aString.coder) &#123;</span><br><span class="line">      <span class="keyword">return</span> StringLatin1.equals(value, aString.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//s1和s2代表的字符序列都相同</span></span><br><span class="line"><span class="comment">//此时比较的就不是s1和s2存储的地址，而是字符串s1和s2存储的内容</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">//true </span></span><br></pre></td></tr></table></figure>
<h2 id="string的构造方法"><a class="markdownIt-Anchor" href="#string的构造方法"></a> String的构造方法</h2>
<h3 id="stringbyte-bytes"><a class="markdownIt-Anchor" href="#stringbyte-bytes"></a> String(byte[] bytes)</h3>
<blockquote>
<p>Constructs a new <code>String</code> by decoding（解码） the specified array of bytes using the platform's default charset. The length of the new <code>String</code> is a function of the charset, and hence may not be equal to the length of the byte array.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;<span class="comment">//&#x27;a&#x27; = 97</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line">System.out.println(str);<span class="comment">//abc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>输出一个引用时会自动调用其toString()方法，默认输出对象的内存地址，String类已经重写了该方法</li>
</ul>
<h3 id="tostring"><a class="markdownIt-Anchor" href="#tostring"></a> toString()</h3>
<blockquote>
<p>This object (which is already a string!) is itself returned.（返回字符串自己）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stringbyte-bytes-int-offset-int-length"><a class="markdownIt-Anchor" href="#stringbyte-bytes-int-offset-int-length"></a> String(byte[] bytes, int offset, int length)</h3>
<blockquote>
<p>bytes - The bytes to be decoded into characters（待转换的字节数组）</p>
<p>offset - The index of the first byte to decode（待转换的起始位置）</p>
<p>length - The number of bytes to decode（待转换的长度）</p>
</blockquote>
<ul>
<li><code>bytes</code>数组很长，我们只希望转换其中一部分为<code>String</code>时调用该构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;<span class="comment">//&#x27;a&#x27; = 97</span></span><br><span class="line"><span class="comment">//从bytes数组中的下标为一个的位置开始，转换两个字符为String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(str);<span class="comment">//bc</span></span><br></pre></td></tr></table></figure>
<h3 id="stringchar-value"><a class="markdownIt-Anchor" href="#stringchar-value"></a> String(char[] value)</h3>
<ul>
<li>与<code>String(byte[] bytes)</code>类似</li>
</ul>
<h3 id="stringchar-value-int-offset-int-count"><a class="markdownIt-Anchor" href="#stringchar-value-int-offset-int-count"></a> String(char[] value, int offset, int count)</h3>
<ul>
<li>与<code>String(byte[] bytes, int offset, int length)</code>类似</li>
</ul>
<h3 id="stringstring-original"><a class="markdownIt-Anchor" href="#stringstring-original"></a> String(String original)</h3>
<ul>
<li>通过已有的String来构造新的String</li>
<li><code>String str = new String(&quot;abc&quot;);</code></li>
</ul>
<h2 id="string中的常用方法"><a class="markdownIt-Anchor" href="#string中的常用方法"></a> String中的常用方法</h2>
<h3 id="charatint-index"><a class="markdownIt-Anchor" href="#charatint-index"></a> <code>charAt(int index)</code></h3>
<blockquote>
<p>Returns the char value at the specified index（返回字符串中某个下标的字符值）. An index ranges from 0 to length() - 1. The first char value of the sequence is at index 0, the next at index 1, and so on, as for array indexing.<br />
If the char value specified by the index is a surrogate, the surrogate value is returned.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isLatin1()) &#123;</span><br><span class="line">    <span class="keyword">return</span> StringLatin1.charAt(value, index);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> StringUTF16.charAt(value, index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>.charAt(<span class="number">2</span>);</span><br><span class="line">System.out.println(c);<span class="comment">//c</span></span><br></pre></td></tr></table></figure>
<h3 id="comparetostring-anotherstring"><a class="markdownIt-Anchor" href="#comparetostring-anotherstring"></a> <code>compareTo(String anotherString)</code></h3>
<blockquote>
<p>Compares two strings lexicographically（按字典顺序比较两个字符串）. The comparison is based on the Unicode value of each character in the strings. The character sequence represented by this String object is compared lexicographically to the character sequence represented by the argument string. The result is a negative integer if this String object lexicographically precedes the argument string（str小于anotherString时返回负数）. The result is a positive integer if this String object lexicographically follows the argument string（str大于anotherString时返回正数）. The result is zero if the strings are equal; compareTo returns 0 exactly when the equals(Object) method would return true.（当两个字符串相等时返回0）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span> &#123;</span><br><span class="line">  <span class="type">byte</span> v1[] = value;</span><br><span class="line">  <span class="type">byte</span> v2[] = anotherString.value;</span><br><span class="line">  <span class="type">byte</span> <span class="variable">coder</span> <span class="operator">=</span> coder();</span><br><span class="line">  <span class="keyword">if</span> (coder == anotherString.coder()) &#123;</span><br><span class="line">    <span class="keyword">return</span> coder == LATIN1 ? StringLatin1.compareTo(v1, v2)</span><br><span class="line">      : StringUTF16.compareTo(v1, v2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> coder == LATIN1 ? StringLatin1.compareToUTF16(v1, v2)</span><br><span class="line">    : StringUTF16.compareToLatin1(v1, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>str1.compareTo(str2)</code>
<ul>
<li><u>等价于<code>str1 - str2</code></u></li>
<li>当<code>str1</code>大于<code>str2</code>时返回正数</li>
<li>...小于...返回负数</li>
<li>...等于...返回0</li>
</ul>
</li>
</ul>
<h3 id="indexofstring-str"><a class="markdownIt-Anchor" href="#indexofstring-str"></a> <code>IndexOf(String str)</code></h3>
<blockquote>
<p>Returns the index within this string of the first occurrence of the specified substring, starting at the specified index.（返回字符串中某一子串第一次出现的下标）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(<span class="string">&quot;def&quot;</span>);<span class="comment">//index = 3</span></span><br></pre></td></tr></table></figure>
<h3 id="public-int-lastindexofstring-str"><a class="markdownIt-Anchor" href="#public-int-lastindexofstring-str"></a> <code>public int lastIndexOf(String str)</code></h3>
<blockquote>
<p>Returns the index within this string of the last occurrence of the specified character.（返回字符串中某一子串最后一次出现的下标</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcabc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> str.lastIndexOf(str);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<h3 id="public-boolean-containscharsequence-s"><a class="markdownIt-Anchor" href="#public-boolean-containscharsequence-s"></a> <code>public boolean contains(CharSequence s)</code></h3>
<blockquote>
<p>Returns true if and only if this string contains the specified sequence of char values.（当字符串包含某一部分字符串时返回真）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(CharSequence s)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> indexOf(s.toString()) &gt;= <span class="number">0</span>;<span class="comment">//即子串s在字符串中出现过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串<code>str</code>包含字符串<code>s</code>等价于<code>s</code>出现在<code>str</code>中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> str.contains(<span class="string">&quot;bcd&quot;</span>);<span class="comment">//flag = true;</span></span><br></pre></td></tr></table></figure>
<h3 id="public-boolean-endswithstring-suffix"><a class="markdownIt-Anchor" href="#public-boolean-endswithstring-suffix"></a> <code>public boolean endsWith(String suffix)</code></h3>
<blockquote>
<p>Tests if this string ends with the specified suffix.（判断某个字符串是否以某一个子串结尾）</p>
</blockquote>
<ul>
<li>类似的也有<code>startWith(String prefix)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;MyJava.java&quot;</span>.endWith(<span class="string">&quot;.txt&quot;</span>);<span class="comment">//false</span></span><br><span class="line"><span class="string">&quot;MyJava.java&quot;</span>.endWith(<span class="string">&quot;.java&quot;</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="public-boolean-equalsignorecasestring-anotherstring"><a class="markdownIt-Anchor" href="#public-boolean-equalsignorecasestring-anotherstring"></a> <code>public boolean equalsIgnoreCase(String anotherString)</code></h3>
<blockquote>
<p>Compares this String to another String, ignoring case considerations. （在忽略大小的区别下，比较两个字符串）Two strings are considered equal ignoring case if they are of the same length and corresponding characters in the two strings are equal ignoring case.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Abc&quot;</span>.equalsIgnoreCase(<span class="string">&quot;Abc&quot;</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="public-boolean-isempty"><a class="markdownIt-Anchor" href="#public-boolean-isempty"></a> <code>public boolean isEmpty()</code></h3>
<blockquote>
<p>Returns true if, and only if, length() is 0.（判断某个字符串长度是否为0）</p>
</blockquote>
<ul>
<li>当一个字符串长度为0时，返回true
<ul>
<li>判断数组长度时，是调用<code>length</code>属性</li>
<li>判断字符串长度时，是调用<code>length()</code>方法</li>
</ul>
</li>
<li><strong><u>长度为0并不等价于该字符串为<code>null</code></u></strong>
<ul>
<li>空引用调用方法时会出现空指针异常的错误</li>
</ul>
</li>
</ul>
<h3 id="public-string-replacecharsequence-target-charsequence-replacement"><a class="markdownIt-Anchor" href="#public-string-replacecharsequence-target-charsequence-replacement"></a> <code>public String replace(CharSequence target, CharSequence replacement)</code></h3>
<blockquote>
<p>Replaces <u>each substring</u> of this string that matches the literal target sequence with the specified literal replacement sequence.（将字符串中每一个target子串，用replacement串替换） The replacement proceeds from the beginning of the string to the end, for example, replacing &quot;aa&quot; with &quot;b&quot; in the string &quot;aaa&quot; will result in &quot;ba&quot; rather than &quot;ab&quot;.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcdefabc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> str.replace(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;一二三&#x27;</span>);<span class="comment">//一二三def一二三</span></span><br></pre></td></tr></table></figure>
<h3 id="public-string-splitstring-regex"><a class="markdownIt-Anchor" href="#public-string-splitstring-regex"></a> <code>public String[] split(String regex)</code></h3>
<blockquote>
<p>Splits this string around matches of the given regular expression（用给定的正则表达式拆分原字符串）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2022-12-03&quot;</span>;</span><br><span class="line">String[] split = str.split(<span class="string">&quot;-&quot;</span>);<span class="comment">//&#123;&quot;2022&quot;,&quot;12&quot;,&quot;03&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="public-string-substringint-beginindex-int-endindex"><a class="markdownIt-Anchor" href="#public-string-substringint-beginindex-int-endindex"></a> <code>public String substring(int beginIndex, int endIndex)</code></h3>
<blockquote>
<p>Returns a string that is a substring of this string. The substring begins at the specified beginIndex and extends to the character at index endIndex - 1. （从字符串中截取从beginIndex到endIndex-1之间的子串）（左闭右开）Thus the length of the substring is endIndex-beginIndex.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;hamburger&quot;</span>.substring(<span class="number">4</span>, <span class="number">8</span>)<span class="comment">//&quot;urge&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="public-char-tochararray"><a class="markdownIt-Anchor" href="#public-char-tochararray"></a> <code>public char[] toCharArray()</code></h3>
<blockquote>
<p>Converts this string to a new character array.（将字符串转换为字符数组）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] chars = <span class="string">&quot;abcdef&quot;</span>.toCharArray();</span><br></pre></td></tr></table></figure>
<h3 id="public-string-tolowercase"><a class="markdownIt-Anchor" href="#public-string-tolowercase"></a> <code>public String toLowerCase()</code></h3>
<blockquote>
<p>Converts all of the characters in this String to lower case using the rules of the default locale. （将字符串中所有的字母都转化为小写）</p>
</blockquote>
<h3 id="public-string-touppercase"><a class="markdownIt-Anchor" href="#public-string-touppercase"></a> <code>public String toUpperCase()</code></h3>
<blockquote>
<p>Converts all of the characters in this String to upper case using the rules of the default locale. （将字符串中所有的字母都转化为大写）</p>
</blockquote>
<h3 id="public-string-trim"><a class="markdownIt-Anchor" href="#public-string-trim"></a> <code>public String trim()</code></h3>
<blockquote>
<p>Returns a string whose value is this string, with all leading and trailing space removed, where space is defined as any character whose codepoint is less than or equal to 'U+0020' (the space character).（去掉字符串中前面以及后面的空格，中间的空格不会去掉）</p>
</blockquote>
<h3 id="public-static-string-valueofobject-obj"><a class="markdownIt-Anchor" href="#public-static-string-valueofobject-obj"></a> <code>public static String valueOf(Object obj)</code></h3>
<blockquote>
<p>Returns the string representation of the Object argument.（将Object obj用字符串的形式表示）（<u>少有的静态方法</u>）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (obj == <span class="literal">null</span>) ? <span class="string">&quot;null&quot;</span> : obj.toString();<span class="comment">//在底层调用的是toString()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>valueOf</code>在底层调用的是<code>toString()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(<span class="literal">true</span>);<span class="comment">//str=&quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(<span class="keyword">new</span> <span class="title class_">User</span>());<span class="comment">//调用User的toString()</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>println</code>方法在底层调用的是<code>valueOf</code></li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(x);</span><br><span class="line">	<span class="keyword">if</span> (getClass() == PrintStream.class) &#123;</span><br><span class="line">		<span class="comment">// need to apply String.valueOf again since first invocation</span></span><br><span class="line">		<span class="comment">// might return null</span></span><br><span class="line">		writeln(String.valueOf(s));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">		print(s);</span><br><span class="line">		newLine();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>所有能在控制台上显示的内容都是<strong>字符串</strong></p>
<ul>
<li>将数据通过<code>valueOf</code>转换成字符串</li>
</ul>
</li>
</ul>
<h2 id="stringbuffer"><a class="markdownIt-Anchor" href="#stringbuffer"></a> StringBuffer</h2>
<h3 id="stringbuffer的原理"><a class="markdownIt-Anchor" href="#stringbuffer的原理"></a> StringBuffer的原理</h3>
<ul>
<li>由于字符串是不可变的，每一次拼接都会产生一个新的字符串，<u>这样会占用大量的方法区内存，造成空间的浪费</u></li>
</ul>
<h4 id="stringbuffer的存储原理"><a class="markdownIt-Anchor" href="#stringbuffer的存储原理"></a> <strong>StringBuffer的存储原理</strong></h4>
<ul>
<li><code>public StringBuffer()</code></li>
</ul>
<blockquote>
<p>Constructs a string buffer with no characters in it and an initial capacity of 16 characters.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">  <span class="keyword">if</span> (COMPACT_STRINGS) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="title class_">byte</span>[capacity];</span><br><span class="line">    coder = LATIN1;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    value = StringUTF16.newBytesFor(capacity);</span><br><span class="line">    coder = UTF16;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>StringBuffer的底层是一个byte数组</strong></li>
<li>初始化容量是16</li>
</ul>
<h4 id="stringbuffer的扩容"><a class="markdownIt-Anchor" href="#stringbuffer的扩容"></a> <strong>StringBuffer的扩容</strong></h4>
<ul>
<li><code>public synchronized StringBuffer append(CharSequence s)</code></li>
</ul>
<blockquote>
<p>Appends the specified CharSequence to this sequence.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(CharSequence s)</span> &#123;</span><br><span class="line">  toStringCache = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">super</span>.append(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">  	<span class="keyword">return</span> appendNull();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">  ensureCapacityInternal(count + len);</span><br><span class="line">  putStringAt(count, str);</span><br><span class="line">  count += len;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> value.length &gt;&gt; coder;</span><br><span class="line">  <span class="keyword">if</span> (minimumCapacity - oldCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    value = Arrays.copyOf(value,</span><br><span class="line">                          newCapacity(minimumCapacity) &lt;&lt; coder);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>通过append方法追加追加追加内容时，如果byte数组满了，就通过<strong>数组拷贝</strong>的方式进行自动扩容</p>
</li>
<li>
<p><u>String类型的底层存储也是通过byte数组，但是该数组由<code>final</code>修饰，无法修改！</u></p>
<ul>
<li>准确来说一个引用只能指向一块空间，如果扩容了一个新的空间，原来的引用无法指向它</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8qrnrllyuj30mt0a00tr.jpg" alt="" /></p>
</li>
<li>
<p>提高StringBuffer的性能：在创建时就给定一个初始化容量，最好减少底层数组的扩容次数</p>
</li>
</ul>
<h4 id="stringbuffer和stringbuilder的区别"><a class="markdownIt-Anchor" href="#stringbuffer和stringbuilder的区别"></a> StringBuffer和StringBuilder的区别</h4>
<ul>
<li>StringBuffer中的方法都有<code>synchronized</code>关键字修饰，表示StringBuffer在多线程环境下运行是安全的</li>
<li>StringBuilder中的方法没有被<code>synchronized</code>修饰，表示在多线程运行情况下是不安全的</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2022/12/15/Java/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h1>
<h2 id="异常的概念"><a class="markdownIt-Anchor" href="#异常的概念"></a> 异常的概念</h2>
<ul>
<li>
<p>程序执行过程中发生了不正常的情况，这种情况被称为异常</p>
</li>
<li>
<p>Java可以对异常进行处理</p>
<ul>
<li>将异常信息输出到控制台上，供程序员参考</li>
<li>提高程序的<u>健壮性</u></li>
</ul>
</li>
<li>
<p>JVM可以在控制台上输出异常信息</p>
</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h94fm1yr1xj30rj06umxy.jpg" alt="" /></p>
<h2 id="异常以类的形式存在"><a class="markdownIt-Anchor" href="#异常以类的形式存在"></a> 异常以类的形式存在</h2>
<ul>
<li>异常在Java中以<strong>类</strong>的形式存在</li>
<li>每一个异常类都可以创建异常对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过异常类来实例化异常对象</span></span><br><span class="line"><span class="type">ArrayIndexOutOfBoundsException</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;数组下标越界异常&quot;</span>);</span><br><span class="line">        System.out.println(exception);</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h94fvgtd5gj30nu06mjrw.jpg" alt="" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b - <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;<span class="comment">//程序运行到此处时，JVM会实例化一个ArithmeticException异常类的对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每发生一次异常，都会创建一个该异常类的对象
<ul>
<li>面向对象编程的思想：</li>
<li><u>发生即对象！存在即类！</u></li>
</ul>
</li>
</ul>
<h2 id="异常的继承结构"><a class="markdownIt-Anchor" href="#异常的继承结构"></a> 异常的继承结构</h2>
<h3 id="uml"><a class="markdownIt-Anchor" href="#uml"></a> <a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80">UML</a></h3>
<ul>
<li><em>Unified Modeling Language</em>同一建模语言</li>
<li>一种图标式语言，是一种开放的方法，用于说明、可视化、构建和编写一个<u>面向对象的</u>、软件密集系统的制品的开放方法</li>
<li>软件设计人员使用UML</li>
</ul>
<h3 id="异常的继承结构-2"><a class="markdownIt-Anchor" href="#异常的继承结构-2"></a> 异常的继承结构</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h94ha3tex2j30xr0geab9.jpg" alt="" /></p>
<ul>
<li>所有的异常类是从<code>java.lang.Exception</code>类继承的子类。</li>
<li><code>Exception</code>类是<code>Throwable</code>类的子类。除了<code>Exception</code>类外，<code>Throwable</code>还有一个子类<code>Error</code>
<ul>
<li>意味着无论是异常还是错误都是可以抛出的</li>
<li>所有的错误只要发生，Java都会终止程序的执行，退出JVM</li>
<li><strong>错误是不能处理的</strong></li>
</ul>
</li>
<li><code>Exception</code>类又分为两大类
<ul>
<li>编译时异常（受控异常）
<ul>
<li><code>Exception</code>的直接子类</li>
<li>编译时的异常不是在编译阶段发生的，而是说必须在编写程序时<u>预先对这类异常进行处理</u>，如果不处理则无法进行编译！</li>
<li>也就是说运行程序前不可能存在编译异常</li>
<li>发生的概率更高
<ul>
<li>对于一些发生概率比较高的异常，我们需要在运行之前对其进行处理</li>
</ul>
</li>
</ul>
</li>
<li>运行时异常（非受控异常）
<ul>
<li><code>RuntimeException</code></li>
<li>运行时的异常在编写程序时可以处理也可以不处理</li>
<li>发生的概率更低
<ul>
<li>对于一些发生概率比较低的异常，我们不需要对其进行处理</li>
</ul>
</li>
</ul>
</li>
<li>如果不区分两种异常，即所有异常都需要在编写程序阶段进行预处理
<ul>
<li>程序是绝对安全的</li>
<li>程序过于复杂，需要处理各种异常</li>
</ul>
</li>
<li>所有的异常都是发生在运行阶段，编译阶段是不会发生异常的。因为编译异常必须在编译时进行处理，否则无法运行。
<ul>
<li>异常的出现必须实例化异常对象（<code>new</code>），只有在运行时才可以实例化对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="异常的处理"><a class="markdownIt-Anchor" href="#异常的处理"></a> 异常的处理</h2>
<h3 id="在方法声明的-位置上使用throws关键字"><a class="markdownIt-Anchor" href="#在方法声明的-位置上使用throws关键字"></a> 在方法声明的 位置上，使用<code>throws</code>关键字</h3>
<ul>
<li>
<p>异常上抛，交给调用者</p>
<ul>
<li>调用者需要对这个异常进行处理，它处理的方法也是这两种，要么上抛给调用它的上一级，要么自己处理</li>
<li>当上抛到<code>main</code>方法时，<code>main</code>方法继续上抛，上抛给JVM，则JVM只能终止程序的运行</li>
</ul>
</li>
<li>
<p>方法声明的异常必须属于<strong>编译时异常</strong></p>
</li>
<li>
<p>因为是编译时异常，所以在调用该方法时必须对这种异常<strong>进行预先处理</strong></p>
<ul>
<li>否则编译报错</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">//调用该方法时不对异常进行处理</span></span><br><span class="line">        doSome();</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//表示在调用doSome()方法时可能会出现ClassNotFoundException异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h94ihrj34dj30ra05ndgk.jpg" alt="" /></p>
<h4 id="用throws关键字对异常处理"><a class="markdownIt-Anchor" href="#用throws关键字对异常处理"></a> 用<code>throws</code>关键字对异常处理</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">  	<span class="comment">//继续向上抛异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        doSome();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h94inawicdj30fv0680sx.jpg" alt="" /></p>
<ul>
<li><code>throws</code>关键字后可以跟多个异常，多个异常之间通过逗号隔开</li>
<li>接受<code>throws</code>抛上来的异常的方法需要对异常进行处理，处理的方法也有两种，要么自己捕获，要么继续向上抛
<ul>
<li>如果继续向上抛，则抛出的异常必须是接受的异常的父类，或者就是该异常本身</li>
</ul>
</li>
<li><code>main</code>方法一般不再向上抛出异常
<ul>
<li>异常机制的初衷就是为了在发生异常的情况下不影响程序的运行，如果<code>main</code>方法继续上抛异常给JVM，则势必会导致程序的退出</li>
</ul>
</li>
<li>一个方法中如果将异常上报了，<u>则该方法运行结束，不会再运行后续的代码</u></li>
</ul>
<h4 id="throw关键字"><a class="markdownIt-Anchor" href="#throw关键字"></a> <code>throw</code>关键字</h4>
<ul>
<li>在方法体中抛出主动抛出异常</li>
<li>语法格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等价于抛出一个异常类的实例</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常名();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> NoSuchMethodException&#123;</span><br><span class="line">    <span class="comment">//主动抛出异常</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用trycatch语句和进行异常的捕捉"><a class="markdownIt-Anchor" href="#使用trycatch语句和进行异常的捕捉"></a> 使用<code>try...catch</code>语句和进行异常的捕捉</h3>
<ul>
<li>自己处理这个异常</li>
</ul>
<h4 id="语法格式"><a class="markdownIt-Anchor" href="#语法格式"></a> 语法格式</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">//尝试</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类 异常名)&#123;</span><br><span class="line">		<span class="comment">//捕捉到异常之后的分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>catch</code>捕捉到的异常必须是发生的或接受到的异常，或者是以上异常的父类</li>
<li><code>catch</code>后建议只精确的捕捉一个异常，针对某一个异常进行异常处理</li>
<li><code>catch</code>后跟多个异常时可以用<code>｜</code>来分隔开（JDK8）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">		doSome();</span><br><span class="line">&#125;<span class="keyword">catch</span>(NoSuchMethodException | ClassNotFoundException e)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;未找到该方法或者没找到该类&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个<code>try</code>后可以跟多个<code>catch</code>，处理多个异常
<ul>
<li>多个<code>catch</code>时会从上到下执行，那么必须遵守多个异常从小到大的原则，一个异常不能被多次捕获</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line">        m1();</span><br><span class="line">        System.out.println(<span class="string">&quot;main over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 bigin&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到相关方法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//m2方法调用了m3方法，因此m2方法需要处理m3向上抛出的异常</span></span><br><span class="line">    <span class="comment">//如果选择继续向上抛出异常，则抛出的异常必须和m3抛上来的异常一致，或者抛出的异常是m3异常的父类</span></span><br><span class="line">    <span class="comment">//抛出m3异常的父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> ReflectiveOperationException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 bigin&quot;</span>);</span><br><span class="line">        m3();</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//采用上抛的方式处理异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m3 bigin&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        m4(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;m3 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NoSuchMethodException属于编译时异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> NoSuchMethodException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m4 bigin&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;m4 doSome&quot;</span>);</span><br><span class="line">        <span class="comment">//主动抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodException</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;m4 over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常对象的常用方法"><a class="markdownIt-Anchor" href="#异常对象的常用方法"></a> 异常对象的常用方法</h2>
<h3 id="public-string-getmessage"><a class="markdownIt-Anchor" href="#public-string-getmessage"></a> <code>public String getMessage()</code></h3>
<blockquote>
<p>Returns the detail message string of this Throwable instance (which may be null).</p>
</blockquote>
<ul>
<li>获取异常简单的描述信息
<ul>
<li>这个信息其实就是构造方法中的字符串参数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassNotFoundException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;未找到这个个类&quot;</span>);</span><br><span class="line">System.out.println(e.getMessage());<span class="comment">//输出未找到这个个类</span></span><br></pre></td></tr></table></figure>
<h3 id="printstacktrace"><a class="markdownIt-Anchor" href="#printstacktrace"></a> <code>printStackTrace()</code></h3>
<blockquote>
<p>Prints this throwable and its backtrace to the standard error stream. This method prints a stack trace for this Throwable object on the error output stream that is the value of the field System</p>
</blockquote>
<ul>
<li>获取异常追踪的堆栈信息</li>
<li>Java后台打印异常堆栈追踪信息时，采用的了异步线程的方式打印
<ul>
<li>专门有一个线程用于打印这个信息</li>
</ul>
</li>
<li>建议在所有异常处理时都打印一下异常追踪的堆栈信息，辅助我们处理异常</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>异常2</title>
    <url>/2022/12/19/Java/%E5%BC%82%E5%B8%B82/</url>
    <content><![CDATA[<h2 id="finally关键字"><a class="markdownIt-Anchor" href="#finally关键字"></a> Finally关键字</h2>
<h2 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h2>
<ul>
<li>在<code>try....catch</code>中的<code>finally</code>子句
<ul>
<li><code>fianlly</code>子句的代码是最后执行的，并且一定会执行，即使<code>try</code>语句块中的代码出现了异常</li>
</ul>
</li>
<li>在<code>finally</code>代码块中，可以运行清理类型等收尾善后性质的语句</li>
<li><code>finally</code>代码块出现在<code>catch</code>代码块最后</li>
</ul>
<h2 id="语法格式"><a class="markdownIt-Anchor" href="#语法格式"></a> 语法格式</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//程序代码1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//程序代码2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">//程序代码3</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">//程序代码4</span></span><br><span class="line">  <span class="comment">//无论代码1有没有发生异常，代码4都会在最后执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2>
<h3 id="catch不能独立于try存在"><a class="markdownIt-Anchor" href="#catch不能独立于try存在"></a> <code>catch</code>不能独立于<code>try</code>存在。</h3>
<ul>
<li>在<code>try/catch</code>后面添加<code>finally</code>块并非强制性要求的。</li>
</ul>
<h3 id="try代码后不能既没catch块也没finally块"><a class="markdownIt-Anchor" href="#try代码后不能既没catch块也没finally块"></a> <code>try</code>代码后不能既没<code>catch</code>块也没<code>finally</code>块</h3>
<ul>
<li>意味着<code>try</code>之后可以只跟一个<code>finally</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;try...&quot;</span>);</span><br><span class="line">     	 	<span class="comment">//即使有了return语句，finally子句还是会执行</span></span><br><span class="line">      	<span class="comment">//执行顺序</span></span><br><span class="line">      	<span class="comment">//首先执行try </span></span><br><span class="line">      	<span class="comment">//然后执行finally</span></span><br><span class="line">      	<span class="comment">//最后执行return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;finally...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h98zhtxbeoj30ct072wen.jpg" alt="" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;try...&quot;</span>);</span><br><span class="line">      	<span class="comment">//直接退出JVM则不会执行之后的finally语句</span></span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;finally...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h98znp0zgfj30fv05uweo.jpg" alt="" /></p>
<h3 id="finally中的代码执行顺序"><a class="markdownIt-Anchor" href="#finally中的代码执行顺序"></a> finally中的代码执行顺序</h3>
<ul>
<li>总体上必须遵循
<ol>
<li>方法体中的代码自上而下一次执行</li>
<li><code>return</code>语句一旦执行，方法执行结束</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> doSome();</span><br><span class="line">    System.out.println(<span class="string">&quot;main...&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">doSome</span><span class="params">( )</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;try...&quot;</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        i ++;</span><br><span class="line">        System.out.println(<span class="string">&quot;finally...&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h99082wpknj30fs07xjrm.jpg" alt="" /></p>
<ul>
<li>从控制台的显示信息上
<ul>
<li>先执行<code>try</code>，然后执行<code>finally</code>，最后返回主函数</li>
</ul>
</li>
<li>但是主函数接受到的<code>i</code>似乎没有收到<code>finally</code>的影响
<ul>
<li>这一点是遵循第二条规则的，即<code>doSome()</code>方法自上而下执行，执行到<code>return</code>语句时退出，还不能考虑后面的<code>finally</code></li>
</ul>
</li>
<li>虽然逻辑上<code>finally</code>是紧接着<code>try</code>执行的，执行完<code>finally</code>后才返回<code>return</code>，但是最后的执行效果不能违法前面的两条规则</li>
<li>真实的处理过程是这样的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">//doSome()</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;	</span><br><span class="line">i++;				<span class="comment">//finally</span></span><br><span class="line"><span class="keyword">return</span> j;</span><br></pre></td></tr></table></figure>
<h3 id="trycatch可以嵌套使用"><a class="markdownIt-Anchor" href="#trycatch可以嵌套使用"></a> <code>try....catch</code>可以嵌套使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/.....&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            s.toString();<span class="comment">//空指针异常，进而跳转到异常处理程序</span></span><br><span class="line">          	<span class="comment">//如果没有finally子句，则以下程序不会被执行</span></span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          	<span class="comment">//使用finally子句，确保已经打开的文件流关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>)</span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="final-finally-finalize"><a class="markdownIt-Anchor" href="#final-finally-finalize"></a> <code>final</code>、<code>finally</code>、<code>finalize</code></h3>
<h4 id="final"><a class="markdownIt-Anchor" href="#final"></a> <code>final</code></h4>
<ul>
<li>关键字，可以修饰变量、方法、类等，表示最终的不可变的</li>
</ul>
<h4 id="finally"><a class="markdownIt-Anchor" href="#finally"></a> <code>finally</code></h4>
<ul>
<li>关键字，与<code>try</code>一起联合使用，使用在异常处理机制中，由<code>finally</code>修饰的语句一定是会执行的</li>
</ul>
<h4 id="finalize"><a class="markdownIt-Anchor" href="#finalize"></a> <code>finalize</code></h4>
<ul>
<li>是<code>Object</code>类中的一个方法，作为方法名出现，该方法由JVM的垃圾回收器GC自动调用</li>
<li>当一个对象即将被垃圾回收器回收时，垃圾回收器负责调用该方法</li>
</ul>
<h3 id="重写的方法抛出的异常只能更少不能更多"><a class="markdownIt-Anchor" href="#重写的方法抛出的异常只能更少不能更多"></a> 重写的方法抛出的异常只能更少不能更多</h3>
<ul>
<li>父类的方法没有抛出异常的话，子类的方法就不能抛出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123; &#125;<span class="comment">//编译报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类抛出的异常是父类异常的子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException&#123; &#125;<span class="comment">//编译通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类抛出的异常数少于父类的异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException, ClassNotFoundException&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException&#123; &#125;<span class="comment">//编译通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h2>
<ul>
<li>编写一个类继承<code>Exception</code>或者<code>RuntimeException</code></li>
<li>提供两个构造方法
<ul>
<li>一个带有<code>String</code>参数的</li>
<li>一个无参数的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>throw</code>的方法手动抛出异常</li>
<li>在上层方法中捕获这个异常进行处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不要在该方法中处理异常</span></span><br><span class="line"><span class="comment">//自己抛出，自己处理没有意义</span></span><br><span class="line"><span class="comment">//这个就是要向上层方法提示已经出现了异常，由上层方法来决定如何处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> MyException&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;抛出自定义异常&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常的练习题"><a class="markdownIt-Anchor" href="#异常的练习题"></a> 异常的练习题</h2>
<ul>
<li>模拟用户注册过程，当用户名不合法时弹出异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义异常类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    MyException()&#123;&#125;</span><br><span class="line">    MyException(String s)&#123;</span><br><span class="line">        <span class="built_in">super</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> MyException&#123;</span><br><span class="line">      	<span class="comment">//先判断引用是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == username || <span class="literal">null</span> == password)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;请输入用户名或者密码&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (username.length() &lt; <span class="number">6</span> || username.length() &gt; <span class="number">14</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;用户名必须在6-14之间&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;注册成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String username, password;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">        username = scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">        password = scanner.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            register(username,password);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (MyException e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类</title>
    <url>/2022/11/24/Java/%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h1>
<h2 id="抽象类的概念"><a class="markdownIt-Anchor" href="#抽象类的概念"></a> 抽象类的概念</h2>
<ul>
<li>
<p><u>类和类之间具有的共同特征，将这些共同特征提取出来，形成的就是抽象类</u></p>
</li>
<li>
<p><strong><u>抽象类无法实例化创建对象</u></strong></p>
<ul>
<li>类是对对象的抽象，而对象是真实具体的，因此类可以实例化为对象</li>
<li>抽象类是对类的抽象，类是思维上抽象的，因此抽象类无法实例化为对象</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8fauvv563j30mw0c075y.jpg" alt="" /></p>
</li>
<li>
<p>抽象类属于引用数据类型</p>
</li>
<li>
<p>抽象类的语法结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] <span class="keyword">abstract</span> class 类名&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>抽象类是用来被子类继承的</p>
<ul>
<li>
<p>抽象类无法实例化，无法创建对象</p>
</li>
<li>
<p>继承抽象类的子类也可以是一个抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> CreditAccount <span class="keyword">extends</span> <span class="title class_">BankAccount</span>&#123; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><u>抽象类无法被<code>final</code>关键字修饰</u></p>
</li>
</ul>
</li>
<li>
<p>抽象类同样拥有构造方法</p>
<ul>
<li>虽然抽象类无法实例化对象，但是抽象类仍然有构造方法</li>
<li>抽象类的构造方法是提供给子类是用的</li>
<li>子类构造方法第一行会默认有<code>super()</code></li>
</ul>
</li>
</ul>
<h2 id="抽象方法"><a class="markdownIt-Anchor" href="#抽象方法"></a> 抽象方法</h2>
<ul>
<li>
<p>没有实现的方法、没有方法体的方法称作抽象方法</p>
</li>
<li>
<p>抽象方法的语法结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] <span class="keyword">abstract</span> 返回值类型 方法名(形参列表);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>抽象方法没有方法体，以分号结尾</p>
<ul>
<li>甚至不能有大括号</li>
</ul>
</li>
<li>
<p>修饰符列表中一定包含<code>abstract</code>关键字</p>
</li>
<li>
<p><strong>抽象方法只能出现在抽象类中</strong></p>
<ul>
<li>但是抽象类中也可以存在非抽象的方法</li>
</ul>
</li>
<li>
<p><strong>一个非抽象类继承一个抽象类，必须覆盖（抽象）抽象类中的抽象方法</strong></p>
<ul>
<li>如果不覆盖，那么非抽象类就会继承抽象方法，然而抽象方法不能出现在非抽象类中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;<span class="comment">//抽象类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;<span class="comment">//非抽象类继承抽象类</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;&#125;<span class="comment">//必须覆盖抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8fy376y2oj319c0k876i.jpg" alt="" /></p>
<ul>
<li>抽象类去继承抽象类，则父类中的抽象方法不需要一定被覆盖/实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;<span class="comment">//抽象类去继承抽象类</span></span><br><span class="line">  <span class="comment">//可以不用实现抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>抽象类中的多态</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;<span class="comment">//抽象类</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;<span class="comment">//非抽象类去继承抽象类</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;<span class="comment">//实现抽象方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;鸟儿在飞翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">//抽象类不能实例化对象，但是抽象类同样可以拥有引用</span></span><br><span class="line">      	<span class="comment">//Bird不是抽象类，可以实例化为对象</span></span><br><span class="line">      	<span class="comment">//animal一个Animal类的引用，指向Bird的一个对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">      	<span class="comment">//编译时，绑定的是Animal类的move()方法</span></span><br><span class="line">      	<span class="comment">//运行时，绑定的是Bird类的move()方法</span></span><br><span class="line">        animal.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果继承抽象类的非抽象类中，没有实现抽象方法，那么在运行时无法去运行方法体中的代码</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>接口</title>
    <url>/2022/11/26/Java/%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h1>
<h2 id="接口的概念"><a class="markdownIt-Anchor" href="#接口的概念"></a> 接口的概念</h2>
<ul>
<li>
<p>接口也是一个引用数据类型</p>
<ul>
<li>虽然接口不是一个类，但它编译之后仍然生成一个<code>.class</code>的字节码文件</li>
</ul>
</li>
<li>
<p>接口是<strong>完全抽象</strong>的</p>
<ul>
<li>接口是一种特殊的抽象类</li>
<li>抽象类是半抽象的</li>
</ul>
</li>
<li>
<p>接口的语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] interface 接口名&#123;</span><br><span class="line">  	<span class="comment">//接口不是一个类，不能用class关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] class 类名&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>抽象类的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] <span class="keyword">abstract</span> class 类名&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>接口支持多继承，一个接口可以继承多个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">		<span class="comment">//编译生产.class字节码文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span>, B&#123;</span><br><span class="line">		<span class="comment">//支持多继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8fzhoo1zzj306b05mmx2.jpg" alt="" /></p>
</li>
<li>
<p>接口中只包含两个部分：<u><strong>常量 以及 抽象方法</strong></u></p>
</li>
<li>
<p>接口中所有的元素都是由<code>public</code>修饰的</p>
<ul>
<li>在接口中定义方法时，<code>public</code>和<code>abstract</code>两个关键字可以修饰不写</li>
<li>在接口中声明变量时，<code>publi static final</code>三个关键字不写，并且必须手动赋初始值
<ul>
<li>通过接口直接访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="接口的实现"><a class="markdownIt-Anchor" href="#接口的实现"></a> 接口的实现</h2>
<ul>
<li>
<p>类和接之间的继承关系称作<strong>实现</strong>，关键字<code>implements</code></p>
<ul>
<li>
<p>类和类之间叫做继承，关键字<code>extends</code></p>
</li>
<li>
<p>抽象类实现接口时，可以不用实现接口中的方法</p>
<ul>
<li>抽象类中运行存在抽象方法</li>
</ul>
</li>
<li>
<p>非抽象类实现接口时，必须要实现接口中每一个 的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;<span class="comment">//接口A</span></span><br><span class="line">  	<span class="comment">//常量</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line">  	<span class="comment">//抽象方法</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;<span class="comment">//非抽象方法实现接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;<span class="comment">//通过快捷键command + N直接生成</span></span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="comment">//必须实现接口中的每一个抽象方法</span></span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;&#125;<span class="comment">//抽象方法实现接口</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在实现接口中的方法时，类中方法的访问控制权限必须是<code>public</code></p>
<ul>
<li>子类继承父类的方法，访问权限只能更高，不能更低</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="接口的多态"><a class="markdownIt-Anchor" href="#接口的多态"></a> 接口的多态</h2>
<ul>
<li>
<p>接口的多态</p>
</li>
<li>
<pre class="highlight"><code class="java"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();<span class="comment">//父类型的引用指向子类型的对象</span>
a.sum(<span class="number">10</span>,<span class="number">20</span>);
&lt;!--code￼<span class="number">5</span>--&gt;

&lt;!--code￼<span class="number">6</span>--&gt;



</code></pre>
</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g0s85rx5j30u80jwdhj.jpg" alt="" /></p>
<ul>
<li>接口的类型转换
<ul>
<li>向下类型转换
<ul>
<li>同样需要使用<code>instanceof</code>来判断</li>
</ul>
</li>
<li>强制类型转换
<ul>
<li><u>可以两个没有继承关系的接口进行相互转化</u></li>
<li>编译不会报错，但是运行过程中可能会抛出<code>ClassCastException</code>异常</li>
<li>在类的类型转换中，无论是向上转型还是向下转型，必须要求两个类有继承关系</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="继承和实现同时存在"><a class="markdownIt-Anchor" href="#继承和实现同时存在"></a> 继承和实现同时存在</h2>
<ul>
<li>
<p><code>extends</code>关键字在前，<code>implements</code>关键字在后</p>
</li>
<li>
<p>接口通常提取的是行为动作</p>
</li>
<li>
<p>一个类实现一个接口，就代表能够完成该接口的动作</p>
</li>
<li>
<p>举一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="comment">//接口：接口通常提取的是行为动作</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Flyable通过接口插到猫身上，猫就可以飞翔</span></span><br><span class="line"><span class="comment">//将翅膀插到猫身上，猫就可以飞翔</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;会飞的猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果不想让蛇类飞，可以不实现Flyable接口</span></span><br><span class="line"><span class="comment">//没有实现这个接口则表示不能飞</span></span><br><span class="line"><span class="comment">//不给蛇插上翅膀，蛇就不能飞翔</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Flyable</span> <span class="variable">fly</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    fly.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="接口的作用"><a class="markdownIt-Anchor" href="#接口的作用"></a> 接口的作用</h2>
<ul>
<li>面向抽象编程等价于面向接口编程</li>
<li>有了接口就可以插拔，可插拔代表拓展力强、低耦合度</li>
<li>接口的使用离不开多态</li>
<li><code>A has a B</code><strong><u>则B是A的一个属性</u></strong></li>
<li><code>A is a B</code><strong><u>则A是B的子类（继承）</u></strong></li>
<li>举一个例子：顾客去餐厅可以点餐，既可以点中餐也可以点西餐</li>
</ul>
<h2 id="接口和抽象类的区别"><a class="markdownIt-Anchor" href="#接口和抽象类的区别"></a> 接口和抽象类的区别</h2>
<ol>
<li>抽象
<ul>
<li>抽象类是半抽象的：可以在里面定义非抽象的方法，<u>也可以定义普通的成员变量</u></li>
<li>接口是纯抽象的：在接口中定义的方法都是抽象方法，在接口中声明的变量都是静态常量</li>
</ul>
</li>
<li>构造方法
<ul>
<li>抽象类拥有构造方法</li>
<li>接口中没有构造方法</li>
</ul>
</li>
<li>继承
<ul>
<li>抽象类只能单继承：一个类只能继承一个抽象类</li>
<li>接口支持多继承：一个类可以实现多个接口</li>
</ul>
</li>
<li>使用情况
<ul>
<li>抽象类是对行为和数据的抽象，使用的较少</li>
<li>接口是对行为的抽象</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据的格式化</title>
    <url>/2022/12/14/Java/%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<h1 id="数据的格式化"><a class="markdownIt-Anchor" href="#数据的格式化"></a> 数据的格式化</h1>
<h2 id="日期格式化"><a class="markdownIt-Anchor" href="#日期格式化"></a> 日期格式化</h2>
<h3 id="date"><a class="markdownIt-Anchor" href="#date"></a> Date</h3>
<p>在<code>java.util</code>包中存在一个<code>Data</code>类，提供对日期的描述，这个描述可以精确到毫秒</p>
<blockquote>
<p>The class <code>Date</code> represents a specific instant in time, with millisecond precision.</p>
</blockquote>
<h4 id="public-date"><a class="markdownIt-Anchor" href="#public-date"></a> <code>public Date()</code></h4>
<blockquote>
<p>Allocates a <code>Date</code> object and initializes it so that it represents the time at which it was allocated, measured to the nearest millisecond.</p>
</blockquote>
<ul>
<li>获取系统当前时间（精确到毫秒）</li>
<li>直接通过无参的构造方法获得</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date1);<span class="comment">//默认调用重写了的toString()方法</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h92guhr7ltj30ft07q74g.jpg" alt="" /></p>
<h4 id="public-datelong-date"><a class="markdownIt-Anchor" href="#public-datelong-date"></a> <code>public Date(long date)</code></h4>
<blockquote>
<p>Allocates a Date object and initializes it to represent the specified number of milliseconds since the standard base time known as &quot;the epoch&quot;, namely January 1, 1970, 00:00:00 GMT.</p>
</blockquote>
<ul>
<li>通过传入一个自<em>1970年1月1日00:00:00 000</em>开始的<u>毫秒数</u>来构造一个<code>Date</code>对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1</span>);<span class="comment">//自epoch开始后的1毫米</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">System.out.println(simpleDateFormat.format(date1));</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h93hehg74bj30fr06jt8v.jpg" alt="" /></p>
<ul>
<li>之所以是八点，是因为时区的问题，这里显示的是北京时间（东八区）</li>
</ul>
<h4 id="simpledateformat"><a class="markdownIt-Anchor" href="#simpledateformat"></a> <code>SimpleDateFormat</code></h4>
<p>在<code>java.text</code>中存在<code>SimpleDateFormat</code>类，提供用<u>特定格式</u>对日期的描述</p>
<blockquote>
<p><code>SimpleDateFormat</code> is a concrete class for formatting and parsing dates in a locale-sensitive manner. It allows for formatting (date → text), parsing (text → date), and normalization.</p>
</blockquote>
<h5 id="public-simpledateformatstring-pattern"><a class="markdownIt-Anchor" href="#public-simpledateformatstring-pattern"></a> <code>public SimpleDateFormat(String pattern)</code></h5>
<blockquote>
<p>Constructs a <code>SimpleDateFormat</code> using the given pattern and the default date format symbols for the default FOMAT locale. <strong>Note:</strong> This constructor may not support all locales.</p>
</blockquote>
<ul>
<li>用给定格式创建一个<code>SimpleDateFormat</code>对象</li>
<li>格式</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h92h7tymwgj30pk0fygno.jpg" alt="" /></p>
<h5 id="public-final-string-formatdate-date"><a class="markdownIt-Anchor" href="#public-final-string-formatdate-date"></a> <code>public final String format(Date date)</code></h5>
<ul>
<li>将一个<code>Date</code>类型的时间转换成一个字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;日期：yyyy-MM-dd 时间：HH:mm:ss:SSS&quot;</span>);</span><br><span class="line"><span class="comment">//除了字母所代表的含义不能修改，其余的格式都能修改</span></span><br><span class="line"><span class="comment">//yyyy的含义是年份的数字有四位...以此类推</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h93fmokpyoj30fs0813yt.jpg" alt="" /></p>
<h5 id="public-date-parsestring-source-throws-parseexception"><a class="markdownIt-Anchor" href="#public-date-parsestring-source-throws-parseexception"></a> <code>public Date parse(String source) throws ParseException</code></h5>
<ul>
<li>将给定的一个时间字符串转换成标准的<code>Date</code>类型时间</li>
<li>注意<code>SimpleDateFormat</code>的日期格式必须和字符串的日期格式相同</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;<span class="comment">//需要处理异常</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;2022-12-14  17:19:30 666&quot;</span>;<span class="comment">//2022年12月14日17点19分33秒666毫秒</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd  HH:mm:ss SSS&quot;</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> simpleDateFormat1.parse(time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h93gknrrsaj30fw07z3yu.jpg" alt="" /></p>
<h2 id="时间"><a class="markdownIt-Anchor" href="#时间"></a> 时间</h2>
<h3 id="public-static-native-long-currenttimemillis"><a class="markdownIt-Anchor" href="#public-static-native-long-currenttimemillis"></a> <code>public static native long currentTimeMillis()</code></h3>
<blockquote>
<p>Returns the current time in milliseconds. the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC</p>
</blockquote>
<ul>
<li>返回自<em>1970年1月1日00:00:00 000</em>到当前系统时间的<u>总毫秒数</u></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">nowTimeMili</span> <span class="operator">=</span> System.currentTimeMillis();</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h93gus5455j30ft06p74g.jpg" alt="" /></p>
<h3 id="程序运行时间的计算"><a class="markdownIt-Anchor" href="#程序运行时间的计算"></a> 程序运行时间的计算</h3>
<ul>
<li>通过分别获取某段程序运行前的系统时间，以及程序运行结束后的系统时间，通过做差来求出该程序的运行时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">doSome();</span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">long</span> <span class="variable">runTime</span> <span class="operator">=</span> endTime - startTime;</span><br></pre></td></tr></table></figure>
<h3 id="获取昨天当前的时间"><a class="markdownIt-Anchor" href="#获取昨天当前的时间"></a> 获取昨天当前的时间</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">nowTime</span> <span class="operator">=</span> System.currentTimeMillis();<span class="comment">//获取自epoch开始当前时间的毫秒数</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">yesterday</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(nowTime - <span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);<span class="comment">//减去一天之间的毫秒数</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">System.out.println(simpleDateFormat.format(yesterday));</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h93hm71jywj30fv06emxc.jpg" alt="" /></p>
<h2 id="数据格式化"><a class="markdownIt-Anchor" href="#数据格式化"></a> 数据格式化</h2>
<h3 id="decimalformat"><a class="markdownIt-Anchor" href="#decimalformat"></a> DecimalFormat</h3>
<p>在<code>java.text</code>包下存在<code>DecimalFormat</code>包，提供对数字的描述</p>
<blockquote>
<p>It has a variety of features designed to make it possible to parse and format numbers in any locale, including support for Western, Arabic, and Indic digits. It also supports different kinds of numbers, including integers (123), fixed-point numbers (123.4), scientific notation (1.23E4), percentages (12%), and currency amounts ($123). All of these can be localized.</p>
</blockquote>
<h3 id="public-decimalformatstring-pattern"><a class="markdownIt-Anchor" href="#public-decimalformatstring-pattern"></a> <code>public DecimalFormat(String pattern)</code></h3>
<blockquote>
<p>Creates a DecimalFormat using the given pattern and the symbols for the default FORMAT locale. This is a convenient way to obtain a DecimalFormat when internationalization is not the main concern.</p>
</blockquote>
<ul>
<li>用给定的模式去创造一个<code>DecimalFormat</code>对象</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h93i538idvj314i0a8wgm.jpg" alt="" /></p>
<ul>
<li>简单来说
<ul>
<li>*#*代表任意数字</li>
<li><em>0</em>代表不够时的补位</li>
<li>*，*代表千分位</li>
<li>*.*代表小数点</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式类似123，456.78</span></span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">decimalFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;###,###.##&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="public-final-string-formatdouble-number"><a class="markdownIt-Anchor" href="#public-final-string-formatdouble-number"></a> <code>public final String format(double number)</code></h3>
<ul>
<li>将一个<code>double</code>类型的数据转换成特定的<code>DecimalFormat</code>类型的字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DecimalFormat</span> <span class="variable">decimalFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;###,###.##&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> decimalFormat.format(<span class="number">1234.654</span>);</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h93iaywxvwj30fw0700sw.jpg" alt="" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DecimalFormat</span> <span class="variable">decimalFormat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;000,000,000.000&quot;</span>);</span><br><span class="line">System.out.println(decimalFormat1.format(<span class="number">1234567.89</span>));</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h93ie3f1amj30fw07iq35.jpg" alt="" /></p>
<h3 id="bigdecimal"><a class="markdownIt-Anchor" href="#bigdecimal"></a> <code>BigDecimal</code></h3>
<blockquote>
<p>The <code>BigDecimal</code> class provides operations for arithmetic, scale manipulation, rounding, comparison, hashing, and format conversion. The <code>toString()</code> method provides a canonical representation of a <code>BigDecimal</code>.</p>
</blockquote>
<ul>
<li>精度极高的大数据，不属于基本数据类型，一般用于财务软件中</li>
<li>使用<code>BigDecimal</code>中提供的方法来进行数据操作</li>
</ul>
<h3 id="随机数"><a class="markdownIt-Anchor" href="#随机数"></a> 随机数</h3>
<p>在<code>java.util</code>包下有<code>Random</code>类，用于生成随机数</p>
<h4 id="public-int-nextintint-bound"><a class="markdownIt-Anchor" href="#public-int-nextintint-bound"></a> <code>public int nextInt(int bound)</code></h4>
<blockquote>
<p>Returns a pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence.</p>
</blockquote>
<ul>
<li>返回一个在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>b</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,bound)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span>之间的随机整数</li>
</ul>
<h4 id="public-int-nextint"><a class="markdownIt-Anchor" href="#public-int-nextint"></a> <code>public int nextInt()</code></h4>
<ul>
<li>返回一个整形范围内的随机数</li>
</ul>
<h4 id="mathrandom"><a class="markdownIt-Anchor" href="#mathrandom"></a> <code>Math.Random()</code></h4>
<p>还可以用<code>Math</code>类中的<code>Random()</code>方法来生成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>之间的随机浮点数</p>
<ul>
<li>用<code>Math.Random()</code>生成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span>之间的随机数方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * a);</span><br><span class="line"><span class="comment">//需要进行类型强制转换</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意以下错误写法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> (<span class="type">int</span>) Math.random() * a;</span><br><span class="line"><span class="comment">//这样会先进行Math.random()的类型强制转换，转换得到的结果是0，所以这个随机数的值一直是0</span></span><br></pre></td></tr></table></figure>
<h4 id="产生ab范围内的随机数"><a class="markdownIt-Anchor" href="#产生ab范围内的随机数"></a> 产生<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>范围内的随机数</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> random.nextInt(b-a) + a;</span><br><span class="line"><span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> a + (<span class="type">int</span>)(Math.random()*(b-a));</span><br></pre></td></tr></table></figure>
<h4 id="产生多个不含重复数字的随机数组"><a class="markdownIt-Anchor" href="#产生多个不含重复数字的随机数组"></a> 产生多个不含重复数字的随机数组</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">//随机生成五个不同的随机数放入数组中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//数组的个数</span></span><br><span class="line">        <span class="keyword">while</span> (num &lt; <span class="number">20</span>)&#123;<span class="comment">//随机产生20个数组</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> random.nextInt(<span class="number">20</span>) + <span class="number">1</span>;<span class="comment">//随机产生数组的长度，长度至少是1</span></span><br><span class="line">            <span class="type">int</span>[] arr = randomArray(len,<span class="number">20</span>);<span class="comment">//数组中每个元素的范围是0-20</span></span><br><span class="line">            <span class="keyword">if</span>(arr != <span class="literal">null</span>)&#123;</span><br><span class="line">                display(arr,len);</span><br><span class="line">                num ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArray(<span class="type">int</span> len, <span class="type">int</span> bound)&#123;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; bound) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//如果产生的长度比数的范围还要大，则必定存在重复元素</span></span><br><span class="line">        <span class="type">int</span>[] randoms = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        Arrays.fill(randoms,-<span class="number">1</span>);<span class="comment">//数组所有元素默认填充为-1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//随机数的个数</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//代表没有重复元素</span></span><br><span class="line">        <span class="keyword">while</span> (num &lt; len)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> random.nextInt(bound);<span class="comment">//随机产生数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i ++)&#123;<span class="comment">//和前面的数字不重复</span></span><br><span class="line">                <span class="keyword">if</span> (randomNum == randoms[i]) flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) randoms[num ++] = randomNum;</span><br><span class="line">            flag = <span class="literal">true</span>;<span class="comment">//重置判断条件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> randoms;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h2>
<ul>
<li>枚举是一种特殊的类，在编译之后同样生成一个<code>.class</code>文件</li>
<li>枚举也是一种引用类型</li>
<li>枚举中的每一个值可以看作是一个<strong>常量</strong>，我们不需要再为其赋值</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h93nme6969j30t107jq3p.jpg" alt="" /></p>
<h3 id="枚举的语法格式"><a class="markdownIt-Anchor" href="#枚举的语法格式"></a> 枚举的语法格式</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举类型名&#123;</span><br><span class="line">		枚举值<span class="number">1</span>，枚举值<span class="number">2.</span>..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>枚举值的访问
<ul>
<li>通过枚举类型名去访问</li>
</ul>
</li>
<li>枚举值的命名全部采用大写字母</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> Color.RED;</span><br><span class="line">        System.out.println(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">    RED, BLUE, GREEN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h93ns6epulj30fu05wglt.jpg" alt="" /></p>
<h3 id="枚举的使用"><a class="markdownIt-Anchor" href="#枚举的使用"></a> 枚举的使用</h3>
<ul>
<li>枚举的使用有点类似于<u>布尔类型</u></li>
<li>当结果的类型是有穷尽的，但又大于两种，我们考虑使用枚举类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">result</span> <span class="operator">=</span> add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (result == Number.POSITIVE)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;两数相加的和是正数&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == Number.NEGETIVE) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;两数相加的和是负数&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;两数相加的和是0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a + b &gt; <span class="number">0</span>) <span class="keyword">return</span> Number.POSITIVE;</span><br><span class="line">        <span class="keyword">if</span> (a + b &lt; <span class="number">0</span>) <span class="keyword">return</span> Number.NEGETIVE;</span><br><span class="line">        <span class="keyword">return</span> Number.ZERO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    POSITIVE, ZERO, NEGETIVE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数组1</title>
    <url>/2022/11/29/Java/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h1>
<h2 id="数组-2"><a class="markdownIt-Anchor" href="#数组-2"></a> 数组</h2>
<ul>
<li>Java中的数组是一个<u>引用数据类型</u>，其父类是<code>Object</code>
<ul>
<li>数组存储于堆内存中</li>
</ul>
</li>
<li>数组实际上是一个<strong>容器</strong>，可以容纳多个元素</li>
<li>数组中可以存储基本数据类型，也可以存储引用数据类型
<ul>
<li>存储引用属于类型时，存储的是对象的引用</li>
</ul>
</li>
<li>在Java数组一旦创建，中长度不可变</li>
<li>数组的分类
<ul>
<li>一维数组：最常用</li>
<li>二维数组</li>
<li>多维数组：很少用</li>
</ul>
</li>
<li>所有的数组对象都有<code>length</code>属性，用来获取数组中元素的个数</li>
<li>Java要求数组中的元素类型统一
<ul>
<li><code>int</code>型数组只能存储<code>int</code>型元素</li>
</ul>
</li>
<li>数组中元素的内存地址是连续的</li>
<li>数组中首元素的内存地址作为整个数组对象的内存地址
<ul>
<li>数组中元素的内存地址是连续的，知道第一个元素的地址就可以推算出其他元素的地址</li>
</ul>
</li>
</ul>
<h2 id="数组的优缺点"><a class="markdownIt-Anchor" href="#数组的优缺点"></a> 数组的优缺点</h2>
<ul>
<li>优点
<ol>
<li>检索效率高
<ul>
<li>知道第一个元素的内存地址、知道每个元素占用的空间大小，可以通过下标直接定位出每个元素的内存地址</li>
</ul>
</li>
<li>存储效率高</li>
</ol>
</li>
<li>缺点
<ol>
<li>增加/删除元素效率低
<ul>
<li>对于数组中最后一个元素的增删是没有效率影响的</li>
</ul>
</li>
<li>数组很难存储大量的数据
<ul>
<li>无法在内存中开辟一大块连续的空间</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="一维数组"><a class="markdownIt-Anchor" href="#一维数组"></a> 一维数组</h2>
<h3 id="语法格式"><a class="markdownIt-Anchor" href="#语法格式"></a> 语法格式</h3>
<h4 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar;</span><br><span class="line"><span class="comment">//int[] arr1;</span></span><br><span class="line"><span class="comment">//User[] array;</span></span><br></pre></td></tr></table></figure>
<h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4>
<ul>
<li>
<p>分为静态初始化和动态初始化</p>
</li>
<li>
<p>静态初始化</p>
<ul>
<li>当创建数组时就确定数组中存储的元素，那么采用静态初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;</span><br><span class="line"><span class="comment">//这条语句包括两个步骤</span></span><br><span class="line"><span class="comment">//&quot;数据类型[] 数组名&quot;是声明了一个数组</span></span><br><span class="line"><span class="comment">//然后通过静态的方式给新创建的数组赋值</span></span><br><span class="line"><span class="comment">//int[] arr = &#123;1,2,3&#125;; </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>动态初始化</p>
<ul>
<li>通过动态初始化的数组元素默认值为0</li>
<li>预先为数组元素分配内存空间，在后期可以修改数组元素的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br><span class="line"><span class="comment">//通过&quot;dataType[arraySize]&quot;声明了一个数组</span></span><br><span class="line"><span class="comment">//将新创建的数组赋给arrayRefVar</span></span><br><span class="line"><span class="comment">//int[] arr = new int[3];</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="数组的遍历"><a class="markdownIt-Anchor" href="#数组的遍历"></a> 数组的遍历</h4>
<ul>
<li>
<p><code>ArrayIndexOutOfBoundsException</code></p>
<ul>
<li>数组下标越界异常：当访问的元素的下标超出或者小于数组元素的范围时抛出的异常</li>
</ul>
</li>
<li>
<p>For - Each循环</p>
<ul>
<li>可以在不适用下标的情况下遍历数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(dataType element: arrayRefVar)&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//举个例子</span></span><br><span class="line"><span class="type">double</span>[] arr = &#123;<span class="number">1.3</span>,<span class="number">4.6</span>,<span class="number">2.6</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">double</span> element: arr)&#123;</span><br><span class="line">   System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="数组作为方法的参数"><a class="markdownIt-Anchor" href="#数组作为方法的参数"></a> 数组作为方法的参数</h4>
<ul>
<li>数组可以作为参数传递给方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> elemnt: arr) &#123;</span><br><span class="line">            System.out.print(elemnt + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;通过静态方法初始化的数组&quot;</span>);</span><br><span class="line">        print(arr1);</span><br><span class="line">        System.out.println(<span class="string">&quot;通过动态方法初始化的数组&quot;</span>);</span><br><span class="line">        print(arr2);</span><br><span class="line">        System.out.println(<span class="string">&quot;通过动态方法初始化的数组&quot;</span>);</span><br><span class="line">        print(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8lsy8ycupj30ft0andg9.jpg" alt="" /></p>
<ul>
<li>直接传递静态数组的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">dataType</span>[]&#123;value0, value1, ..., valuek&#125;</span><br><span class="line"><span class="comment">//举个例子</span></span><br><span class="line">print(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);<span class="comment">//报错</span></span><br><span class="line">print(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;)<span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure>
<h2 id="main方法的形参列表"><a class="markdownIt-Anchor" href="#main方法的形参列表"></a> main方法的形参列表</h2>
<ul>
<li>
<p>JVM负责调用<code>main</code>方法，<code>main</code>方法的形参列表是<code>String[] args</code></p>
</li>
<li>
<p>JVM传递的实参并不是一个空引用，但并没有存储数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;String[] args的长度是 &quot;</span> + args.length);</span><br><span class="line">  			<span class="comment">//等价于</span></span><br><span class="line">  			<span class="comment">//String[] strs = &#123;&#125;;</span></span><br><span class="line">  			<span class="comment">//引用指向一个数组，但是数组中没有存储任何数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>String[] args</code>是用来接受用户在控制台上输入的参数的</p>
<ul>
<li>用户通过<code>java</code>命令来输入参数
<ul>
<li><code>java + 类名 + 参数</code></li>
</ul>
</li>
<li>JVM将用户输入的参数按照空格的方式进行分离，分离转化完成后自动放到<code>String[] args</code>中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTest</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;String[] args的长度为 &quot;</span> + args.length);</span><br><span class="line">		<span class="keyword">for</span>(String element: args)&#123;</span><br><span class="line">			System.out.println(element);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ltevppqoj30la0em0ts.jpg" alt="" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;请输入用户名和密码！&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">  	<span class="comment">//有效避免空指针异常</span></span><br><span class="line">  	<span class="comment">//用&quot;admin&quot;去调用equals方法</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(args[<span class="number">0</span>]) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(args[<span class="number">1</span>]) )&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;欢迎&quot;</span> + args[<span class="number">0</span>] + <span class="string">&quot;回来&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;用户名密码错误！&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ltol9acej30ni0fa3zl.jpg" alt="" /></p>
</li>
</ul>
<h2 id="引用类型的数组"><a class="markdownIt-Anchor" href="#引用类型的数组"></a> 引用类型的数组</h2>
<ul>
<li>当数组中存储引用数据类型时，会涉及到多态的概念</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">//创建一个父类的数组</span></span><br><span class="line">      	<span class="comment">//父类的数组中可以存储不同的子类对象</span></span><br><span class="line">        Animal[] animals = &#123;<span class="keyword">new</span> <span class="title class_">Bird</span>(), <span class="keyword">new</span> <span class="title class_">Fish</span>()&#125;;</span><br><span class="line">      	<span class="comment">//调用父类的的方法</span></span><br><span class="line">      	<span class="comment">//最后会调用每个子类对父类方法的重写</span></span><br><span class="line">        <span class="keyword">for</span>(Animal element : animals)&#123;</span><br><span class="line">            element.move();</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//调用某个子类特有的方法</span></span><br><span class="line">      	<span class="comment">//需要向下转型（转型之前用instanceof来判断）</span></span><br><span class="line">        <span class="keyword">for</span> (Animal animal: animals)&#123;</span><br><span class="line">            <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Bird)&#123;</span><br><span class="line">                <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> (Bird) animal;</span><br><span class="line">                bird.hatch();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is moving&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hatch</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is hatching its baby&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fish is swimming&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组的扩容"><a class="markdownIt-Anchor" href="#数组的扩容"></a> 数组的扩容</h2>
<ul>
<li>扩容的过程
<ul>
<li>当原数组元素满了的时候</li>
<li>新建一个大容量的数组，将之前数组中的数据一个一个的拷贝到大数组中</li>
</ul>
</li>
<li>扩容的效率很低
<ul>
<li>在设置数组时需要提前估计好数组的长度，避免发生拷贝</li>
</ul>
</li>
</ul>
<h3 id="数组的拷贝"><a class="markdownIt-Anchor" href="#数组的拷贝"></a> 数组的拷贝</h3>
<ul>
<li>
<p><code>System.arraycopy(Object src,int srcPos,Object dest, int destPos, int length)</code></p>
<blockquote>
<p>Copies an array from the specified source array, beginning at the specified position, to the specified position of the destination array. A subsequence of array components are copied from the source array referenced by <code>src</code> （从src数组中复制）to the destination array referenced by <code>dest</code>（复制到dest数组中）. The number of components copied is equal to the <code>length</code> argument（拷贝元素的长度）. The components at positions <code>srcPos</code> through <code>srcPos+length-1</code> in the source array are copied into positions <code>destPos</code>through <code>destPos+length-1</code>, respectively, of the destination array.</p>
</blockquote>
<ul>
<li>用<code>Object</code>可以更好的兼容各种数组类型</li>
<li>所有的数组都继承了<code>Object</code>类</li>
</ul>
</li>
<li>
<p><strong>从<code>src</code>数组的<code>srcPos</code>的位置开始复制，拷贝到到<code>dest</code>数组从<code>destPos</code>位置开始的地方，一共复制<code>length</code>个元素，</strong></p>
</li>
<li>
<p>拷贝的内容不仅可以拷贝基本类型的数据，还可以拷贝引用类型的数据</p>
<ul>
<li>拷贝引用类型的数据时拷贝的是其地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;World&quot;</span>,<span class="string">&quot;Test&quot;</span>,<span class="string">&quot;Java&quot;</span>&#125;;</span><br><span class="line">        String[] arrNew = <span class="keyword">new</span> <span class="title class_">String</span>[arr.length];</span><br><span class="line">  			<span class="comment">//拷贝引用内容</span></span><br><span class="line">        System.arraycopy(arr,<span class="number">0</span>,arrNew,<span class="number">0</span>,arr.length);</span><br><span class="line">        <span class="keyword">for</span>(String str : arrNew)&#123;</span><br><span class="line">            System.out.print(str + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Object[] objects = &#123;<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>()&#125;;</span><br><span class="line">        Object[] objects1 = <span class="keyword">new</span> <span class="title class_">Object</span>[objects.length + <span class="number">5</span>];</span><br><span class="line">        System.arraycopy(objects,<span class="number">0</span>,objects1,<span class="number">0</span>,objects.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objects1.length; i++)&#123;</span><br><span class="line">          	<span class="comment">//输出拷贝的内容</span></span><br><span class="line">          	<span class="comment">//在Java中直接输出一个类的对象时会默认调用该对象的toString方法</span></span><br><span class="line">          	<span class="comment">//默认的toString方法是输出 类名@地址</span></span><br><span class="line">            System.out.println(objects1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8m3vyvx0hj30fu0dm3yz.jpg" alt="" /></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组2</title>
    <url>/2022/11/30/Java/%E6%95%B0%E7%BB%842/</url>
    <content><![CDATA[<h1 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h1>
<h2 id="二维数组"><a class="markdownIt-Anchor" href="#二维数组"></a> 二维数组</h2>
<ul>
<li>二维数组是一个特殊的一维数组，特殊在这个一维数组中每个元素都是一个一维数组</li>
<li>三维数组是一个特殊的二维数组，在这个二维数组中每个元素都是一个一个一维数组</li>
<li>....</li>
</ul>
<h3 id="语法格式"><a class="markdownIt-Anchor" href="#语法格式"></a> 语法格式</h3>
<h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4>
<ul>
<li>
<p>静态初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[][] arrayRefVar = &#123;</span><br><span class="line">	&#123;value0, value1, ..., valuek&#125;,</span><br><span class="line">	&#123;valuek+<span class="number">1</span>, valuek+<span class="number">2</span>, ..., valuek+i&#125;,</span><br><span class="line">	...</span><br><span class="line">	&#123;valuej+<span class="number">1</span>, value1j+<span class="number">2</span>, ..., valuej+n&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//举个例子</span></span><br><span class="line"><span class="type">int</span>[][] arr = &#123;</span><br><span class="line">  &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">  &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,</span><br><span class="line">  &#123;<span class="number">12</span>,<span class="number">543</span>,<span class="number">23</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>二维数组的长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以上一个例子中的arr数组为例</span></span><br><span class="line">System.out.println(arr.length);<span class="comment">//输出二维数组的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">	System.out.println(arr[i].length);<span class="comment">//输出二维数组里每个元素的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>动态初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[][] arrayRefVar = <span class="keyword">new</span> <span class="title class_">dataType</span>[length1][length2];</span><br><span class="line"><span class="comment">//举个例子</span></span><br><span class="line"><span class="type">double</span>[][] arry = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">10</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="数组的访问"><a class="markdownIt-Anchor" href="#数组的访问"></a> 数组的访问</h4>
<ul>
<li><code>arr[i][j]</code>表示第<code>i</code>个一维数组中的第<code>j</code>个元素
<ul>
<li><code>arr[i]</code>是一个整体</li>
<li>第<code>i</code>行第<code>j</code>列的元素</li>
</ul>
</li>
<li>数组的遍历
<ul>
<li>用两个循环来遍历二维数组</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中常用算法</title>
    <url>/2022/12/01/Java/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="数组中常用算法"><a class="markdownIt-Anchor" href="#数组中常用算法"></a> 数组中常用算法</h1>
<h2 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//默认所有元素都是有序的</span></span><br><span class="line">            <span class="comment">//从1开始与后面的数比较，避免越界</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; arr.length - i; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j-<span class="number">1</span>] &gt; arr[j])&#123;</span><br><span class="line">                    swap(arr,j-<span class="number">1</span>,j);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         		<span class="comment">//如果遍历了一次没有发现任何逆序对，则代表所有元素都是排好序的</span></span><br><span class="line">            <span class="keyword">if</span> (flag)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//生成随机数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArr(<span class="type">int</span> len, <span class="type">int</span> range)&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * range);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//比较两个数组是否相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == <span class="literal">null</span> || arr2 == <span class="literal">null</span> || arr1.length != arr2.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] != arr2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//测试方法</span></span><br><span class="line">  	<span class="comment">//生成一个长度为len，每个元素在0-range之间的数组，分别用排序算法以及系统提供的sort方法进行排序</span></span><br><span class="line">  	<span class="comment">//将以上步骤重复times次，比较结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> range, <span class="type">int</span> times)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] arr1 = randomArr(len, range);</span><br><span class="line">            <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">            System.arraycopy(arr1,<span class="number">0</span>,arr2,<span class="number">0</span>,len);</span><br><span class="line">            bubbleSort(arr1);</span><br><span class="line">            Arrays.sort(arr2);</span><br><span class="line">            <span class="keyword">if</span> (!compare(arr1,arr2))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (test(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;False&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8o4wr4fenj30fu08fq32.jpg" alt="" /></p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<ul>
<li>冒泡排序需要<code>arr.length-1</code>轮，在每一轮中，从下标为1的元素开始与后面的元素进行比较，这样可以有效避免数组指针越界</li>
</ul>
<h2 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h2>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line">  	<span class="comment">//在数组arr中，选择从下标start开始后面的元素中最小的哪一个，并把它放到start位置上</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pickSmall</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[small] &gt; arr[i])</span><br><span class="line">                small = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (small != start)<span class="comment">//如果start是最小的那个元素则不需要交换</span></span><br><span class="line">            swap(arr,start,small);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            pickSmall(arr,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArr(<span class="type">int</span> len, <span class="type">int</span> range)&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * range);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == <span class="literal">null</span> || arr2 == <span class="literal">null</span> || arr1.length != arr2.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] != arr2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> range, <span class="type">int</span> times)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] arr1 = randomArr(len, range);</span><br><span class="line">            <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">            System.arraycopy(arr1,<span class="number">0</span>,arr2,<span class="number">0</span>,len);</span><br><span class="line">            selectSort(arr1);</span><br><span class="line">            Arrays.sort(arr2);</span><br><span class="line">            <span class="keyword">if</span> (!compare(arr1,arr2))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (test(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;False&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8o4x794saj30ft084aa7.jpg" alt="" /></p>
<h2 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> 二分查找</h2>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;<span class="comment">//边界条件需要带=</span></span><br><span class="line">            mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; target)&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回没有重复元素的随机数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArr(<span class="type">int</span> len, <span class="type">int</span> range)&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * range);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dupilcate(arr))<span class="comment">//如果这个数组没有重复元素，则直接返回</span></span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//否则返回一个空</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//判断数组中是否有重复元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">dupilcate</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//测试方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> range)</span>&#123;</span><br><span class="line">      	<span class="comment">//随机生成一个没有重复元素的数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = randomArr(len, range);</span><br><span class="line">        <span class="keyword">while</span> (arr == <span class="literal">null</span>)&#123;</span><br><span class="line">            arr = randomArr(len, range);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//对其进行排序</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">      	<span class="comment">//随机选择一个这个数组中的元素作为待查找的目标值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * len);</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> arr[index];</span><br><span class="line">				<span class="comment">//返回查找的结果</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(arr,target)==index;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//将以上步骤重复times次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> range, <span class="type">int</span> times)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!test(len, range))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      	<span class="comment">//元素数字的范围一定要大于数组的长度，否则会产生太多有重复元素的数组</span></span><br><span class="line">        <span class="keyword">if</span> (test(<span class="number">100</span>,<span class="number">10000</span>,<span class="number">100</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;False&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8o52tkr5xj30fu07s74f.jpg" alt="" /></p>
<h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
<ul>
<li>在进行二分查找时，控制循环的条件语句是<code>low &lt;= high</code>，<strong><u>一定得带等号</u></strong>。因为在<code>low=high</code>这个情况下还可以进入一次循环体，此时计算出来的<code>mid</code>就是<code>low</code></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2022/12/23/Java/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h2>
<h3 id="泛型的作用"><a class="markdownIt-Anchor" href="#泛型的作用"></a> 泛型的作用</h3>
<ul>
<li>泛型提供了<strong>编译时</strong>类型安全检测机制，该机制允许程序员在编译时检测到非法的类型
<ul>
<li>在运行期间泛型的作用不大</li>
</ul>
</li>
<li>泛型的好处
<ul>
<li>统一集合中存储的元素类型</li>
<li>从集合中取出的元素类型都是泛型所指定的类型，不需要进行大量的向下类型转换</li>
</ul>
</li>
<li>泛型的缺点
<ul>
<li>导致集合中存储元素缺乏多样性
<ul>
<li>原本集合中存储的全部都是<code>Object</code>类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is moving...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bird is flying...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is barking...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不实用泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">  	<span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">  	<span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    arrayList.add(animal);arrayList.add(bird);arrayList.add(dog);</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">      	<span class="comment">//需要向下强制类型转换</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Animal)&#123;</span><br><span class="line">            <span class="type">Animal</span> <span class="variable">ani</span> <span class="operator">=</span> (Animal) obj;</span><br><span class="line">            ani.move();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">  	<span class="comment">//使用泛型后，ArrayList只会存储Animal类型的数据</span></span><br><span class="line">    ArrayList&lt;Animal&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    arrayList.add(animal);arrayList.add(bird);arrayList.add(dog);</span><br><span class="line">		<span class="comment">//迭代器也需要使用泛型</span></span><br><span class="line">    Iterator&lt;Animal&gt; iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">      	<span class="comment">//当然如果要使用Dog和Bird中的特殊方法，还需要进行向下类型转化</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">ani</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        ani.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动类型推断机制"><a class="markdownIt-Anchor" href="#自动类型推断机制"></a> 自动类型推断机制</h3>
<ul>
<li>JDK8引入的新机制，又称为钻石表达式</li>
<li>在声明时，只用写前面尖括号中的泛型的类型，后面的类型可以自动推断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用自动类型推断机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">  	<span class="comment">//自动类型推断机制</span></span><br><span class="line">    <span class="comment">//ArrayList&lt;Animal&gt; arrayList = new ArrayList&lt;Animal&gt;();</span></span><br><span class="line">  	ArrayList&lt;Animal&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    arrayList.add(animal);arrayList.add(bird);arrayList.add(dog);</span><br><span class="line">		</span><br><span class="line">    Iterator&lt;Animal&gt; iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">ani</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        ani.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义泛型"><a class="markdownIt-Anchor" href="#自定义泛型"></a> 自定义泛型</h3>
<h4 id="泛型方法"><a class="markdownIt-Anchor" href="#泛型方法"></a> 泛型方法</h4>
<ul>
<li>我们可以自定义一个泛型方法，该方法在调用时可以接收不同类型的参数</li>
<li>语法规则
<ul>
<li><code>&lt;类型&gt;</code>中的类型只是一个表示符，一般为<code>&lt;T&gt;</code>（Type）或者<code>&lt;E&gt;</code>（Element）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法修饰符 &lt;类型&gt;方法返回值 方法名(行参列表)&#123;</span><br><span class="line">		方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] strings = &#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>,<span class="string">&quot;789&quot;</span>&#125;;</span><br><span class="line">    System.out.println(test(strings));;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;MyClass&gt; MyClass <span class="title function_">test</span><span class="params">(MyClass[] myClasses)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (MyClass element: myClasses)&#123;</span><br><span class="line">    		System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myClasses[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型类"><a class="markdownIt-Anchor" href="#泛型类"></a> 泛型类</h4>
<ul>
<li>与泛型方法类似</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyClass&lt;Animal&gt; myClass = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        myClass.setT(<span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> myClass.getT();</span><br><span class="line">        System.out.println(animal.name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setT</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="foreach循环"><a class="markdownIt-Anchor" href="#foreach循环"></a> Foreach循环</h2>
<h3 id="增强for循环"><a class="markdownIt-Anchor" href="#增强for循环"></a> 增强for循环</h3>
<ul>
<li>在JDK5之后推出的新特性</li>
<li>语法格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(ElementType 变量名: Arrays/Collection)&#123;</span><br><span class="line">		<span class="comment">//对变量进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>缺点：没有下标</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">     list.add(<span class="string">&quot;123&quot;</span>);list.add(<span class="string">&quot;456&quot;</span>);list.add(<span class="string">&quot;789&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;abc&quot;</span>);list.add(<span class="string">&quot;def&quot;</span>);list.add(<span class="string">&quot;ghi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String str: list)&#123;</span><br><span class="line">    		System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="comment">//等价于</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    		System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="comment">//等价于</span></span><br><span class="line">   Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">   <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">   			System.out.println(iterator.next());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义时间</title>
    <url>/2022/11/23/Java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="自定义时间"><a class="markdownIt-Anchor" href="#自定义时间"></a> 自定义时间</h1>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>自定义一个时间类，能够完成对时间的加减操作。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h4 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h4>
<p>针对这个问题，我们需要定义一个时间类<code>MyTime</code>，其中当然必须包含三个属性<code>hour</code>，<code>minute</code>和<code>second</code>，为了安全起见，我们将这三个属性设置为私有属性。这个问题最麻烦的部分当然是对时间的各项操作，包括时间的增加、减少，具体来说，最复杂的部分应该是时间的减少。</p>
<p>我的第一个思路是直接对各项属性进行操作，例如：增加多少秒，则直接通过<code>setSecond</code>函数来实现，然后再来调整各个属性，如果秒数超过<code>60</code>则进位等等。这个思路在解决时间相加时是比较简单的，但是解决时间减少时就比较麻烦了，尤其是对秒进行相减时，需要考虑<code>hour</code>，<code>minute</code>和<code>second</code>三个属性的变化。</p>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHour</span><span class="params">(<span class="type">int</span> hor)</span> &#123;</span><br><span class="line">    setHour((getHour() + hor) % <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMinute</span><span class="params">(<span class="type">int</span> min)</span> &#123;</span><br><span class="line">    min = min + getMinute();</span><br><span class="line">    <span class="keyword">if</span> (min &lt; <span class="number">60</span>) &#123;</span><br><span class="line">        setMinute(min);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addHour(min / <span class="number">60</span>);</span><br><span class="line">        setMinute((min % <span class="number">60</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSecond</span><span class="params">(<span class="type">int</span> sec)</span> &#123;</span><br><span class="line">    sec = sec + getSecond();</span><br><span class="line">    <span class="keyword">if</span> (sec &lt; <span class="number">60</span>) &#123;</span><br><span class="line">        setSecond(sec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addMinute(sec / <span class="number">60</span>);</span><br><span class="line">        setSecond(sec % <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subHour</span><span class="params">(<span class="type">int</span> hor)</span> &#123;</span><br><span class="line">    hor = getHour() - hor;</span><br><span class="line">    <span class="keyword">if</span> (hor &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;时间错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setHour(hor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subMinute</span><span class="params">(<span class="type">int</span> min)</span> &#123;</span><br><span class="line">    min = getMinute() - min;</span><br><span class="line">  	<span class="comment">//这里需要考虑复杂的借位情况</span></span><br><span class="line">  	<span class="comment">//分钟只需要向小时借位，但借的位数变化很大</span></span><br><span class="line">    <span class="keyword">if</span> (min &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        subHour(min / <span class="number">60</span> * (-<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        min = <span class="number">60</span> + min % <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">if</span> (min &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            addHour(min / <span class="number">60</span>);</span><br><span class="line">            setMinute(min % <span class="number">60</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setMinute(<span class="number">60</span> + min % <span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setMinute(min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subSecond</span><span class="params">(<span class="type">int</span> sec)</span> &#123;</span><br><span class="line">  	<span class="comment">//需要考虑向分、小时借位的情况</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>在写到<code>subSecond</code>方法时，我意识到这个思路太麻烦了，可能不是解决这个问题的最好办法。</p>
<p>这时，我想到能否运用<strong>面向对象的思想</strong>来解决这个问题：在时间增加时，不是直接对<code>MyTime</code>对象的一个属性进行相加，而是将要增加/减少的时间也封装成一个<code>MyTime</code>对象，直接进行对象与对象之间的操作。然后再定义一个方法，能够调整每个对象的属性，使对象的各个属性合法（小时的取值在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mtext>～</mtext><mn>23</mn></mrow><annotation encoding="application/x-tex">0～23</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">～</span><span class="mord">2</span><span class="mord">3</span></span></span></span>之间，分钟和秒的取值在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mtext>～</mtext><mn>59</mn></mrow><annotation encoding="application/x-tex">0～59</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">～</span><span class="mord">5</span><span class="mord">9</span></span></span></span>之间）。这样，相加时，直接两个对象对应的属性相加，加完了再调整一下最后的结果；相减时，直接两个对象对应的属性相减，减完了再调整一下。</p>
<p>这个方法的好处是大大简化了时间相加减的操作。</p>
<ul>
<li>一方面，两个规范合法的对象相加减，分钟或者秒如果要借位的话也最多只用借一位（最极限的情况<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>−</mo><mn>59</mn><mo>=</mo><mo>−</mo><mn>59</mn></mrow><annotation encoding="application/x-tex">0-59=-59</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">5</span><span class="mord">9</span></span></span></span>），要进位的话也最多只用尽一位（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>59</mn><mo>+</mo><mn>59</mn><mo>=</mo><mn>118</mn></mrow><annotation encoding="application/x-tex">59+59=118</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">8</span></span></span></span>），在这种情况下不用考虑一次操作对多个属性的影响。举个例子，按照方法一直接给某一个属性进行操作，比如按最复杂的秒来说，如果要增加3600秒，那么就需要<code>setSecond(getSecond()+3600)</code>，那么这个操作之后就需要再去调整分、小时，这两个属性，它们的进位、借位情况会随着不同的值而有很大的不同。但是如果按照方法二，我们需要考虑的情况就会大大减少，每一次操作最多影响两个属性，而且影响的范围不过是进或者借一位。</li>
<li>另一方面，我们可以直接省略进位/借位的操作，尤其即使是只进了一位（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mo>:</mo><mn>59</mn><mo>:</mo><mn>59</mn><mo>+</mo><mn>0</mn><mo>:</mo><mn>0</mn><mo>:</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">10:59:59+0:0:1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>）会影响多个属性的特殊情况。通过规范化的函数，我们可以让任意一个<code>MyTime</code>对象的属性合法。也就是说，对于任何一次的运算结果，我们可以不用考虑过多运算进位/借位的过程，而是将最后的运算结果（例如上一个例子的运算结果：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mo>:</mo><mn>59</mn><mo>:</mo><mn>60</mn></mrow><annotation encoding="application/x-tex">10:59:60</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span></span></span></span>）再次进行一次规范化，不停的进行规范化操作，直到最后的结果合法，并且这个规范化的过程不过是调用一个函数。</li>
</ul>
<p>这个方法当然也不是我一下就想出来的，即使我有了用封装的办法来解决这个问题的思路后还是碰到了不少麻烦。虽然我想到了直接用两个对象进行操作，但我并没有意思到可以对操作的结果再进行一次标准化，以此来减少麻烦，我一开始还是想着在sub方法里详细的考虑每一种情况。如果按照这样的思路的话，其实我这样做也没有比方法一好太多。但是我还是学习到了不少东西，比如说有关于Java中的向上取整方法。</p>
<h4 id="向上取整"><a class="markdownIt-Anchor" href="#向上取整"></a> 向上取整</h4>
<ul>
<li>
<p>在Java中的除运算是向下取整的，向上取整需要调用<code>Math.ceil(double a)</code>方法</p>
</li>
<li>
<p>语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;<span class="comment">//需要导入Math包</span></span><br><span class="line"><span class="comment">//它的返回值是double类型的，参数列表也需要的也是一个double</span></span><br><span class="line"><span class="type">double</span> Math.ceil(<span class="type">double</span> a)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">5/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">/</span><span class="mord">2</span></span></span></span>向下取整以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>2</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">-2/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord">/</span><span class="mord">3</span></span></span></span>向下取整</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要将最后的计算结果强制转化为int才</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res1</span> <span class="operator">=</span> (<span class="type">int</span>)Math.ceil((<span class="type">double</span>)<span class="number">5</span>/<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">res2</span> <span class="operator">=</span> (<span class="type">int</span>)Math.ceil((<span class="type">double</span>)-<span class="number">2</span>/<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8f1iimxj7j30vq0f0q4a.jpg" alt="" /></p>
</li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTime</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hour;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> minute;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTime</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTime</span><span class="params">(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (second &lt; <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.second = second;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minute = minute + second / <span class="number">60</span>;</span><br><span class="line">            <span class="built_in">this</span>.second = second % <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minute &lt; <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.minute = minute;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hour = hour + minute / <span class="number">60</span>;</span><br><span class="line">            <span class="built_in">this</span>.minute = minute % <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.hour = hour % <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将输入的时间转换为MyTime对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyTime <span class="title function_">trans</span><span class="params">(<span class="type">int</span> time, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="comment">//2代表秒 1代表分 0代表小时</span></span><br><span class="line">        <span class="type">MyTime</span> <span class="variable">myTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTime</span>();</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                myTime.setHour(time / <span class="number">3600</span>);</span><br><span class="line">                time = time % <span class="number">3600</span>;</span><br><span class="line">                myTime.setMinute(time / <span class="number">60</span>);</span><br><span class="line">                myTime.setSecond(time % <span class="number">60</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                myTime.setHour(time / <span class="number">60</span>);</span><br><span class="line">                myTime.setMinute(time % <span class="number">60</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                myTime.setHour(time);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;时间类型错误！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整Mytime对象，使其数字合法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trans</span><span class="params">(MyTime time)</span> &#123;</span><br><span class="line">        <span class="comment">//对秒进行标准化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> time.getSecond();</span><br><span class="line">            <span class="comment">//如果秒大于或者等于60，则需要进位</span></span><br><span class="line">            <span class="comment">//需要注意的是，两个标准的MyTime类型相加，最多只会进一位</span></span><br><span class="line">        <span class="keyword">if</span> (second &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            time.setMinute(time.getMinute() + second / <span class="number">60</span>);</span><br><span class="line">            time.setSecond(second % <span class="number">60</span>);</span><br><span class="line">            trans(time);<span class="comment">//再次标准化，因为可能分钟属性超过了60</span></span><br><span class="line">        &#125; <span class="keyword">if</span>(second &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//若秒小于0，则需要借为</span></span><br><span class="line">            <span class="comment">//两个标准的MyTime类型相减，最多只会借一位</span></span><br><span class="line">            time.setSecond(<span class="number">60</span> + second);</span><br><span class="line">            time.setMinute(time.getMinute() - <span class="number">1</span>);<span class="comment">//借一位</span></span><br><span class="line">            trans(time);<span class="comment">//再次标准化</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果秒小于60，且大于0，则直接赋值即可</span></span><br><span class="line">            time.setSecond(second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对分钟进行标准化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> time.getMinute();</span><br><span class="line">            <span class="comment">//如果分钟大于或者等于60，则需要进位</span></span><br><span class="line">            <span class="comment">//最多进一位</span></span><br><span class="line">        <span class="keyword">if</span> (minute &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            time.setHour(time.getHour() + minute / <span class="number">60</span>);</span><br><span class="line">            time.setMinute(minute % <span class="number">60</span>);</span><br><span class="line">            trans(time);</span><br><span class="line">        &#125;<span class="keyword">if</span> (minute &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//分钟小于0，则需要借位</span></span><br><span class="line">            <span class="comment">//最多只会借一位</span></span><br><span class="line">            time.setMinute(<span class="number">60</span> + minute);</span><br><span class="line">            <span class="comment">//https://blog.csdn.net/qq_39290394/article/details/102468431</span></span><br><span class="line">            time.setHour(time.getHour() - <span class="number">1</span>);<span class="comment">//对应的小时减少</span></span><br><span class="line">            trans(time);<span class="comment">//再次标准化</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果分钟小于60，且大于0，则直接赋值即可</span></span><br><span class="line">            time.setMinute(minute);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对小时进行标准化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> time.getHour();</span><br><span class="line">            <span class="comment">//如果小时大于24，则需要进行取模运输</span></span><br><span class="line">        <span class="keyword">if</span> (hour &gt; <span class="number">24</span>)&#123;</span><br><span class="line">            time.setHour(hour % <span class="number">24</span>);</span><br><span class="line">            <span class="comment">//如果小时小于0，则需要转换为正数</span></span><br><span class="line">            <span class="comment">//两个标准的MyTime进行相减，最小的结果为-24</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hour &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            time.setHour(hour + <span class="number">24</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            time.setHour(hour);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHour</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hour;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHour</span><span class="params">(<span class="type">int</span> hour)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hour = hour;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minute;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMinute</span><span class="params">(<span class="type">int</span> minute)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.minute = minute;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSecond</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(<span class="type">int</span> second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//显示时间结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getHour() + <span class="string">&quot; : &quot;</span> + getMinute() + <span class="string">&quot; : &quot;</span> + getSecond());</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//显示运算结果</span></span><br><span class="line">  	<span class="comment">//type 0代表加，1代表减</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dispaly</span><span class="params">(MyTime time1, MyTime time2, <span class="type">int</span> type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(time1.getHour() + <span class="string">&quot; : &quot;</span> + time1.getMinute() + <span class="string">&quot; : &quot;</span> + time1.getSecond() + <span class="string">&quot; + &quot;</span> + time2.getHour() + <span class="string">&quot; : &quot;</span> + time2.getMinute() + <span class="string">&quot; : &quot;</span> + time2.getSecond());</span><br><span class="line">            time1.add(time2);</span><br><span class="line">            time1.display();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(time1.getHour() + <span class="string">&quot; : &quot;</span> + time1.getMinute() + <span class="string">&quot; : &quot;</span> + time1.getSecond() + <span class="string">&quot; - &quot;</span> + time2.getHour() + <span class="string">&quot; : &quot;</span> + time2.getMinute() + <span class="string">&quot; : &quot;</span> + time2.getSecond());</span><br><span class="line">            time1.sub(time2);</span><br><span class="line">            time1.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//时间相加操作</span></span><br><span class="line">  	<span class="comment">//直接让两个属性相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MyTime time)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setSecond(<span class="built_in">this</span>.getSecond() + time.getSecond());</span><br><span class="line">        <span class="built_in">this</span>.setMinute(<span class="built_in">this</span>.getMinute() + time.getMinute());</span><br><span class="line">        <span class="built_in">this</span>.setHour(<span class="built_in">this</span>.getHour() + time.getHour());</span><br><span class="line">        trans(<span class="built_in">this</span>);<span class="comment">//增加之后使其合法</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//时间相减操作</span></span><br><span class="line">  	<span class="comment">//直接让两个属性相减</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">(MyTime time)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setHour(<span class="built_in">this</span>.getHour() - time.getHour());</span><br><span class="line">        <span class="built_in">this</span>.setMinute(<span class="built_in">this</span>.getMinute() - time.getMinute());</span><br><span class="line">        <span class="built_in">this</span>.setSecond(<span class="built_in">this</span>.getSecond() - time.getSecond());</span><br><span class="line">        trans(<span class="built_in">this</span>);<span class="comment">//减完之后使其合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>计算柱体体积</title>
    <url>/2022/11/25/Java/%E8%AE%A1%E7%AE%97%E6%9F%B1%E4%BD%93%E4%BD%93%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="计算柱体体积"><a class="markdownIt-Anchor" href="#计算柱体体积"></a> 计算柱体体积</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<ul>
<li>为柱体的底面设计一个接口Geometry，包含计算面积的方法<code>getArea()</code></li>
<li>为柱体设计类Pillar，要求
<ul>
<li>有两个成员变量，底面和高度。底面可以是任何可以计算面积的几何形状</li>
<li>实现构造方法，对成员变量赋值</li>
<li>设计成员方法，计算柱体pillar的体积</li>
</ul>
</li>
<li>编写测试类圆形类、矩形类，实现Geometry接口，编写测试类Test</li>
</ul>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pillar</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Geometry bottom;<span class="comment">//底面</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> hight;<span class="comment">//高度</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pillar</span><span class="params">(Geometry shape, <span class="type">double</span> hight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bottom = shape;</span><br><span class="line">        <span class="built_in">this</span>.hight = hight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回体积</span></span><br><span class="line">    <span class="comment">//由于不同的底面计算面积时需要的参数个数不同，因此这里直接设置不需要参数</span></span><br><span class="line">    <span class="comment">//通过调用Geometry中的getArea()方法获得面积</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bottom.getArea() * hight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//几何形状接口</span></span><br><span class="line"><span class="comment">//插上几何形状接口后就能获得面积</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Geometry</span>&#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆形类实现几何形状</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Geometry</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> radius;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>;<span class="comment">//常量</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//实现getArea()方法</span></span><br><span class="line">    <span class="comment">//在实现接口中的方法时注意不能用重载的方法实现</span></span><br><span class="line">    <span class="comment">//即不能改变其形参列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">int</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Geometry</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length * width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> length, <span class="type">int</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多态，父类型引用指向子类型对象</span></span><br><span class="line">        <span class="comment">//Shape类的引用指向一个半径为10的圆形</span></span><br><span class="line">        <span class="type">Geometry</span> <span class="variable">shape1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//构造一个以半径为10的圆形为底，高为10的圆柱</span></span><br><span class="line">        <span class="type">Pillar</span> <span class="variable">pillar1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pillar</span>(shape1,<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;体积是 &quot;</span> + pillar1.getSize());</span><br><span class="line"></span><br><span class="line">        <span class="type">Geometry</span> <span class="variable">shape2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="type">Pillar</span> <span class="variable">pillar2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pillar</span>(shape2,<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;体积是 &quot;</span> + pillar2.getSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hd94zauzj30fu08574h.jpg" alt="" /></p>
<h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2>
<ul>
<li>在一开始我做这个题目时，我被Geometry中计算面积的方法<code>getArea()</code>方法难到了。考虑到接口中不能设计变量，我不能也不方便给每一种几何图形都设置计算面积时所需要的变量，那<code>getArea()</code>方法的形参列表我就很难去设计。<u>此时我的第一反应是在不同的几何形状类中用重载的方式去实现接口中的抽象方法。</u>但是事实证明这个思路是行不通的，<strong>在类中实现一个接口时我们需要完完全全的照抄接口中的抽象方法，不能修改它的返回类型以及形参列表</strong>。</li>
<li>在这之后其实换一个思路就好了。既然每种几何图形的面积计算都需要不同的形参列表，那我不如直接不需要形参好了，在<code>getArea()</code>方法中直接去调用每个几何形状方法的成员变量。这种方法就不用再去担心计算不同面积时需要不同参数的情况。</li>
<li>这次的一个小练习也真正的让我感受到了多态的便利之处。通过一个 Geometry接口，我们能用非常简单的方式来计算各种类型柱体的体积。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>验证回文串</title>
    <url>/2022/12/03/Java/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="验证回文串"><a class="markdownIt-Anchor" href="#验证回文串"></a> 验证回文串</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。（字母和数字都属于字母数字字符）</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>我们首先观察回文串的特点，也就是正着读和反着读的顺序是相同的，那么借助这个特点，我首先想到的是用双指针的方法来解决这道题。设立两个指针，分别从头到尾，和从尾到头的遍历这个字符串，如果这个字符串是一个回文串的话，那头指针和尾指针指向的字符应该永远都是一样的。</p>
<p>当然这个题还有一个点需要考虑，那么就是要移除所有的非字母数字字符，并且忽略大小写。这一点其实也很容易实现，根据遍历到的字符的ASCII码做相应的处理即可。如果是非字母数字字符则直接跳过，如果是大写字符那么就统一将其转换为小写。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，只需要将字符串遍历一遍即可</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="补充知识"><a class="markdownIt-Anchor" href="#补充知识"></a> 补充知识</h3>
<ul>
<li>
<p><code>public static boolean isLetterOrDigit(char ch)</code></p>
<blockquote>
<p>Determines if the specified character is a letter or digit.（判断一个字符是字母或者是数字）</p>
<p>A character is considered to be a letter or digit if either <code>Character.isLetter(char ch)</code> or <code>Character.isDigit(char ch)</code> returns <code>true</code> for the character.</p>
</blockquote>
<ul>
<li>在<code>java.lang.Character</code>下提供了一个静态方法来判断一个字符的属性，我们不需要再单独写一个方法去通过ASCII码实现该功能</li>
</ul>
</li>
<li>
<p><code>public static char toLowerCase(char ch)</code></p>
<blockquote>
<p>Converts the character argument to lowercase using case mapping information from the UnicodeData file.（将大些字母转换为小写字母）</p>
</blockquote>
<ul>
<li>在<code>java.lang.Character</code>下提供了一个静态方法来实现大小写字母的转化</li>
</ul>
</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = s.length() - <span class="number">1</span>;<span class="comment">//两个指针</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">//不需要带等号，因为如果i和j指向同一个字符时，那必然是相等的</span></span><br><span class="line">          	<span class="comment">//忽略非字母数字字符</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; isChar(s.charAt(i)) == <span class="string">&#x27;\u0000&#x27;</span>)&#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//忽略非字母数字字符</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; isChar(s.charAt(j)) == <span class="string">&#x27;\u0000&#x27;</span>)&#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//如果两个指针指向的内容不一样，则肯定不是回文串</span></span><br><span class="line">            <span class="keyword">if</span> (isChar(s.charAt(i)) != isChar(s.charAt(j)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i ++;<span class="comment">//指针移动</span></span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//判断字符是否是字母数字字符，是的话返回数字或者小写字符，否则返回0</span></span><br><span class="line">  	<span class="comment">//等价于实现了isLetterOrDigit(char ch)和toLowerCase(char ch)方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">isChar</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">asc</span> <span class="operator">=</span> (<span class="type">int</span>) c;</span><br><span class="line">        <span class="keyword">if</span> (asc &lt; <span class="number">48</span>) <span class="keyword">return</span> <span class="string">&#x27;\u0000&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (asc &gt; <span class="number">57</span> &amp;&amp; asc &lt; <span class="number">65</span>) <span class="keyword">return</span> <span class="string">&#x27;\u0000&#x27;</span>;</span><br><span class="line">        <span class="comment">//将大写字母转换为小写字母</span></span><br><span class="line">        <span class="keyword">if</span> (asc &gt; <span class="number">64</span> &amp;&amp; asc &lt; <span class="number">91</span>) <span class="keyword">return</span> (<span class="type">char</span>) (c + <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">if</span> (asc &gt; <span class="number">90</span> &amp;&amp; asc &lt; <span class="number">97</span>) <span class="keyword">return</span> <span class="string">&#x27;\u0000&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (asc &gt; <span class="number">122</span>) <span class="keyword">return</span> <span class="string">&#x27;\u0000&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(i)))&#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(j)))&#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Character.toLowerCase(s.charAt(i ++)) != Character.toLowerCase(s.charAt(j --)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>当然还有一个更直接的方法。既然回文串满足将字符串反过来读还是一样的的特点，那我们就直接反转一个字符串，如果反转之后的和反转之前是一样的话，那它就是一个回文串。这里的反转不能直接反转，我们需要将字符串里的非字母数字字符去掉之后再进行反转。</p>
<p>由于需要对字符串的内容进行修改，我们这里考虑使用<code>StringBuffer</code>的数据类型</p>
<ul>
<li>时间复杂度：我们首先要遍历一遍原来的字符串，去掉其中的非字母数字字符，然后将其翻转之后再与原来的字符串进行比较，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：我们需要用一个<code>StringBuffer</code>来装载之前的字符串信息，空间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">          	<span class="comment">//将非字母数字字符 并且将其统一为小写后 加入sb</span></span><br><span class="line">            <span class="keyword">if</span> (Character.isLetterOrDigit(c))</span><br><span class="line">                sb.append(Character.toLowerCase(c));</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//new StringBuffer(sb.reverse())会报错</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sbReverse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(sb).reverse();</span><br><span class="line">      	<span class="comment">//是sb与sbReverse比较，而不是s和sbReverse比较</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString().equals(sbReverse.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>整数反转</title>
    <url>/2022/11/28/%E7%AE%97%E6%B3%95/%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="整数反转"><a class="markdownIt-Anchor" href="#整数反转"></a> 整数反转</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给你一个32位的有符号整数x ，返回将x中的数字部分反转后的结果。如果反转后整数超过32位的有符号整数的范围<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mtext>−</mtext><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>31</mn></msup><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[−2^{31},2^{31} − 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，就返回 0。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>我最开始想到的方法就是设置一个数组<code>nums</code>，将x中的数字通过不停的模10取出，然后我再把数组<code>nums</code>的数字重新拼接成一个数。模10取出一方面就是逆序读取x中的数字（从低位开始读），另一方面通过取模运算还能很好的保留x的符号信息。重新拼接的过程也很简单，<code>nums</code>数组中第一位就乘$10^{len} $，<code>nums</code>第二位再乘$10^{len-1} $....其中<code>len</code>表示数字的位数。</p>
<p>我这个方法在面对普通的输入时是有效的，<u><strong>但是无法判断溢出的问题</strong></u>！整型的取值范围是<code>[-2147483648~2147483647]</code>。因为我会一上来就确定最后结果的首位数字，如果首位数字是4，并且长度有10位，那么很好判断最后结果肯定溢出。但是如果首位数字是2，并且长度还是10，那我其实就很为难了，因为如果2999999999那就是越界了，那要是2000000000那又没有越界，所以我得不停的判断下去。结果里每增加一位数，我就得判断一次，这样下去其实是无法得出结果的。</p>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];<span class="comment">//最多只有10位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录数字的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nums[i] = x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; len &gt; <span class="number">0</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                len --;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//判断是否大于最小32位整数</span></span><br><span class="line">          	<span class="comment">//然而这是无效且徒劳的</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否小于最小32位整数</span></span><br><span class="line">            <span class="keyword">if</span> (res &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = pow(<span class="number">10</span>,len-<span class="number">1</span>) * nums[i] + res;</span><br><span class="line">            len --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//x的i次方</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//计算次方时，初始值得默认为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j ++)&#123;</span><br><span class="line">            res = res * x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>针对方法一的漏洞，我们可以提出改进。我们不要一开始就确定结果的最高位，而是可以每取出x的末尾的一位数，我们就拼接一下，让最后的结果慢慢的变大。</p>
<p>在方法一中，假如我们要反转123这个数，我们的方法是这样的。先通过取模运算，得到一个<code>nums</code>数组<code>nums=&#123;3,2,1&#125;</code>。然后依次从<code>nums</code>数组里读出数字，拼接成最后的结果，即$res_{1} =3\times 10^{2} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，</mtext></mrow><annotation encoding="application/x-tex">，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span></span></span></span>res_{2} =res_{1} +2\times 10^{1} $...我直接确定了最后结果里的每一位数字，这个过程类似<u>从顶向下</u>，我只能拿到一个已经溢出了的结果，但无法知道是从哪一步开始发生的溢出。</p>
<p>那在方法二中，我们是采用这样的步骤<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><msub><mi>s</mi><mn>1</mn></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">res_{1} = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><msub><mi>s</mi><mn>2</mn></msub><mo>=</mo><mi>r</mi><mi>e</mi><msub><mi>s</mi><mn>1</mn></msub><mo>×</mo><mn>10</mn><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">res_{2}= res_{1}\times 10 + 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>...也就是每增加一位数就把之前的数向前挤一位。这样的过程类似<u>从底向上</u>，这样做的好处就是能判断每一步的结果，如果在第n-1步发生了溢出，那就可以直接返回0了。</p>
<p>那接下来就只用解决如何判断溢出这个问题了。发生溢出其实就是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><msub><mi>s</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>×</mo><mn>10</mn><mo>+</mo><mi>i</mi><mo>&gt;</mo><mi>M</mi><mi>A</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">res_{n-1} \times 10 + i &gt;MAX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，那么我们把这个逻辑转换成代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否大于最小32位整数</span></span><br><span class="line"><span class="comment">//除10是因为最后res的计算时要乘10</span></span><br><span class="line"><span class="comment">//tmp = x % 10</span></span><br><span class="line"><span class="keyword">if</span> (res &gt; Integer.MAX_VALUE/<span class="number">10</span> || (res==Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; tmp&gt;<span class="number">7</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否大于最小32位整数</span></span><br><span class="line"><span class="keyword">if</span> (res &lt; Integer.MIN_VALUE/<span class="number">10</span> || (res==-Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; tmp&lt;-<span class="number">8</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们也可以从发生溢出后产生的后果出发来判断是否已经发生了溢出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">last = res;<span class="comment">//记录上一个res</span></span><br><span class="line">res = res*<span class="number">10</span> + tmp;</span><br><span class="line"><span class="comment">//判断整数溢出</span></span><br><span class="line"><span class="comment">//发生溢出后，显然两个res之间不再会满足如下关系</span></span><br><span class="line"><span class="keyword">if</span>(last != res/<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>由于在这个方法里，我们不需要数字的长度信息，不需要计算<code>res = pow(10,len-1) * nums[i] + res</code>，所以我们也没有必要先遍历一遍数组，每取出一个数字就可以做一次操作。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>只用遍历一次数x即可</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;<span class="comment">//循环结束的条件是！=0，因此存在负数情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> res;</span><br><span class="line">            res = x % <span class="number">10</span> + res * <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (pre != res / <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2022/11/23/%E7%AE%97%E6%B3%95/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="两数之和"><a class="markdownIt-Anchor" href="#两数之和"></a> 两数之和</h1>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给你一个下标从 1 开始的整数数组<code>numbers</code> ，该数组已按<u>非递减顺序排列</u>，请你从数组中找出满足相加之和等于目标数<code>target</code>的两个数。如果设这两个数分别是<code>numbers[index1]</code>和<code>numbers[index2]</code>，则<code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code>。</p>
<p>你可以假设每个输入 只对应唯一的答案 ，而且你不可以重复使用相同的元素。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>这个问题可以等价于先固定<code>numbers[index1]</code>这个数，要求我们在数组中找到<code>target-numbers[index1]</code>这个数的下标。由于当前的数组是有序的，所以我们首先考虑到通过二分法来解决这个问题。为了避免重复，我们可以每次在numbers[index1]这个数右边寻找。</p>
<ul>
<li>采用这种方法时，<code>index1</code>的下标需要将整个数组遍历一遍来确定第一个数，在<code>index1</code>遍历的一轮中，对剩下的数采用二分法来查找<code>index2</code>，一轮二分法查找需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>的时间，而一共需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>轮，总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>这种方法不需要申请额外的辅助空间，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>注意：如果将二分查找封装成一个函数，那么可能会因为频繁调用函数而造成超时</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; index1 &lt; numbers.length; index1++) &#123;</span><br><span class="line">            low = index1 + <span class="number">1</span>;</span><br><span class="line">            high = numbers.length - <span class="number">1</span>;</span><br><span class="line">          	<span class="comment">//在每一轮中采用二分法来查找</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                mid = low + ((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (numbers[index1] + numbers[mid] &gt; target) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[index1] + numbers[mid] &lt; target)&#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    index2 = mid;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;++index1,++index2&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;<span class="comment">//否则查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="针对上述方法的优化"><a class="markdownIt-Anchor" href="#针对上述方法的优化"></a> 针对上述方法的优化</h3>
<p>我们仔细思考可以发现，如果当<code>index1</code>过小，以至于index2指向数组中最末尾的数时，它们的二者之和也不能大于或者等于<code>target</code>时，那么就可以直接略过这一轮，直接对下一个更大的<code>index1</code>进行查找</p>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; index1 &lt; numbers.length; index1++) &#123;</span><br><span class="line">            low = index1 + <span class="number">1</span>;</span><br><span class="line">            high = numbers.length - <span class="number">1</span>;</span><br><span class="line">          	<span class="comment">//如果index1和数组中最大的数相加都小了，则直接跳过这一轮</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[index1] + numbers[high] &lt; target)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                mid = low + ((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (numbers[index1] + numbers[mid] &gt; target) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[index1] + numbers[mid] &lt; target)&#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    index2 = mid;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;++index1,++index2&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>使用双指针的方法，初始化时低位的指针指向最左边的元素，高位的指针指向最右边的元素，判断这二者之和与<code>target</code>的关系，如果大了，则代表<code>high</code>指针指向的元素过大，<code>high</code>指针左移。如果小了，则代表<code>low</code>指针指向的元素过小，low<code>指针</code>右移。如果刚好等于，则输出<code>low</code>和<code>high</code>指针即可。</p>
<p>这里我们会疑惑，这样的移动会不会造成正确答案被我们遗漏。我们假定<code>numbers[i]+numbers[j]=target</code>.初始时两个指针分别指向下标<code>0</code>和下标<br />
<code>numbers.length−1</code>，左指针指向的下标小于或等于 <code>i</code>，右指针指向的下标大于或等于 <code>j</code>。除非初始时左指针和右指针已经位于下标<code>i</code>和<code>j,</code>否则一定是左指针先到达下标<code>i</code>的位置或者右指针先到达下标<code>j</code> 的位置。<br />
如果左指针先到达下标<code>i</code>的位置，此时右指针还在下标<code>j</code> 的右侧，因此一定是右指针左移，左指针不可能移<code>i</code>的右侧。对应的同理。由此可见，在整个移动过程中，左指针不可能移到<code>i</code>的右侧，右指针不可能移到<code>j</code> 的左侧，因此不会把可能的解过滤掉。由于题目确保有唯一的答案，因此使用双指针一定可以找到答案。</p>
<ul>
<li>这种方法时间只用遍历一遍数组，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度显然是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[low] + numbers[high];</span><br><span class="line">        <span class="keyword">while</span>(sum != target)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                high --;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low ++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum = numbers[low] + numbers[high];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;++low,++high&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2022/12/20/Java/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h1>
<h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2>
<ul>
<li>集合就是一个容器，可以用来容纳其它类型的数据</li>
<li>作用
<ul>
<li>集合作为一个载体，可以一次性容纳多个对象</li>
</ul>
</li>
<li>集合中存储的是对象的<strong>引用</strong>
<ul>
<li>集合中不能存储基本数据类型</li>
<li>集合中也不能直接存储对象</li>
<li>集合本身也是一个对象，这也意味着，集合中可以存储集合的引用</li>
</ul>
</li>
<li>每一个不同的集合在底层对应不同的<strong>数据结构</strong>
<ul>
<li>向不同的集合中增加元素等价于将数据放到了不同的数据结构中</li>
<li>使用不同的集合等价于使用不同的数据结构</li>
<li>根据不同的情况，选择不同的集合</li>
</ul>
</li>
<li>所有的集合类以及集合接口都在<code>java.util</code>下</li>
</ul>
<h2 id="collction的继承结构图"><a class="markdownIt-Anchor" href="#collction的继承结构图"></a> <code>Collction</code>的继承结构图</h2>
<ul>
<li>Java中集合分为两大类
<ol>
<li>直接存储数据元素的方式
<ul>
<li>其超级父类接口是<code>java.util.Collection</code></li>
</ul>
</li>
<li>以键/值对的方式存储数据
<ul>
<li>其超级父类接口是<code>java.util.Map</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="public-interface-iterablet"><a class="markdownIt-Anchor" href="#public-interface-iterablet"></a> <code>public interface Iterable&lt;T&gt;</code></h3>
<blockquote>
<p>Implementing this interface allows an object to be the target of the enhanced for statement (sometimes called the &quot;for-each loop&quot; statement).</p>
</blockquote>
<ul>
<li>表示可迭代、可遍历的接口</li>
<li>实现这个接口代表集合中所有元素都是可以遍历的</li>
<li>接口中有如下方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于返回一个迭代器来遍历集合中的元素</span></span><br><span class="line">Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="public-interface-iteratore"><a class="markdownIt-Anchor" href="#public-interface-iteratore"></a> <code>public interface Iterator&lt;E&gt;</code></h3>
<blockquote>
<p>An iterator over a collection. Iterator takes the place of Enumeration in the Java Collections Framework.</p>
</blockquote>
<ul>
<li>集合的迭代器对象</li>
<li>使用迭代器来遍历整个集合</li>
<li>接口中有以下三个方法来实现集合的遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<h3 id="list接口"><a class="markdownIt-Anchor" href="#list接口"></a> <code>List</code>接口</h3>
<ul>
<li>存储元素的特点
<ul>
<li>有序：存储时的顺序和取出时的顺序一致</li>
<li>可重复：允许在List中存在重复元素</li>
<li>存储的元素有下标：下标从0开始</li>
</ul>
</li>
<li>分别有<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>三个类来实现这个接口</li>
</ul>
<h4 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> <code>ArrayList</code></h4>
<ul>
<li>底层采用<strong>数组</strong>的数据结构</li>
<li>非线程安全的</li>
</ul>
<h4 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> <code>LinkedList</code></h4>
<ul>
<li>底层采用<strong>双向链表</strong>的数据结构</li>
</ul>
<h4 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> <code>Vector</code></h4>
<ul>
<li>底层采用<strong>数组</strong>的数据结构</li>
<li>线程安全的
<ul>
<li>方法中关键字<code>synchronize</code>修饰</li>
<li>效率较低，使用较少</li>
</ul>
</li>
</ul>
<h3 id="set接口"><a class="markdownIt-Anchor" href="#set接口"></a> <code>Set</code>接口</h3>
<ul>
<li>存储元素的特点
<ul>
<li>无序</li>
<li>不可重复</li>
<li>无下标</li>
</ul>
</li>
</ul>
<h3 id="继承结构图"><a class="markdownIt-Anchor" href="#继承结构图"></a> 继承结构图</h3>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h99nmlsdu4j317a0m2tei.jpg" alt="" /></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h99ny5soe3j31n40om0z6.jpg" alt="" /></p>
<h2 id="map的继承结构图"><a class="markdownIt-Anchor" href="#map的继承结构图"></a> <code>Map</code>的继承结构图</h2>
<ul>
<li><code>Map</code>集合与<code>Collection</code>集合无关</li>
<li><code>Map</code>集合中以键值对的方式（<code>key</code>和<code>value</code>）存储元素
<ul>
<li><code>key</code>和<code>value</code>存储的都是对象的引用</li>
<li><code>key</code>是无序且不可重复的</li>
</ul>
</li>
<li>分别有<code>HashMap</code>、<code>Hashtable</code>两个类来实现这个接口</li>
<li>有一个子接口<code>SortedMap</code>，<code>TreeMap</code>实现这个子接口
<ul>
<li><code>SortedMap</code>接口中的<code>key</code>同样是无序且不可重复的</li>
<li>且集合<code>key</code>部分的元素会自动按照大小进行排序</li>
<li>区分这里的<strong>排序</strong>和<code>List</code>集合中的<strong>有序</strong>的区别
<ul>
<li>排序是指：从大到小进行排序</li>
<li>有序是指：存的顺序和取的顺序一致</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> <code>HashMap</code></h3>
<ul>
<li>底层采用<strong>哈希表</strong>的数据结构</li>
<li>非线程安全的</li>
</ul>
<h3 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable"></a> <code>Hashtable</code></h3>
<ul>
<li>底层采用<strong>哈希表</strong>的数据结构</li>
<li>线程安全的
<ul>
<li>效率较低，使用较少</li>
</ul>
</li>
<li>有一个子类<code>Proprieties</code>
<ul>
<li><code>key</code>和<code>value</code>只支持<code>String</code>类型</li>
</ul>
</li>
</ul>
<h3 id="treemap"><a class="markdownIt-Anchor" href="#treemap"></a> <code>TreeMap</code></h3>
<ul>
<li>底层采用<strong>二叉树</strong>的数据结构</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGgy1h99ok7cakgj31lc0u0q9d.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/2022/11/23/%E7%AE%97%E6%B3%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#买卖股票的最佳时机"></a> 买卖股票的最佳时机</h1>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给你一个整数数组<code>prices</code>其中<code>prices[i]</code>表示某支股票第<code>i</code>天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。返回你能获得的最大利润 。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h3>
<h4 id="动态规划的思想"><a class="markdownIt-Anchor" href="#动态规划的思想"></a> 动态规划的思想</h4>
<p>动态规划的思想是：给定一个问题，我们把它拆成一个个<u>子问题</u>，直到子问题可以直接解决。然后，把子问题答案<u>保存起来</u>，以减少重复计算。再根据子问题答案反推，得出原问题解。</p>
<p>其核心就是：<strong>拆分子问题，记住过往，减少重复计算</strong></p>
<p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后发现存在重叠子问题，就可以考虑使用动态规划。</p>
<h4 id="动态规划问题的解决思路"><a class="markdownIt-Anchor" href="#动态规划问题的解决思路"></a> 动态规划问题的解决思路</h4>
<p>动态规划问题的解题步骤主要的有两步</p>
<ol>
<li><strong>状态定义</strong>
<ul>
<li>每一个子问题的求解就能获得一个状态，这个状态可以是当前最长的路径、最大的利润。而状态转移方程</li>
</ul>
</li>
<li><strong>状态转移方程</strong>
<ul>
<li>而从之前已知的状态递推到待求解的目标值这个状态上，我们需要为其规划一个最优的路线，这个状态的转变的路线就称为状态转移方程。</li>
</ul>
</li>
<li>确定边界条件
<ul>
<li>边界条件也就是整个状态转移方程的初始值，只有确定边界条件后才可以使整个递推的状态转移方程运算起来，求得任意状态下的目标值</li>
</ul>
</li>
</ol>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>回到这道题，我们可以列举出每天可能获得的最大利润。这些最大利润之间必然存在关联与重叠，比如要想要通过卖股票增加利润，那么就必须在前几天购入这只股票，然后在前几天购入这只股票会让前几天的利润减少。也就是说，这个问题可以被分成一个个相互重叠的子问题。</p>
<p>其次，每天的利润是可以被穷尽的。因为每天的状态是有穷尽的，要么买、要么卖、要么没有动作，然后因为天数也是有限的，也就是说每个子问题的状态是有限的。所以这道题是可以采用动态规划的方法来解决的。</p>
<p>那么一旦确定要使用动态规划的思想去解决问题，我们就可以按照上述的两个步骤来继续思考。</p>
<ol>
<li>
<p>首先是确定子问题的状态。我认为对状态的定义是解决一道题的关键，并且这个步骤是非常需要技巧和经验的。针对这道题，我们可以把每天获得的最大利润定义为一个状态，也可以把每天的行为定义成一个状态。</p>
<p>我在一开始的时候尝试用第一个思路，即把每天的最大利润定义成一个状态，<code>profit[i]</code>表示每天最大的利润，但我发现这样的话去推导状态转移方程会十分的麻烦。我们一方面需要考虑当天的情况，另一方面还需要不停的回顾之前的情况，比如前几天去买股票、买了股票之后持有的那几天里的利润又不能改变等等。</p>
<p>但是当我们把状态定义为每天的交易情况后题目就瞬间变得容易起来。</p>
<p>我们定义<code>profit[i][]</code>这个二维数组为第<code>i</code>天的状态，<code>dp[i][0]</code>表示第<code>i</code>天交易完之后手里没有股票的最大利润，<code>dp[i][1]</code>表示第<code>i</code>天交易完之后手里持有股票的最大利润</p>
</li>
<li>
<p>接下来就是求状态转移方程，找到状态与状态之间的关系</p>
<ul>
<li>
<p>当天交易完之后手里没有股票可能有两种情况</p>
<ul>
<li>一种是当天没有进行任何交易，又因为当天手里没有股票，所以当天没有股票的利润只能取前一天手里没有股票的利润</li>
<li>另一种是把当天手里的股票给卖了，既然能卖，说明手里是有股票的，所以这个时候当天没有股票的利润要取前一天手里有股票的利润加上当天股票能卖的价格。这两种情况我们取利润最大的即可</li>
<li>所以可以得到：<code>profit[i][0] = max(profit[i-1][0],profit[i-1][1] + prices[i])</code></li>
</ul>
</li>
<li>
<p>当天交易完之后手里持有股票也有两种情况</p>
<ul>
<li>
<p>一种是当天没有任何交易，又因为当天手里持有股票，所以当天手里持有的股票其实前一天就已经持有了。</p>
</li>
<li>
<p>还一种是当天买入了股票，当天能买股票，说明前一天手里肯定是没有股票的，我们取这两者的最大值</p>
</li>
<li>
<p>所以可以得到:<code>profit[i][1] = max(profit[i-1][1],profit[i-1][0] - prices[i]);</code></p>
</li>
</ul>
</li>
<li>
<p>这样每一天的状态仅仅与前面一天有关，不用再考虑几天前的情况</p>
</li>
</ul>
</li>
<li>
<p>当然还要确定整个问题的边界条件，即<code>profit[1][0]</code>和<code>profit[1][1]</code></p>
<ul>
<li><code>profit[1][0] = 0</code>，<code>profit[1][1] = -prieces[0]</code></li>
</ul>
</li>
</ol>
<ul>
<li>时间复杂度：每天只有两种状态，所以时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：我们需要申请<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>来存储状态信息</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">//记录每一天的最大利润</span></span><br><span class="line">        <span class="type">int</span>[][] profit = <span class="keyword">new</span> <span class="title class_">int</span>[days][<span class="number">2</span>];</span><br><span class="line">        profit[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line">        profit[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; days; i++) &#123;</span><br><span class="line">            profit[i][<span class="number">0</span>] = max(profit[i-<span class="number">1</span>][<span class="number">0</span>],profit[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            profit[i][<span class="number">1</span>] = max(profit[i-<span class="number">1</span>][<span class="number">1</span>],profit[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//最后一天肯定是手里没有股票的时候，利润才会最大，</span></span><br><span class="line">   		 	<span class="comment">//只需要返回dp[length - 1][0]即可</span></span><br><span class="line">        <span class="keyword">return</span> profit[days-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>这道题可以将每天的价格趋势画成一张图</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8aqljjgbmj30y10u0wg5.jpg" alt="" /></p>
<p>我们不难发现，最后获得的利润最大值就是所有上升区间的和。</p>
<p>但是我在思考这道问题的时候会有疑惑，有如下这种情况：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8aqng6o7ej30zp0qwwfr.jpg" alt="" /></p>
<p>即一次到位的绿色部分的高度大于中间有转折的黄色部分，对应着时机情况就是：先涨，但跌了一些，最后又涨，一直拿在手里不卖比见涨就买，见跌就卖的利润更高。但通过图示可以很清晰的发现，黄色部分的长度是肯定大于绿色部分的，因此这道题可以等价于：<strong>求上升区间的累加和</strong>，其实这也有一些贪心算法的思想在里面。</p>
<ul>
<li>时间复杂度：我们只需要遍历一遍数组，求出所有上升区间累加和即可，因此时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：在这种方法里我们不需要申请辅助空间，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (days == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> profit; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; days; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dif</span> <span class="operator">=</span> prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dif &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                profit = profit + dif;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机2</title>
    <url>/2023/01/06/%E7%AE%97%E6%B3%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2/</url>
    <content><![CDATA[<h1 id="买卖股票的最佳时机2"><a class="markdownIt-Anchor" href="#买卖股票的最佳时机2"></a> 买卖股票的最佳时机2</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给定一个数组<code>prices</code>，它的第<em>i</em>个元素<code>prices[i]</code>表示一支给定股票第<em>i</em>天的价格。你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0。</p>
<p>这道题和<a href="https://keveinkk.github.io/2022/11/23/%E7%AE%97%E6%B3%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/">买卖股票的最佳时机1</a>的区别在于：我们只能买卖股票一次。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>相较于买卖股票的最佳时机1来说，时机1允许我们多次买入买出，那我们只要在涨价时卖出即可，也就是我们只用统计价格波动图里所有上升区间的和。而这个题只允许我们买入和卖出一次，那我们就只能在价格最低点买入，在价格最高点卖出。因此这道题就可以转换为如何寻找这个数组里的最大值和最小值，并且这个最大值要出现在最小值后面。</p>
<p>我的第一个想法就是暴力枚举法，从数组第一个数字开始，遍历后面所有的数，找到里面最大的数字，那么就可以求出在第一天买入股票时的最大利润；然后再从第二个数开始向后遍历，找到最大的树，那么就可以求出在第二天买入时的最大利润…</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> prices[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; prices.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[j] &gt; high) high = prices[j];</span><br><span class="line">            &#125;</span><br><span class="line">            profit = Math.max(profit,high - prices[i];)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>方法一显然太慢了。方法一中的最外层循环其实就是在说：遍历到<code>i=1</code>那我们就假定最小的数是<code>prices[1]</code>，遍历到<code>i=5</code>那我们就假定最小的数是<code>prices[5]</code>。所以说，如果我们能通过一次遍历，既找到整个数组中的最小值，又能找到整个数组中的最大值，且最大值出现在最小值之后，我们就能大大优化这个方法。</p>
<p>这里我们采用动态规划的思想。我们用一个数组来记录最小值，<code>min[i]=k</code>表示数组<code>nums</code>中第<em>i</em>个数之前最小的数是<em>k</em>。那么一个数组中的最小值的状态转移方程是：$min[i]=\left {min[i-1],nums[i]  \right } $</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，我们只用遍历一遍就可以找到数组中的最小值。而数组中的最大值可以不停的用当前遍历到的值减去这个数之前的最小值，然后不停的更新最大值，最后返回最大的最大值</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，我们用一个数组来记录每个数之前的最小值</li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] lowPrice = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length];</span><br><span class="line">        lowPrice[<span class="number">0</span>] = prices[<span class="number">0</span>];<span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i ++)&#123;</span><br><span class="line">            lowPrice[i] = Math.min(lowPrice[i - <span class="number">1</span>], prices[i]);</span><br><span class="line">            profit = Math.max(prices[i] - lowPrice[i],profit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3>
<p>其实方法二还可以继续优化，我们没有必要存储每个数之前的最小值，我们只用记录当前数之前的最小值即可，因为最大值的计算只会用到当前数的最小值。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lowPrice</span> <span class="operator">=</span> prices[<span class="number">0</span>];<span class="comment">//只用一个变量来存储记录当前数的最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; lowPrice) &#123;</span><br><span class="line">                lowPrice = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                profit = Math.max(profit,prices[i]-lowPrice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最大深度</title>
    <url>/2022/12/24/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="二叉树的最大深度"><a class="markdownIt-Anchor" href="#二叉树的最大深度"></a> 二叉树的最大深度</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<h2 id="方法一深度优先搜索"><a class="markdownIt-Anchor" href="#方法一深度优先搜索"></a> 方法一：深度优先搜索</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>递归的方法是最容易想到的，我们很容易得到关于二叉树最大深度的递归公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>=</mo><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mn>1</mn><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">maxDepth=Max(left,1ight)+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>指的是节点左右子树的深度。这里的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span>代表的是当前节点的高度。递归</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，每个节点都会被访问一遍</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(height)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">height</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>指的是树的高度</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二广度优先搜索"><a class="markdownIt-Anchor" href="#方法二广度优先搜索"></a> 方法二：广度优先搜索</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>我们也可以用广度优先搜索，也就是一层一层的遍历的方法来实现这道题：当我们遍历完一层时，那么树的高度就增加一个。</p>
<p>我在之前就知道可以用队列来实现树的广度优先遍历，但这次是自己第一次来动手实现这个功能，我不太清楚如何来遍历一层：是每遍历一层就新申请一个队列吗？每遍历到一个节点，就把它的左右孩子放到下一层新的队列里，或者是别的方法。</p>
<p>我们肯定不需要每遍历一层就申请一个新的队列。我们可以设置一个变量<code>sizeOfQue</code>来记录每一层节点的个数：所有的一层的节点都添入队列时，我们就能统计到这一层有多少个节点，每出一个节点<code>sizeOfQue</code>数就减少一个，同时这个节点的左右孩子都入队。当<code>sizeOfQue</code>为<em>0</em>时，就代表上一层所有的节点都已经出队，队伍里剩下的都是下一层的节点，那我们统计一下队伍里有多少个节点，就又可以继续下去...</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，我们需要把所有节点都访问一遍</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，我们需要设置一个队列来存储一层的节点，最坏情况下所有的节点都会在一层（除了根节点）</li>
</ul>
<h3 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> Queue</h3>
<h4 id="queue接口"><a class="markdownIt-Anchor" href="#queue接口"></a> Queue接口</h4>
<p>然后由于要用到队列的特性，我们就考虑使用Java中队列的实现类。</p>
<p><code>Queue</code>接口在<code>java.util</code>包下，它继承了<code>Collection</code>接口，它的特性自然不用说：只能在队尾入队，对头出队，并且是先进先出。</p>
<blockquote>
<p>The Queue interface is present in java.utilcessed in FIFO(First In First Out) order. It is an ordered list of objects with its use limited to inserting elements at the end of the list and deleting elements from the start of the list, (i.e.), it follows the <strong>FIFO</strong> or the First-In-First-Out principle.</p>
</blockquote>
<h4 id="queue中常用的方法"><a class="markdownIt-Anchor" href="#queue中常用的方法"></a> Queue中常用的方法</h4>
<h5 id="boolean-adde-e"><a class="markdownIt-Anchor" href="#boolean-adde-e"></a> <code>boolean add(E e)</code></h5>
<blockquote>
<p>Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning <code>true</code> upon success and throwing an <code>IllegalStateException</code> if no space is currently available.</p>
</blockquote>
<ul>
<li>添加一个元素到队列中</li>
<li>如果添加成功返回<code>true</code>，当空间不足添加失败时抛出异常，但不会返回<code>false</code></li>
</ul>
<h5 id="boolean-offere-e"><a class="markdownIt-Anchor" href="#boolean-offere-e"></a> <code>boolean offer(E e)</code></h5>
<blockquote>
<p>Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions. When using a capacity-restricted queue, this method is generally preferable to <code>add(E)</code>, which can fail to insert an element only by throwing an exception.</p>
</blockquote>
<ul>
<li>添加元素时一般更推荐使用该方法
<ul>
<li><code>add()</code>方法在添加失败时只会报错，不会返回异常</li>
<li><code>offer()</code>方法添加成功返回<code>true</code>，添加失败返回<code>false</code></li>
</ul>
</li>
</ul>
<h5 id="e-remove"><a class="markdownIt-Anchor" href="#e-remove"></a> <code>E remove()</code></h5>
<blockquote>
<p>Retrieves and removes the head of this queue. This method differs from <code>poll</code>only in that it throws an exception if this queue is empty.</p>
</blockquote>
<ul>
<li>移除对头的元素</li>
<li>当队伍为空时，会返回异常</li>
</ul>
<h5 id="e-poll"><a class="markdownIt-Anchor" href="#e-poll"></a> <code>E poll()</code></h5>
<blockquote>
<p>Retrieves and removes the head of this queue, or returns <code>null</code> if this queue is empty.</p>
</blockquote>
<ul>
<li>更推荐使用这个方法来移除对头的元素</li>
<li>移除成功返回该元素，移除失败返回<code>null</code></li>
</ul>
<h5 id="e-peek"><a class="markdownIt-Anchor" href="#e-peek"></a> <code>E peek()</code></h5>
<blockquote>
<p>Retrieves, but does not remove, the head of this queue, or returns <code>null</code> if this queue is empty.</p>
</blockquote>
<ul>
<li>返回对头的元素，但对对头的元素不做任何操作</li>
<li>当队伍为空时，返回<code>null</code></li>
</ul>
<h4 id="queue的实现类"><a class="markdownIt-Anchor" href="#queue的实现类"></a> Queue的实现类</h4>
<p>作为一个接口，肯定是有具体的类来实现这个接口，在Java中分别有<u><code>PriorityBlockingQueue</code></u>、 <u><code>PriorityQueue</code></u>和<u><code>LinkList</code></u>两个类来实现队列的接口，其中后两个是非线程安全的。</p>
<ul>
<li><code>PriorityQueue</code>是优先级队列，它不是FIFO的，而是根据元素的优先级，优先级高的或者低的先出队列</li>
<li>我们一般都使用<code>LinkList</code>来具体实现队列</li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">dept</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        queue.offer(root);<span class="comment">//添加跟节点，需要对根节点进行判断，如果根节点为空则无法添加</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sizeOfQue</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span> (sizeOfQue &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();<span class="comment">//弹出对头节点</span></span><br><span class="line">              	<span class="comment">//入队之前需要进行判断</span></span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) queue.offer(temp.right);</span><br><span class="line">                sizeOfQue --;</span><br><span class="line">            &#125;</span><br><span class="line">            dept ++;<span class="comment">//遍历完一层，深度加一</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表中的节点</title>
    <url>/2022/12/14/%E7%AE%97%E6%B3%95/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="删除链表中的节点"><a class="markdownIt-Anchor" href="#删除链表中的节点"></a> 删除链表中的节点</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>有一个单链表的<code>head</code>，我们想删除它其中的一个节点<code>node</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>经典的删除一个节点方法是找到这个节点<code>node</code>的前驱节点<code>pre</code>，然后修改<code>pre</code>的指针来做到对<code>node</code>的删除。但是这道题没有给我们这个链表的头节点，并且这个还是一个单链表，所以我们无法做到查找到这个节点的前驱。</p>
<p>那我们换一个角度想想，如果不能让自己消失，那我们不妨让自己变成其他节点，然后再删除那个节点</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(ListNode node)</span> &#123;</span><br><span class="line">        node.val = node.next.val;<span class="comment">//让自己变成后一个节点</span></span><br><span class="line">        node.next = node.next.next;<span class="comment">//删除后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>加一</title>
    <url>/2022/11/24/%E7%AE%97%E6%B3%95/%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h1 id="加一"><a class="markdownIt-Anchor" href="#加一"></a> 加一</h1>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数0之外，这个整数不会以零开头。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字123，对其加一，输出124。</span><br><span class="line"></span><br><span class="line">输入：digits = [9]</span><br><span class="line">输出：[1，0]</span><br><span class="line">解释：输入数组表示数字9，对其加一，输出10。</span><br></pre></td></tr></table></figure>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>这道题在模拟对数字进行加一的运算结果，如果整个<code>digits</code>数组中末尾没有9的话其实非常简单，直接将<code>digits[len-1]</code>最后这个数修改一下，然后返回<code>digits</code>即可；如果数组中其他位置出现了9的话其实也没有影响，因为后面不进位的话前面也不会有改变。我们着重需要考虑的是末尾有9，或者说末尾有连续个9的情况。</p>
<ol>
<li>如果末尾有若干个9，但第一个数字不是，例如[1,2,9,9]。那么将最后一位设置成0，然后向前面进位，如果还是9，则将倒数第二位再设置成0，再进位...这样最后的结果和<code>digits</code>数组的长度是一样的，因为第一位不会再进位了</li>
<li>如果全部是9，即第一位数字也是9，例如[9，9]。那么按照上面的步骤，最后<code>digits</code>的结果就是[10,0,0]，我们首先不得不申请一个大一点的数组res，将digits后面的几位复制给<code>res</code>，然后再将<code>res</code>的第一位设置成1，第二位设置成0即可。</li>
</ol>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，这种方法只用将<code>digits</code>数组遍历一遍即可结束</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，这种方法由于需要复制数组，所以需要申请额外的辅助空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> digits.length;</span><br><span class="line">				<span class="comment">//如果最后一位是9</span></span><br><span class="line">      	<span class="comment">//分两种情况：首位不是9和首位是9</span></span><br><span class="line">        <span class="keyword">if</span> (digits[len - <span class="number">1</span>] == <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len-<span class="number">1</span>;</span><br><span class="line">            digits[i] ++;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; digits[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">                i --;<span class="comment">//指针前移</span></span><br><span class="line">                digits[i] ++;<span class="comment">//进位</span></span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//首位是9</span></span><br><span class="line">          	<span class="comment">//则需要申请一个更大的空间</span></span><br><span class="line">            <span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line">                System.arraycopy(digits,<span class="number">1</span>,res,<span class="number">2</span>,len-<span class="number">1</span>);</span><br><span class="line">                res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            <span class="comment">//首位不是9</span></span><br><span class="line">            <span class="comment">//则只用修改最后一位</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">                System.arraycopy(digits,<span class="number">0</span>,res,<span class="number">0</span>,len);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果最后一位不是9</span></span><br><span class="line">        <span class="comment">//直接复制整个数组，然后修改最后一位即可</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">            System.arraycopy(digits,<span class="number">0</span>,res,<span class="number">0</span>,len);</span><br><span class="line">            res[len-<span class="number">1</span>] = res[len-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>在方法一中，由于我一直采用先申请一个辅助空间，然后对辅助空间进行复制、修改操作，这样导致我的空间复杂度在任何一种情况下都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。但其实，我完全可以调整思路，直接对<code>digits</code>进行操作，然后最后返回<code>digits</code>；除非万不得已，整个<code>digits</code>数组全部都是9，这样我再申请一个更大的空间去存放数据。</p>
<p>同时，对两种情况分辨的标准也可以优化。在方法一中，我是根据末尾是否为9这个标准进行分类。但我们可以换个思路，我们可以看看在进行加一操作后结果是否为0。这二者的区别有点类似<code>while</code>和<code>do( )while</code>：方法一中我们需要先判断，如果是不同的情况，则需要进入不同的<code>while</code>循环，这样代码很长；然而方法二中，我们先进行操作，如果末位加一操作后不为0，那么直接可以跳出循环，这样只用写一种情况下的循环体。</p>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> digits.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          	<span class="comment">//直接先进行加一操作</span></span><br><span class="line">            digits[i] = (digits[i] + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">          	<span class="comment">//这里只用针对当前这个一个数是否为0进行判断，并不只考虑最后一个数</span></span><br><span class="line">          	<span class="comment">//如果这个数不为0，则代表没有发生进位，那这个数前面的都不用改了</span></span><br><span class="line">          	<span class="comment">//此时，加一操作之后的结果已经在数组中修改了，那么直接返回digits即可</span></span><br><span class="line">            <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//如果这个数等于0</span></span><br><span class="line">          	<span class="comment">//则会发生进位现象，前面的数也需要+1</span></span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//循环完全退出则代表digits中原来全部为9</span></span><br><span class="line">      	<span class="comment">//此时再申请新的数组空间</span></span><br><span class="line">        digits = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2023/01/05/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3>
<ul>
<li>动态规划Dynamic Programming，通过把原问题分解成相对简单的子问题的方式来解决复杂问题。</li>
<li>通常具有：<strong>重叠子问题</strong>和<strong>最优子结构性质</strong>
<ol>
<li>重叠子问题：同一个子问题在被重复计算
<ul>
<li>例如：计算<code>f(n)</code>时会用到<code>f(1)</code>的计算结果，计算<code>f(n-1)</code>时还会用到<code>f(1)</code>的计算结果</li>
</ul>
</li>
<li>最优子结构性质：可以从子问题的最优结果推出更大规模问题的最优结果
<ul>
<li>例如：已知全校每个班的最高成绩，现在求全校的最高成绩，那么全校的最高成绩肯定是来自于每个班的最高成绩中</li>
</ul>
</li>
</ol>
</li>
<li>换句话说
<ul>
<li>对于给定的问题，我们将其拆分成一个一个小的子问题，然后一一解决这些子问题</li>
<li>我们将这些子问题的结果保存下来，以减少重复计算</li>
<li>然后根据子问题进行反推，得出原问题</li>
</ul>
</li>
</ul>
<h3 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h3>
<ul>
<li>动态规划的核心思想就是
<ul>
<li><strong>拆分子问题，并且记录子问题的解</strong></li>
</ul>
</li>
<li>具体的解题步骤如下：
<ol>
<li>首先用暴力枚举的方法找到解决这个问题的思路</li>
<li>找规律，确定最优子结构</li>
<li>确定边界条件</li>
<li>写出状态转移方程</li>
</ol>
</li>
</ul>
<h4 id="暴力枚举"><a class="markdownIt-Anchor" href="#暴力枚举"></a> 暴力枚举</h4>
<ul>
<li>首先针对一个问题，先用最朴素的暴力方法枚举出所有的情况，然后求出最后的解</li>
</ul>
<h4 id="确定最优子结构"><a class="markdownIt-Anchor" href="#确定最优子结构"></a> 确定最优子结构</h4>
<ul>
<li>根据暴力枚举出来的所有情况，我们找到其中的规律</li>
<li>看一看后面的解是如何通过前面的解得出的</li>
</ul>
<h4 id="确定边界条件"><a class="markdownIt-Anchor" href="#确定边界条件"></a> 确定边界条件</h4>
<ul>
<li>根据前面找的的最优子结构的规律，这个规律肯定不适用于所有的情况</li>
<li>一般初始条件都需要我们手动的确立</li>
</ul>
<h4 id="写出状态转移方程"><a class="markdownIt-Anchor" href="#写出状态转移方程"></a> 写出状态转移方程</h4>
<ul>
<li>有了前面的最优子结构（规律）以及边界条件，我们就能写出状态转移方程</li>
<li>这里的状态转移指的就是如何从一个子问题的解求出（转移到）另一个问题的解</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <url>/2022/12/15/%E7%AE%97%E6%B3%95/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#删除链表的倒数第n个节点"></a> 删除链表的倒数第N个节点</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给你一个链表，删除链表的倒数第<code>n</code>个结点，并且返回链表的头结点。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>我最直接的想法是通过一次遍历，先确定这个链表一共有多少个节点，这样有了总的节点数以及倒数的个数，我们就能确定这个要被删除的节点在链表中是第几个元素。然后再通过一次遍历，找到这个要删除节点的前驱，然后完成删除操作。</p>
<p>这个想法虽然很容易想到，但是在我实现的过程中还是遇到了一些小麻烦，这些麻烦都与循环有关。</p>
<ul>
<li>如何确定链表中节点的个数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样得到的num其实是节点个数-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (head.next != <span class="literal">null</span>)&#123;</span><br><span class="line">    num ++;</span><br><span class="line">    head = head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这样得到的num才是真的节点个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (head.next != <span class="literal">null</span>)&#123;</span><br><span class="line">    num ++;</span><br><span class="line">    head = head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在已知要删除的节点下标是<code>toRemove</code>（链表下标从1开始）的情况下，寻找其前一个下标</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="comment">//node一共移动了toRemove-1次，循环结束时才指向要删除节点的前驱</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; toRemove-<span class="number">1</span>; i++)&#123;</span><br><span class="line">		node = node.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于头节点的特殊处理
<ul>
<li>如果要删除的是头节点，那么我们不能按照<code>node.next = node.next.next</code>的方法来处理，我们需要进行单独判断</li>
<li>返回<code>return head.next</code></li>
</ul>
</li>
<li>时间复杂度：我们需要进行两次遍历，第一次遍历确定整个链表的的节点个数，第二次用于删除节点，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//记录链表中节点的个数</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (node.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            sz ++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = head;</span><br><span class="line">        <span class="comment">//删除头节点，直接移动头指针</span></span><br><span class="line">        <span class="keyword">if</span>(sz == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">toRemove</span> <span class="operator">=</span> sz - n + <span class="number">1</span>;<span class="comment">//确定要删除节点的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; toRemove - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>方法一中可以引入哑节点<em>dummy node</em>，也就是头节点，来省去对头节点进行特殊的判断。</p>
<p>引入哑节点后对节点下标的判断也需要进一步考虑。</p>
<p>我发现，其实可以大致先写出循环终止的条件，不妨假设是<code>i &lt; n</code>，我们可以输入一个很普遍的例子，然后通过程序的输出结果来修改这个条件。如果删除了<code>toRemove</code>节点的后一个节点，代表我们找的前驱多向后走了一个，那我们就可以修改条件为<code>i &lt; n-1</code>；如果删除的是前一个节点，代表我们少走了一个，那我们就可以再修改条件为<code>i &lt; n+1</code>。所以在写程序的时候不必过多纠结于这些细节，可以在后面慢慢调整。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//引入哑节点哑节点（dummy node）来优化对头节点的判断</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);<span class="comment">//哑节点中数据存储0，next指针指向头节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> getLen(dummy);<span class="comment">//计算包含哑节点在内的链表的节点数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">toRemove</span> <span class="operator">=</span> len - n + <span class="number">1</span>;<span class="comment">//要删除节点的下标</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;<span class="comment">//从哑节点开始向后遍历</span></span><br><span class="line">        <span class="comment">//循环结束后cur指向待删除元素的前一个元素</span></span><br><span class="line">      	<span class="comment">//由于引入了哑节点所以需要再减去1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; toRemove-<span class="number">2</span>; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLen</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3>
<p>我们也可以在不预处理出链表的长度，以及使用常数空间的前提下解决本题。</p>
<p>由于我们需要找到倒数第n个节点，那我们设置两个指针first和second，让first指针先遍历n个节点，此时second指针还指向dummy node，这样它们之间就相差了n个节点（这个值其实也不重要，对于循环条件的调整可以留到程序编写后的调试环节）。然后再同时让两个指针向后遍历，当first指针到链表的末尾时，那么second指针就应该指向的是需要被删除的节点。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，这种方法只需要遍历一遍链表</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> dummy, second = dummy;<span class="comment">//两个指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//first指向n，second指向0</span></span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//first指向链表尾部时，second和它的差距是n</span></span><br><span class="line">        <span class="keyword">while</span> (first.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>两个数组的交集</title>
    <url>/2022/11/23/%E7%AE%97%E6%B3%95/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<h1 id="两个数组的交集"><a class="markdownIt-Anchor" href="#两个数组的交集"></a> 两个数组的交集</h1>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给你两个整数数组<code>nums1</code>和<code>nums2</code>，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<p>由于我还不会调用Java中的哈希函数相关的内容，所以这道题我只能用一种方法来解决。</p>
<p>我们可以先让两个数组是有序的，通过使用双指针的方法得到两个数组的交集。</p>
<ol>
<li>首先对两个数组进行排序，然后使用两个指针遍历两个数组</li>
<li>初始时，两个指针分别指向两个数组的头部</li>
<li>每次比较两个指针指向的两个数组中的数字
<ul>
<li>如果两个数字不相等，则将指向较小数字的指针右移一位</li>
<li>如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位</li>
</ul>
</li>
<li>当至少有一个指针超出数组范围时，遍历结束</li>
</ol>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>+</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogm+nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中<code>m</code>和<code>n</code>是两个数组的长度。我们首先通过调用系统的排序算法来对数组排序，这个步骤的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>+</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogm+nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，然后我们需要遍历两个数组，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，那么总的时间符复杂度就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>+</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogm+nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>我们需要一个辅助空间来存储重复的数字信息。注意，我们只用申请两个数组中较短的那么大的数组，因为极限情况就是短的数组全部和长的数组重复，即使这样也不过是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，所以不用更大的空间</li>
</ul>
<h3 id="知识点回顾"><a class="markdownIt-Anchor" href="#知识点回顾"></a> 知识点回顾</h3>
<ul>
<li>
<p>数组的拷贝<sup><a href="#ref1">1</a></sup></p>
<ul>
<li>通过<code>System.arraycopy()</code>方法来实现数组的拷贝</li>
<li><code>System.arraycopy()</code> 方法是本地的方法，不需要导入任何包</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos, Object dest, <span class="type">int</span> desPos, <span class="type">int</span> length)</span></span><br><span class="line"><span class="comment">//形参列表的含义</span></span><br><span class="line"><span class="comment">//（原数组，原数组的开始位置，目标数组，目标数组的开始位置，拷贝元素个数）</span></span><br><span class="line"><span class="comment">//其中目标数组是要拷贝到的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数组的排序<sup><a href="#ref1">2</a></sup></p>
<ul>
<li>通过<code>Arrays.sort()</code>方法实现数组的排序</li>
<li><code>Arrays.sort(T[] a)</code>: 对指定的 T 型数组按数字升序排序</li>
<li><code>Arrays.sort(T[] a, int formIndex, int toIndex)</code>: 对指定的 T 型数组在下标 [formIndex, toIndex] 之间排序</li>
<li><code>Arrays.sort(T[] a, Comparator&lt;? supre T&gt; c)</code>: 根据比较器产生的顺序对指定对象数组进行排序</li>
<li><code>Arrasy.sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c</code>): …</li>
</ul>
</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当两个数组都有序时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> nums2.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> len1 &lt; len2 ? len1 : len2;<span class="comment">//取较小值</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;<span class="comment">//用于遍历两个数组的指针;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于遍历res指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class="line">            <span class="comment">//不等，则小的移动</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j ++;</span><br><span class="line">            <span class="comment">//相等，则都移动</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</span><br><span class="line">                res[k] = nums1[i];</span><br><span class="line">                k ++;</span><br><span class="line">                i ++;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//拷贝前面有记录的部分</span></span><br><span class="line">      	<span class="comment">//注意不能是只拷贝非0的部分，因为可能nums1和nums2中有0元素重复</span></span><br><span class="line">        <span class="type">int</span>[] fianl = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        System.arraycopy(res,<span class="number">0</span>,fianl,<span class="number">0</span>,k);</span><br><span class="line">        <span class="keyword">return</span> fianl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span name = "ref1"><a href="https://keveinkk.github.io/2022/11/08/%E7%AE%97%E6%B3%95/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/">https://keveinkk.github.io/2022/11/08/算法/旋转数组/</a></span></p>
<p><span name = "ref2"><a href="https://keveinkk.github.io/2022/11/07/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%BE%83%E5%99%A8%20&amp;%20%E5%AF%B9%E6%95%B0%E5%99%A8/">https://keveinkk.github.io/2022/11/07/算法/比较器 &amp; 对数器/</a></span></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2022/12/19/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给你单链表的头节点<code>head</code>，请你反转链表，并返回反转后的链表</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>我的第一个想法是借助栈先进后出的特点，让链表中所有的元素都先入栈，然后再依次出栈，从而达到反转的效果</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3>
<ul>
<li>
<p>遍历链表的技巧</p>
<ul>
<li>平时我已经习惯了用<code>while(head.next!=null)</code>来遍历链表，但其实当循环结束的时候，<code>head</code>指针指向的其实是倒数第二个节点，而非真正的遍历完了整个链表</li>
<li>想要遍历完整个链表需要用<code>while(head!=null)</code></li>
</ul>
</li>
<li>
<p>链表中插入节点的方法</p>
<ul>
<li>在插入一个新的节点到链表中时，如果稍微操作不当就容易引发<strong>空指针异常</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次向temp指针指向的位置插入新元素</span></span><br><span class="line"><span class="comment">//由于每次temp都已经指向了一个元素，即temp不是一个空指针，然而在插入完元素后temp要后移，而temp.next是一个空指针</span></span><br><span class="line"><span class="comment">//那么我们就先填充temp.next，然后再后移</span></span><br><span class="line"><span class="keyword">while</span> (!myStack.isEmpty())&#123;</span><br><span class="line">    temp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(myStack.pop());<span class="comment">//先申请后面的节点</span></span><br><span class="line">    temp = temp.next;<span class="comment">//再进行移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用数组实现栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] listNodes;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> index;</span><br><span class="line">  	<span class="comment">//构造方法来初始化数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        listNodes = <span class="keyword">new</span> <span class="title class_">ListNode</span>[num];</span><br><span class="line">        index = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listNodes[index--].val;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">        listNodes[++index] = node;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      	<span class="comment">//获取链表的长度来初始化栈，当然这一步也可以省略，在前期申请一个足够大的空间即可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> getLen(head);</span><br><span class="line">        <span class="type">MyStack</span> <span class="variable">myStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStack</span>(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            myStack.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reverList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(myStack.pop());<span class="comment">//反转链表的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> reverList;</span><br><span class="line">        <span class="keyword">while</span> (!myStack.isEmpty())&#123;</span><br><span class="line">            temp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(myStack.pop());<span class="comment">//先申请后面的节点</span></span><br><span class="line">            temp = temp.next;<span class="comment">//再进行移动</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLen</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            len ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>可以用迭代的方法来处理这道题，我们可以用一遍循环就能反转整个链表。一个单链表每个节点的<code>next</code>指针都指向其后面的那个节点，那其实我们只用修改每个next<code>指针</code>，让它指向其前面的节点就好了。</p>
<p>在遍历链表时，将当前节点的next指针改为指向前一个节点。由于节点没有指针指向其前一个节点，因此必须事先存储其前一个节点。在更改next指针之前，还需要存储后一个节点，因为还要不停的向后遍历。最后返回整个链表的最后一个节点即可。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next ==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">      	<span class="comment">//三个指针分别指向前一个元素、当前元素，以及后一个元素</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>,cur = head,next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;<span class="comment">//遍历完整个链表</span></span><br><span class="line">            next = cur.next;<span class="comment">//先记录后一个元素</span></span><br><span class="line">            cur.next = pre;<span class="comment">//修改next指针</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;<span class="comment">//再修改下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;<span class="comment">//此时不是返回cur，因为cur==null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3>
<p>有了方法二的启示，我们既然可以只修改指针就实现链表的反转，那我们当然也可以做到只修改值来实现同样的效果。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reverseList</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">          	<span class="comment">//每遍历到一个节点，就记录下它的值，把它插入到新的链表中</span></span><br><span class="line">          	<span class="comment">//这个节点指向链表中的前一个节点，而非后面的空节点，这样就实现了链表的反转</span></span><br><span class="line">            reverseList = <span class="keyword">new</span> <span class="title class_">ListNode</span>(cur.val,reverseList);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串中的单词</title>
    <url>/2022/11/23/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="反转字符串中的单词"><a class="markdownIt-Anchor" href="#反转字符串中的单词"></a> 反转字符串中的单词</h1>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给定一个字符串 <code>s</code> ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h3>
<ul>
<li>
<p>在Java中处理字符串常用的有三种类型：<code>String</code>、<code>StringBuffer</code>以及<code>StringBuilder</code>。这里我们着重介绍前两种</p>
<ol>
<li><code>String</code>和<code>StringBuffer</code>都是由final所修饰的，无法再被继承</li>
<li>它们的主要区别是：<code>String</code>的长度和内容是不可变的，<code>StringBuffer</code>的长度和内容是可变的</li>
<li><code>String</code>是不可变的对象，每次对<code>String</code>类进行改变时都会生成一个新的<code>String</code>类对象，然后将引用指向新的对象。因此如果需要改变字符串的长度，我们通常不会使用<code>String</code>类</li>
<li>使用<code>StringBuffer</code>时，我们每次都会对<code>StringBuffer</code>对象本身进行操作，而不会生成一个新的对象。当需要经常需要修改字符串时，我们推荐使用<code>StringBuffer</code>类</li>
</ol>
</li>
<li>
<p>遍历字符串<code>String</code>的方式</p>
<ol>
<li>
<p>调用<code>String</code>类的<code>toCharArray()</code>方法，先将字符串转变成一个字符数组，然后遍历数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;This is Kevin&#x27;s Blog&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] arr = str.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>调用<code>String</code>类的<code>charAt(int i)</code>方法，在遍历字符串的过程中，每扫描到下标为<code>i</code>的一个字符就将它提取出来变成字符类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;This is Kevin&#x27;s Blog&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length()l i++)&#123;</span><br><span class="line">  System.out.print(str.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，获得字符串的长度时需要使用<code>String</code>类的<code>length()</code>方法，而获得数组的长度时可以直接方法数组中的<code>length</code>属性</p>
</li>
<li>
<p>调用<code>String</code>类的<code>subString(i,i+1)</code>方法，将字符串中的每个字符按照子串的形式提取出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;This is Kevin&#x27;s Blog&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length()l i++)&#123;</span><br><span class="line">  System.out.print(str.subString(i,i+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>s = str.substring(int beginIndex)</code>：将<code>str</code>从首字母起长度为<code>beginIndex</code>的字符串截取下来，将剩余的部分赋值给s</li>
<li><code>s = str.substring(int beginIndex,int endIndex)</code>：将str中下标从beginIndex到<code>endIndex</code>之间的字符串截取下来给s</li>
</ul>
</li>
</ol>
</li>
<li>
<p><code>StringBuffer</code>常用操作</p>
<ol>
<li>
<p><code>StringBuffer append(char c)</code>：添加字符<code>c</code>到<code>StringBuffer</code>对象中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">str.append(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"><span class="comment">//str = &quot;abcd&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>StringBuffer deleteCharAt(int index)</code>：移除下标为<code>index</code>的字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">str.deleteCharAt(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//str = &quot;ab&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>StringBuffer delete(int start,int end)</code>：移除下标从<code>start</code>到<code>end</code>之间的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line">str.delete(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//str = &quot;def&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>String toString()</code>：将<code>StringBuffer</code>转换成<code>String</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> str.toString();</span><br><span class="line"><span class="comment">//s = &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>StringBuffer reverse()</code>：将此<code>StringBuffer</code>逆序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">str.reverse();</span><br><span class="line"><span class="comment">//str = &quot;cba&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>开辟一个新字符串<code>res</code>。扫描原来的字符串s，每扫描到一个新的单词，就暂停扫描，先将扫描到的单词逆序放到<code>res</code>，然后再继续向后扫描。为了达到这个效果我们需要两个指针，一个指针控制字符串<code>s</code>的扫描，另一个指针记录每个单词起始的位置。由于我们需要不停的增加<code>res</code>中的内容，所以考虑申请<code>StringBuffer</code>类型的<code>res</code>，每次添加新的单词时调用<code>append(char c)</code>方法</p>
<ul>
<li>时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，由于在Java中字符串类型是不能修改的，所以无法做到原地工作</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//申请StringBuffer类型的辅助空间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于遍历整个字符串</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">//不采用for循环是因为循环控制语句不好设置，在扫描s字符串时，有很多情况下都会导致继续向前扫描</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">startWord</span> <span class="operator">=</span> i;<span class="comment">//一个指向单词的首字母的指针，记录下每个单词的起始位置</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//在while循环中，如果使用短路与的判断的话，优先将更重要的条件放到第一个表达式是位置，这样更安全，避免index溢出</span></span><br><span class="line">            <span class="comment">//如果扫描到的是正常的字母，则继续向后扫描，尝试找到一整个单词</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳出循环代表一个单词结束，或者遍历完了整个数组</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>;<span class="comment">//记录下一个单词最后的字母下标</span></span><br><span class="line">            <span class="comment">//不需要再设置一个逆序函数，让整个单词逆序后再加入res</span></span><br><span class="line">          	<span class="comment">//直接从后向前扫描，将后面的字母放到前面去即可</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= startWord)&#123;</span><br><span class="line">                res.append(s.charAt(j--));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//可能一个单词之后有多个空格</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                res.append(<span class="string">&#x27; &#x27;</span>);<span class="comment">//每扫描到一个空格，那就加一个空格</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//由于方法的返回值类型是String，最后还需要进行一下类型转换</span></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3>
<p>调试过程我发现，在使用短路与时<code>while(i &lt; s.length() &amp;&amp; s.charAt(i) != ' ')</code>，如果将<code>s.charAt(i) != ' '</code>放在表达式1的位置，很容易编译器报错。</p>
<p>假设此时已经遍历完字符串中的最后一个字符(<code>i=s.length</code>)按照我们的设计，下一轮应该直接跳出循环。从逻辑上表达式1和表达式2的位置不是很重要，如果<code>s.charAt(i) != ' '</code>放在表达式1的位置，<code>i=s.length</code>，那么程序会先判断<code>s.charAt(i) != ' '</code>，在判断过程中就会发生下标越界的错误。但是如果<code>i &lt; s.length()</code> 放在表达式1的位置，在判断过程中不会报错，而会根据表达式结果直接跳出循环！</p>
<p>因此在之后设计下标的逻辑判断时，优先判断下标关系！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序生序链表</title>
    <url>/2022/12/20/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%94%9F%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="合并两个有序生序链表"><a class="markdownIt-Anchor" href="#合并两个有序生序链表"></a> 合并两个有序生序链表</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>将两个升序链表合并为一个新的<strong>升序</strong>链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<h2 id="方法一迭代"><a class="markdownIt-Anchor" href="#方法一迭代"></a> 方法一：迭代</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>我觉得合并两个链表的过程有点类似归并排序，所以我的第一个思路就是用类似归并排序的方法去实现这道题。</p>
<p>我们逐一的比较<code>list1</code>和<code>list2</code>中的每一个元素，哪个链表中的节点值更小，我们就把它加入到我们最后的结果链表中。不妨假设此时<code>list1</code>链表中指针指向的节点值更小，那么就把这个值加入到最后的链表<code>listNode</code>中，然后list1链表的指针后移，同时<code>listNode</code>指针也后移，此时再比较新的<code>list1</code>中指向的节点和<code>list2</code>中指针指向的节点...这样一直比下去，最后肯定会有一个链表会先被比较完，那这时就把剩下的链表的节点全部放到<code>listNode</code>中即可。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，其中<em>n</em>和<em>m</em>分别为两个链表的长度</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况的判断</span></span><br><span class="line">      	<span class="keyword">if</span> (list1 == <span class="literal">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span> (list2 == <span class="literal">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line">      	<span class="comment">//listNode为最后输出的链表</span></span><br><span class="line">      	<span class="comment">//确定listNode的头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">listNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt; list2.val)&#123;</span><br><span class="line">            listNode = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            listNode = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> listNode;</span><br><span class="line">      	<span class="comment">//开始比较两链表</span></span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//如果list1还没有结束，则list1剩下全部的节点都加入listNode</span></span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//同理list2</span></span><br><span class="line">        <span class="keyword">while</span> (list2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>在我第一次写的方法一种，其实代码是非常臃肿的，有好几个地方可以进行优化</p>
<ul>
<li><code>listNode</code>的头节点处理
<ul>
<li>我一直都在避免空指针异常的出现，在方法一中，我直接令<code>listNode</code>是要返回的链表的头节点
<ul>
<li>这样的设置让我不得不单独去考虑头节点的情况，这是非常耗费功夫，而且没有什么意义的</li>
</ul>
</li>
<li>其实可以设置一个<strong>哑节点</strong><code>dummy</code>，随便给它一个节点值，只要让它不为空，然后向这个哑节点后面增添新的节点
<ul>
<li>最后只用返回<code>dummy.next</code></li>
</ul>
</li>
</ul>
</li>
<li>最后剩余一个链表不为空时将整个链表添加到<code>listNode</code>的处理
<ul>
<li>之前做惯了数组相关的题目，导致我复制整个链表时还采用的是逐一节点的复制</li>
<li>但其实链表中只用修改一个节点的指针，就可以复制这个节点以及这个节点之后所有节点的值</li>
</ul>
</li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);<span class="comment">//哑节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;<span class="comment">//用于遍历的指针</span></span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//如果list1为空了，那就直接把整个list2添加到cur后，list2同理</span></span><br><span class="line">        cur.next = (list1 == <span class="literal">null</span> ? list2 : list1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三递归"><a class="markdownIt-Anchor" href="#方法三递归"></a> 方法三：递归</h2>
<h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3>
<p>我们可以递归的定义<code>merge</code>操作</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>l</mtext><mi>i</mi><mi>s</mi><mi>t</mi><mn>1</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>m</mi><mi>e</mi><mi>r</mi><mi>g</mi><mi>e</mi><mo stretchy="false">(</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mn>1</mn><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mn>2</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mn>1</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mn>2</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>l</mtext><mi>i</mi><mi>s</mi><mi>t</mi><mn>2</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>m</mi><mi>e</mi><mi>r</mi><mi>g</mi><mi>e</mi><mo stretchy="false">(</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mn>1</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mn>2</mn><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mn>1</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mn>2</mn><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{cases}
  &amp; \text list1[0] + merge(list1[1],list2[0]),   list1[0]&lt;list2[0] \\
  &amp; \text list2[0] + merge(list1[0],list2[1]),   list1[0]&lt;list2[0]
\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">l</span></span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">l</span></span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord">1</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。每次递归都会去掉<code>list1</code>或者<code>list2</code>的一个头部节点，当<code>list1</code>和<code>list2</code>中所有节点都被去掉之后，合并结束</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>。每递归一次递归深度就会加一，一共需要递归<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n+m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span>次</li>
</ul>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">null</span>)&#123;<span class="comment">//递归出口</span></span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">null</span>) &#123;<span class="comment">//递归出口</span></span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (list1.val &lt; list2.val)&#123;</span><br><span class="line">          	<span class="comment">//如果list1指向的节点值更小，那么list1节点就放在前面</span></span><br><span class="line">          	<span class="comment">//list1后面的节点继续合并</span></span><br><span class="line">            list1.next = mergeTwoLists(list1.next,list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            list2.next = mergeTwoLists(list1,list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表</title>
    <url>/2022/12/22/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="回文链表"><a class="markdownIt-Anchor" href="#回文链表"></a> 回文链表</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给你一个单链表的头节点<code>head</code>，请你判断该链表是否为回文链表。如果是，返回<code>true</code>；否则，返回<code>false</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>由于前几天做了链表反转的题目，所以我的第一思路就是将整个链表反转过来，然后依次遍历正序和逆序的两个链表，如果他们两个遍历的结果相同，那么这就是一个回文链表，否则就不是。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>3</mn><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(3N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，反转链表需要遍历一趟，然后检查回文链表需要遍历两个链表各一趟</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，选择一个合适的链表反转方法可以有效的降低空间复杂度</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//反转字符串</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head, reverse = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>)&#123;</span><br><span class="line">            reverse = <span class="keyword">new</span> <span class="title class_">ListNode</span>(temp.val, reverse);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">				<span class="comment">//遍历两个链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> head, cur2 = reverse;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1.val != cur2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>由于最近在学集合相关的内容，那我想着能不能用数组的方式来实现这道题，毕竟用数组判断回文串太简单了。</p>
<ul>
<li>时间复杂度：$O(\frac{3}{2}N) $，将链表放到数组中需要遍历一趟，然后数组采用双指针法来判断回文链表只需要遍历一半即可</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      	<span class="comment">//用ArrayList类来模拟数组</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将链表中的数据放到数组中</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            arrayList.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用双指针判断数组是否为回文链表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">front</span> <span class="operator">=</span> <span class="number">0</span>, back = arrayList.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (front &lt; back)&#123;</span><br><span class="line">            <span class="comment">//不能用!=作为循环结束条件</span></span><br><span class="line">            <span class="comment">//当数组中有偶数个元素时，两个指针是不会相遇的</span></span><br><span class="line">            <span class="keyword">if</span> (arrayList.get(front) != arrayList.get(back)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            front ++;</span><br><span class="line">            back --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3>
<p>在看了答案的讲解后，发现了一种递归的思路。递归的思路非常高级，我觉得现阶段我很难自己想出来，感觉通过这个例子，我对递归又有了更深入的理解。</p>
<p>我们先用<code>curNode</code>指针是先到尾节点，由于递归的特性再从后往前进行比较。<code>frontNode</code>是递归函数外的指针。</p>
<p><u>我们先解释一下<code>curNode</code>指针是怎么一下一下到了链表的尾节点，并且它甚至能做到在单链表的情况下返回上一个节点。我们借助递归的特性，每次递归一层，<code>curNode</code>指针就向后移动一个，那我们当然可以设置条件让<code>curNode</code>指针移动到最后一个节点。当一次递归结束，根据栈的特性，这一层递归就会作为结果返回给上一层递归，这样就实现了<code>curNode</code>指针的向前移动。</u></p>
<p>然后我们再解释一下<code>frontNode</code>指针为什么要设置成一个全局变量，因为<code>frontNode</code>指针要随着每一次递归都要向后移动一次，这一次的移动是要基于上一次的，因此它得设置静态的<code>static</code></p>
<p>在每一轮递归中若<code>curNode.val != frontNode.val</code>则返回<code>false</code>，否则返回<code>true</code>，继续下一轮判断并且<code>frontNode</code>指针后移，<code>curNode</code>指针前移</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>我们只用递归的遍历链表一遍即可。但是由于函数不停的进栈出栈，导致这个方法的时间性能其实是非常差的</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>递归的遍历深度刚好也是链表的长度</li>
</ul>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode frontNode;<span class="comment">//静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        frontNode = head;</span><br><span class="line">        <span class="keyword">return</span> recursiveCheck(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">recursiveCheck</span><span class="params">(ListNode curNode)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//不停的使cur指针向后移动，一直移动到最后一个节点</span></span><br><span class="line">            <span class="comment">//当是最后一个节点时，直接不会进入第一个if判断，返回true</span></span><br><span class="line">            <span class="comment">//当上一轮的返回结果是false时，则这一轮必定返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!recursiveCheck(curNode.next)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//程序进入到这里时，cur指针已经指向和front指针对称的位置</span></span><br><span class="line">            <span class="comment">//当不满足回文链表的性质时返回false</span></span><br><span class="line">            <span class="comment">//满足性质时，直接退出第一个if判断，返回最后的true</span></span><br><span class="line">            <span class="keyword">if</span>(curNode.val != frontNode.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//满足性质时，front指针后移</span></span><br><span class="line">            <span class="comment">//cur指针会因为递归的结束，返回上一个递归，也就是上一个位置</span></span><br><span class="line">            frontNode = frontNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回true代表这一轮（当前cur和front指针指向的两个节点）符合条件，可以接续判断下一个</span></span><br><span class="line">        <span class="comment">//返回false则代表不是回文链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法四"><a class="markdownIt-Anchor" href="#方法四"></a> 方法四</h2>
<h3 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h3>
<p>与方法一类似的，我们其实不用反转整个链表，只用反转链表的后半部分，然后将前半部分和后半部分进行比较，这样也可以判断其是否为一个回文链表。</p>
<p>具体步骤如下</p>
<ol>
<li>找到链表的中点</li>
<li>反转链表的后半部分</li>
<li>同时从链表的头节点和中部节点开始向后遍历，检查其是否为回文链表</li>
</ol>
<p>在寻找链表中点的这一部分，我们可以考虑采用<strong>快慢指针</strong>的方法：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</p>
<ul>
<li>时间复杂度：$O(2N) $,通过快慢指针找到链表中点只需要遍历链表一半，然后反转链表的一半也只用遍历需要反转的那一部分，最后再分别遍历一半的链表来判断是否为回文链表</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      	<span class="comment">//找到链表中点，并反转后半部分</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">reverseHalf</span> <span class="operator">=</span> reverse(findHalf(head));</span><br><span class="line">        <span class="keyword">while</span> (reverseHalf != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != reverseHalf.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            reverseHalf = reverseHalf.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//寻找链表中点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">findHalf</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;<span class="comment">//注意快指针需要判断多个条件</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//链表的反转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>, curNode = head, nextNode = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            nextNode = curNode.next;</span><br><span class="line">            curNode.next = preNode;</span><br><span class="line">            preNode = curNode;</span><br><span class="line">            curNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序数组</title>
    <url>/2022/12/30/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="合并两个有序数组"><a class="markdownIt-Anchor" href="#合并两个有序数组"></a> 合并两个有序数组</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给你两个按<u>非递减顺序</u>排列的整数数组<code>nums1</code>和<code>nums2</code>，另有两个整数<em>m</em>和n，分别表示<code>nums1</code>和<code>nums2</code>中的元素数目。</p>
<p>请你合并<code>nums2</code>到<code>nums1</code>中，使合并后的数组同样按非递减顺序排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组<code>nums1</code>中。为了应对这种情况，<code>nums1</code>的初始长度为<em>m + n</em>，其中前<em>m</em>个元素表示应合并的元素，后<em>n</em>个元素为<em>0</em>，应忽略。<code>nums2</code>的长度为<em>n</em>。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>我想到最偷懒的方法是，直接把<code>nums2</code>装到<code>nums1</code>后面，然后对<code>nums1</code>重新进行排序</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，移动数组的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，排序是使用系统的快速排序，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，二者取较小值</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，快排的递归深度</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//nums2为空则不需要进行合并</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, k = m;<span class="comment">//j指向nums2数组的起始元素</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; m + n)&#123;</span><br><span class="line">            nums1[k++] = nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>这道题还有点类似归并排序，将两个排好序的数组融合成一个，我们可以借助归并排序的思想来实现它。我们申请一个辅助空间<code>arr</code>，它的大小就是<em>m+n</em>，设置两个指针分别开始遍历<code>nums1</code>和<code>nums2</code>，哪个数组里的元素小就放到<code>arr</code>中，直到将<code>arr</code>放满。<code>arr</code>放满后将其拷贝到<code>nums1</code>中即可。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，归并排序指针需要移动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>次，最后的拷贝指针也需要移动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>次</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  	<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[m+n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) arr[k++] = nums1[i++];</span><br><span class="line">        <span class="keyword">else</span> arr[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == m)&#123;<span class="comment">//如果nums1拷贝完了，则将nums2剩下的元素全部放倒arr中</span></span><br><span class="line">      	<span class="keyword">while</span> (j &lt; n) arr[k++] = nums2[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == n)&#123;<span class="comment">//同理nums2</span></span><br><span class="line">      	<span class="keyword">while</span> (i &lt; m) arr[k++] = nums1[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(arr,<span class="number">0</span>,nums1,<span class="number">0</span>,m+n);<span class="comment">//拷贝数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3>
<p>我们还可以通过逆向双指针方法来解决这个问题。我们应该好好利用nums1后面的空间都是空的这个特性。我们分别从nums1和nums2有数据的部分末尾向前遍历，哪个元素大就将其放到nums1的末尾。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m-<span class="number">1</span>, j = n-<span class="number">1</span>, k = m+n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;<span class="comment">//先赋值再移动，那么循环结束的条件就是某个指针指向-1，这样才代表遍历完</span></span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) nums1[k--] = nums1[i--];</span><br><span class="line">        <span class="keyword">else</span> nums1[k--] = nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)&#123;<span class="comment">//如果nums1遍历完，则nums2直接拷贝到前面</span></span><br><span class="line">    		<span class="keyword">while</span> (j &gt;= <span class="number">0</span>) nums1[k--] = nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span>)&#123;<span class="comment">//同理nums2</span></span><br><span class="line">    		<span class="keyword">while</span> (i &gt;= <span class="number">0</span>) nums1[k--] = nums1[i--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>外观数列</title>
    <url>/2022/12/07/%E7%AE%97%E6%B3%95/%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="外观数列"><a class="markdownIt-Anchor" href="#外观数列"></a> 外观数列</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给定一个正整数<em>n</em>，输出外观数列的第<em>n</em>项。</p>
<p>「外观数列」是一个整数序列，从数字<em>1</em>开始，序列中的每一项都是对前一项的描述。</p>
<p>你可以将其视作是由递归公式定义的数字字符串序列：</p>
<ul>
<li><code>countAndSay(1) = &quot;1&quot;</code></li>
<li><code>countAndSay(n)</code> 是对 <code>countAndSay(n-1)</code> 的描述，然后转换成另一个数字字符串。</li>
<li>前五项如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1- 1</span><br><span class="line">2- 11</span><br><span class="line">3- 21</span><br><span class="line">4- 1211</span><br><span class="line">5- 111221</span><br><span class="line">第一项是数字 1 </span><br><span class="line">描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;</span><br><span class="line">描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;</span><br><span class="line">描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;</span><br><span class="line">描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;</span><br></pre></td></tr></table></figure>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>按照题目对外观数列的描述，我的第一感觉就是，给我第<em>n-1</em>个外观数列的项，我对其进行分析，然后得到第<em>n</em>项，就像题目里所描述的“递归”。</p>
<p>那假设我现在已经知道了第<em>n-1</em>个外观数列的项，我就去遍历这个字符串，因为我们要统计每个数字出现的次数，所以我们需要两个指针，一个指针用于记录之前的那个数，一个用于记录当前这个数：如果这两个数一样，那么该数字出现的次数加一，否则这个数就结束了，我们需要对其进行描述（打印）。描述的过程其实也很简单，先输出这个数出现的次数，然后再输出这个数即可。</p>
<p>我们以第四项为例（<em>1211</em>）。先用一个<code>lastChar</code>来记录下标为<em>0</em>的字符<em>1</em>，指针<code>i</code>从下标为<em>1</em>的元素开始遍历，两个指针指向的内容不一样，那也意味着<code>lastChar</code>所指向的数字只出现了一次，那我们就先打印这个数字出现的次数<em>1</em>，然后再打印这个数字。然后现在<code>lastChar</code>应该指向下标为<em>1</em>的字符<em>2</em>，然后指针<code>i</code>指向下标为<em>2</em>的元素<em>1</em>，这两个指针指向的数字又不一样，那就马上再打印这个数字的信息。当<code>lastChar</code>指向下标为<em>2</em>的字符<em>1</em>时，指针<code>i</code>指向下标为<em>3</em>的元素<em>1</em>，这两个数相同，那么元素<em>1</em>出现的次数就会加一....</p>
<ul>
<li>时间复杂度：由于需要递归，时间复杂度应该是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;<span class="comment">//递归出口</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> countAndSay(n-<span class="number">1</span>);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">char</span> <span class="variable">lastChar</span> <span class="operator">=</span> last.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//记录一个数字出现的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//遍历的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; last.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastChar == last.charAt(i)) &#123;</span><br><span class="line">                num ++;<span class="comment">//出现的次数增加</span></span><br><span class="line">                i ++;<span class="comment">//继续向后遍历</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(num);</span><br><span class="line">                sb.append(lastChar);</span><br><span class="line">                num = <span class="number">0</span>;<span class="comment">//重置</span></span><br><span class="line">                lastChar = last.charAt(i);<span class="comment">//重新比较</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(num);<span class="comment">//对最后一个数的描述</span></span><br><span class="line">        sb.append(lastChar);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串中第一个唯一字符</title>
    <url>/2022/12/01/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="字符串中第一个唯一字符"><a class="markdownIt-Anchor" href="#字符串中第一个唯一字符"></a> 字符串中第一个唯一字符</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给定一个字符串 <code>s</code> ，找到 <em>它的第一个不重复的字符，并返回它的索引</em> 。如果不存在，则返回 <code>-1</code></p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>看到这道题我的第一个联想到的是<a href="https://keveinkk.github.io/2022/11/21/%E7%AE%97%E6%B3%95/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/">存在重复元素</a>，先将字符串里的元素进行排序，排好序后有重复的字符都会紧挨在一起，如果一个元素和左右两个元素都不相等，那这个元素就是不重复的。</p>
<p>但是这个思路有些问题：</p>
<ol>
<li>排序会打乱字符串中字符的顺序，导致输出的字符索引并不是初始的</li>
<li>输出的第一个不重复的字符并不是在字符串中第一个不重复的字符，而是所有不重复字符中ASCII码最小的那个</li>
</ol>
<p>但是这个思路还是给了我很大的启发，既然排序会打乱字符串中字符的顺序，那我就不使用排序好了。那有没有其他的办法可以统计字符出现的次数呢？</p>
<p>我想到了<strong>计数排序</strong>。这道题刚好只有26个字符，那我申请一个长度为26的数组来统计每个字符出现的频率。我按照字符串中字符的顺序遍历，每遍历到一个字符<code>a</code>，我就将其转换为<code>int</code>得到它的<code>ASCII</code>码，再减去97（<code>a</code>的<code>ASCII</code>码为97），这样就能将其放到我申请的数组中了。这样一次遍历后我就能得到所有字符出现的频率，我提取出所有只出现了一次的字符，重新组成一个新的数组，不妨称为<code>uniq</code>数组，如果<code>uniq</code>数组为空，那么程序直接返回-1即可。</p>
<p>但这样仍然不能解决第一个问题，即我得到的字符的顺序是按照<code>ASCII</code>码的顺序排列的，我不清楚原始字符串中的顺序。那么我再遍历一次原来的字符串，把字符串中的每个字符都与<code>uniq</code>数组中的每一个字符进行比较，如果有先匹配到的那我就直接返回这个字符，程序结束。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，主要的问题出现在最后一步，我为了得到原始字符串中第一个出现的字符，我不得不将字符串与<code>uniq</code>数组进行一一比较</li>
<li>空间复杂度:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();<span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">      	<span class="comment">//计数排序</span></span><br><span class="line">        <span class="type">int</span>[] ascii = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++)&#123;</span><br><span class="line">            ascii[(<span class="type">int</span>)chars[i] - <span class="number">97</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] uniq = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ascii.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ascii[i] == <span class="number">1</span>)</span><br><span class="line">                uniq[j++] = (<span class="type">char</span>) (i + <span class="number">97</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">if</span>(uniq == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//如果uniq数组为空，则代表没有唯一的字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; j + <span class="number">1</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chars[i] == uniq[k])&#123;</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>方法一之所以出现时间复杂度很高的情况，归根结底还是我是按照<code>ASCII</code>码的顺序来遍历字符串，如果我能优化<code>uniq</code>数组就能解决这个问题。<code>uniq</code>数组的出现是为了将所有只出现了一次的数都归纳起来，那我是否可以通过直接遍历<code>ascii</code>数组来省掉<code>uniq</code>呢。我直接遍历<code>ascii</code>数组，如果一个元素的值不是1，那我就直接忽略这个字符，它肯定不是我想要的，那如果它的值是1，那就有可能是我想要的结果。那现在的重点就是我按照什么顺序去遍历<code>ascii</code></p>
<p>我们可以不用按照<code>ASCII</code>码的顺序来遍历<code>uniq</code>数组，我们可以直接按照字符串的顺序来遍历数组。就像我们在统计<code>ascii</code>这个数组时，我们并非是用<code>for(int i = 97; i &lt; 97 + 26; i++)</code>的顺序，而是在按照<code>str</code>的顺序，每找到一个字符，就直接把它放到对应的<code>ascii</code>数组中。</p>
<p>那么同理，在方法一的第三个循环中，我们不用拿着字符串和<code>uniq</code>数组进行比较，而是可以直接按照字符串的顺序再读一遍<code>ascii</code>数组，如果<code>ascii</code>数组中记录的该字符的出现的频率是1那么就返回它好了。</p>
<p>同时在代码细节上还有许多可以优化的地方</p>
<ol>
<li>
<p>遍历字符串时不一定要先将其转换为字符数组再遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">		str.charAt(i)....<span class="comment">//提取出字符串中第i个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字符ASCII码的转化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="type">int</span>)chars[i] - <span class="number">97</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">char</span>[i] - <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>时间复杂度：由于没有了<code>uniq</code>数组，更不需要将字符串与<code>uniq</code>数组一一比较，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] times = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];<span class="comment">//原ascii数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            times[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++ ;<span class="comment">//按照字符串的顺序填写times数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (times[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;<span class="comment">//按照字符串的顺序遍历times数组</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span name = "ref1"><a href="https://keveinkk.github.io/2022/11/21/%E7%AE%97%E6%B3%95/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/">https://keveinkk.github.io/2022/11/21/算法/存在重复元素/</a></span></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>存在重复元素</title>
    <url>/2022/11/23/%E7%AE%97%E6%B3%95/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="存在重复元素"><a class="markdownIt-Anchor" href="#存在重复元素"></a> 存在重复元素</h1>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code></p>
<h2 id="方法一利用排序"><a class="markdownIt-Anchor" href="#方法一利用排序"></a> 方法一：利用排序</h2>
<p>在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。</p>
<p>在进行排序时，我们其实可以先导入<code>java.util.Arrays</code>的包，直接利用<code>sort</code>方法进行排序</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，排序的时间复杂度</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，快排的递归深度</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i-<span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>这道题并不能通过位运算的技巧来快速解决，通过排序解决应该是最简单的办法</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串转换整形</title>
    <url>/2022/12/04/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="字符串转换整形"><a class="markdownIt-Anchor" href="#字符串转换整形"></a> 字符串转换整形</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>请你来实现一个<code>myAtoi(string s)</code>函数，使其能将字符串转换成一个 32 位有符号整数。</p>
<p>函数<code>myAtoi(string s)</code>的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，&quot;123&quot; -&gt; 123， &quot;0032&quot; -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。</li>
<li>返回整数作为最终结果。</li>
<li>注意：
<ul>
<li>本题中的空白字符只包括空格字符 ' '</li>
<li>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符</li>
</ul>
</li>
</ol>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>这道题主要考察对输入种类的判断，以及边界情况（溢出）的处理。思路上没有什么难点，但是在细节上有很多需要注意的。</p>
<ul>
<li>
<p>对溢出的判断</p>
<ol>
<li>
<p>方法一</p>
<ul>
<li>每一轮的结果计算公式如下：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mo>=</mo><mi>r</mi><mi>e</mi><mi>s</mi><mo>×</mo><mn>10</mn><mo>+</mo><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">res=res\times 10+temp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span></span></span></span></li>
<li>用一个变量<code>pre</code>记录上一轮的计算结果，<code>res</code>代表这一轮的计算结果
<ul>
<li>如果发生溢出的话<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo mathvariant="normal">≠</mo><mi>r</mi><mi>e</mi><mi>s</mi><mo lspace="0em" rspace="0em">÷</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">pre\ne res {\div} 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord"><span class="mord">÷</span></span><span class="mord">1</span><span class="mord">0</span></span></span></span></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> res;</span><br><span class="line">res = res * <span class="number">10</span> + Character.getNumericValue(s.charAt(i));</span><br><span class="line"><span class="keyword">if</span>(pre != res/<span class="number">10</span>)</span><br><span class="line">	<span class="comment">//溢出处理...</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法二</p>
<ul>
<li>
<p><code>int</code>型发生溢出的话我们考虑使用<code>long</code>型来存储数据</p>
</li>
<li>
<p>用一个<code>long</code>型的变量<code>res</code>来记录每一轮的计算结果</p>
<ul>
<li>如果是正数发生溢出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">res &gt; Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">//溢出处理...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果是负数发生溢出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">res &lt; Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">//溢出处理...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>将字符转化为<code>int</code></p>
<ol>
<li>
<p>通过Character类中的方法</p>
<ul>
<li>
<p><code>public static int getNumericValue(char ch)</code></p>
<blockquote>
<p>Returns the int value that the specified Unicode character represents</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>通过字符之间的运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;5&#x27;</span>;<span class="comment">//0~9</span></span><br><span class="line">c - <span class="string">&#x27;0&#x27;</span><span class="comment">//5</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>时间复杂度：遍历一遍字符串即可，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录结果</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//默认是正数</span></span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">firChar</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>);<span class="comment">//判断第一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (firChar == <span class="string">&#x27;-&#x27;</span>) &#123;<span class="comment">//判断条件太多</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firChar == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;<span class="comment">//非常多余</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(firChar)) &#123;</span><br><span class="line">            res = Character.getNumericValue(firChar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> res;</span><br><span class="line">                res = res * <span class="number">10</span> + Character.getNumericValue(c);</span><br><span class="line">                <span class="keyword">if</span> (pre != res / <span class="number">10</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;<span class="comment">//可以通过三目运算符来优化</span></span><br><span class="line">                        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span> * res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">        <span class="comment">//将直接返回的条件写在一起</span></span><br><span class="line">        <span class="comment">//长度为0直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">firChar</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//第一个字符既不是数字、也不是正负符号，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!Character.isDigit(firChar) &amp;&amp; firChar != <span class="string">&#x27;-&#x27;</span> &amp;&amp; firChar != <span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//此时字符串第一个字符要么是数字，要么是正负号</span></span><br><span class="line">        <span class="comment">//判断符号</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">neg</span> <span class="operator">=</span> (firChar == <span class="string">&#x27;-&#x27;</span>);<span class="comment">//如果符号位是负，则neg为真，其余情况都为正</span></span><br><span class="line">        <span class="comment">//如果第0位是数字，那从第0为开始遍历数组</span></span><br><span class="line">        <span class="comment">//如果第0为是符号，那从第1为开始遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Character.isDigit(firChar) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//最后的结果</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">//第一个条件用于正常遍历字符串</span></span><br><span class="line">        <span class="comment">//第二个条件用于：当字符串数字遍历完了之后，舍弃后面的其他字符</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">            <span class="comment">//此时i指向的一定是数字</span></span><br><span class="line">            ans = ans * <span class="number">10</span> + (s.charAt(i++) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="comment">//判断溢出情况</span></span><br><span class="line">            <span class="keyword">if</span> (neg &amp;&amp; -ans &lt; Integer.MIN_VALUE)</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (!neg &amp;&amp; ans &gt; Integer.MAX_VALUE)</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//不用写-1*ans</span></span><br><span class="line">        <span class="keyword">return</span> neg ? (<span class="type">int</span>)-ans : (<span class="type">int</span>)ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>对称二叉树</title>
    <url>/2022/12/26/%E7%AE%97%E6%B3%95/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="对称二叉树"><a class="markdownIt-Anchor" href="#对称二叉树"></a> 对称二叉树</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给你一个二叉树的根节点<code>root</code>， 检查它是否轴对称。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>学习了昨天做的检查一个树是否为一个二叉搜索树的经验，我想从一个对称二叉树的遍历结果来看看它有什么特点。显然，一个对称的二叉树，它的中序/层次遍历结果显然也是对称的。我就依据这个特点想到了，先对二叉树进行中序或者层次遍历，然后对其遍历结果进行判断。</p>
<p>这个思路大体上是正确的，但是有一个棘手的问题需要解决：如何处理空节点。在我们遍历的过程中，我们会直接跳过空节点，然而在判断一个树是否为对称二叉树时，空节点不能直接跳过。我们看看这个例子<code>[1,2,2,3,3]</code>和<code>[1,2,2,3，null,null,3]</code>显然这两个树的遍历结果是相同的，我们误认为它们都不是是对称的，但是第二个其实是对称的。因此如何处理空节点是解决这个问题的关键。</p>
<p>我的思路是，给空节点赋一个特殊值，如果遍历的时候遇到了一个空节点，我就自动在这里填一个特殊值（由于节点所有值的取值范围是*-100～100*，这里我取特殊值为<em>999</em>），这样我们就能轻易判断一个树是否为对称的。</p>
<p>在实现过程中，我发现其实我并不会用前序遍历来填充空节点，我只会层次遍历。因此我在这里使用层次遍历的方法来处理这道题。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，将所有节点都遍历一遍即可</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，层次遍历需要用一个队列作为辅助空间</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Soluton1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">999</span>);<span class="comment">//给所有的null节点赋特殊值999</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">          	<span class="comment">//每一层的遍历结果都应该是对称的</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">numOfNode</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            TreeNode[] treeNodes = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[numOfNode];</span><br><span class="line">            treeNodes = queue.toArray(treeNodes);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numOfNode/<span class="number">2</span>; i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> numOfNode - i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (treeNodes[i].val != treeNodes[j].val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (numOfNode &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                numOfNode --;</span><br><span class="line">                <span class="keyword">if</span> (temp.val == <span class="number">999</span>) <span class="keyword">continue</span>;<span class="comment">//空节点显然没有孩子</span></span><br><span class="line">              	<span class="comment">//如果一个节点有左孩子则正常加入其左孩子，否则设置其左孩子为特殊节点</span></span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">else</span> queue.offer(flag);</span><br><span class="line">								<span class="comment">//右孩子同理</span></span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) queue.offer(temp.right);</span><br><span class="line">                <span class="keyword">else</span> queue.offer(flag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>我们可以换一种思路想这个问题，没有说对称二叉树一定要只和自己比，只看自己的遍历结果是否对称。我们完全可以再复制一个一摸一样的树，设置两个指针。第一个树的指针往右边走，第二个树的指针往左边走。每次同步的、镜像的一栋两个指针，判断两个指针指向的节点内容是否相同。</p>
<ul>
<li>时间复杂度：我们只用把两个二叉树都遍历一遍即可，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：递归深度也就是递归的层数，递归层数最多就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//设置两个指针对两棵树进行遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//同时指向空节点是正常的</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      	<span class="comment">//检查这两个指针指向的节点</span></span><br><span class="line">      	<span class="comment">//p指针向左移动，则q指针向右移动</span></span><br><span class="line">      	<span class="comment">//p指针向右移动，则q指针向左移动</span></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3>
<p>继续方法二的思路，我们尝试用迭代法解决这个问题。有了同时遍历两个树的想法，那我们可以同时层次遍历两个树，也就是同时遍历两个树的同一层。但是第一个树的孩子是从左向右加入队列的，第二棵树的孩子是从右向左加入队列的。那我们同时从队列里取出两个节点，如果这个树是对称的，那么这两个节点应该是一样的。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numOfNode</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span> (numOfNode &gt; <span class="number">0</span>)&#123;</span><br><span class="line">              	<span class="comment">//同时拿出两个节点</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp1</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp2</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                numOfNode = numOfNode - <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (temp1 == <span class="literal">null</span> &amp;&amp; temp2 == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (temp1 == <span class="literal">null</span> || temp2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (temp1.val != temp2.val)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//第一个节点先入左孩子，再入右孩子</span></span><br><span class="line">                <span class="comment">//第二个节点先入右孩子，再入左孩子</span></span><br><span class="line">                queue.offer(temp1.left);</span><br><span class="line">                queue.offer(temp2.right);</span><br><span class="line">                queue.offer(temp1.right);</span><br><span class="line">                queue.offer(temp2.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>打乱数组</title>
    <url>/2023/01/12/%E7%AE%97%E6%B3%95/%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="打乱数组"><a class="markdownIt-Anchor" href="#打乱数组"></a> 打乱数组</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给你一个整数数组<code>nums</code>，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是等可能的。</p>
<p>实现<code>Solution class</code>:</p>
<ul>
<li><code>Solution(int[] nums)</code> 使用整数数组 <code>nums</code> 初始化对象</li>
<li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li>
<li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li>
</ul>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>这是一道设计问题，就是要求实现一个给定的类的接口，并可能涉及使用一种或多种数据结构。 那这道题一共有三个任务，我们一一来看。</p>
<p>首先是任务一。这个类的名字是<code>Solution</code>，然后他给我们的方法名也是<code>Solution</code>，那显然这就是一个构造函数，并且这个构造函数是带一个参数的，那么我们就需要根据这个参数来设计一下<code>Solution</code>这个类里面的成员变量。这道题都是对数组进行操作的，那么我们就自然而然的想到了也设置一个数组的成员变量。于是乎很自然的，那这个构造函数就将传入的这个形式参数赋给了我们<code>Solution</code>这个类里的成员变量。</p>
<p>再看任务二。它让我们返回数组的初始状态，那实现这个功能其实有两个思路。第一个思路就是我们给我们的初始状态做一个备份，然后之后修改初始状态，当要返回初始状态时，我们返回一开始的备份即可。另一个思路是，我们不给初始状态做备份。当我们后面需要对数组进行操作时，我们不直接对数组进行操作，而是拷贝一份数组，对我们的副本进行操作。这里为了提升空间性能，我才用第一个思路。</p>
<p>然后是任务三。其实任务三才是这个问题的难点：如何打乱一个数组，并且打乱后数组所有排列应该是等可能的。我这里的想法是：生成一个随机数序列，用于表示原有数组里的数打乱后的位置。那么这个随机数序列有三点要求：第一，长度和数组长度相同，因为我们要将每一个元素都放到一个新的位置；第二，随机数的大小必须限制在数组的长度以内，这样元素的新位置才是合法的；第三，这个随机数的序列中不能有重复的随机数，因为一旦发生了重复，就代表之前数组中的两个元素会放到同一个位置，造成元素变少了。</p>
<p>前两点窦很好解决，那接下来我就思考如何获得一个不重复的随机数。我的想法是用一个<code>List</code>的数据结构来存储这个随机数序列，然后借助<code>contains</code>方法来判断某个随机数是否已经存在，如果不存在就加入这个<code>List</code>，如果存在就重新生成。</p>
<ol>
<li>初始化：
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，我们只用将成员变量修改，让其指向形参所指向的数组即可，不需要一个元素一个元素的拷贝</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>重置：
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，由于我们所采取的策略，我们直接返回原始的成员变量即可</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>打乱：
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，我们首先要生成n个随机数，然后我们需要遍历一遍数组，用于给每个元素分配新的位置。但其实生成随机数这个步骤的耗时肯定是远大于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，尤其是分配到后面，耗时是非常大的（如果只剩最后一个位置的时候，其实剩下的数是确定的，但生成的随机数要一个一个试才行。我甚至认为这个过程可能会达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的时间复杂度</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，一方面我们要存储生成的随机数序列，另一方面，由于我们的策略，导致我们要对原数组进行一次拷贝，对其副本进行操作，让原来的成员变量不做改变。</li>
</ul>
</li>
</ol>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.len = nums.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] shuffle() &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(len);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">while</span> (list.size() &lt; len)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> random.nextInt(len);</span><br><span class="line">            <span class="keyword">if</span> (!list.contains(randomNum)) list.add(randomNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            arr[i] = nums[list.get(i)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>我们在方法一中采取的策略是：保留原始的成员变量，每次操作都对其先进拷贝，然后对其副本进行修改。那这里我们才用第二种思路：我们直接对其成员变量进行拷贝，保留一份其初始状态，然后后面的操作直接对这个成员变量进行。</p>
<p>对于初始化操作，我们设置两个成员变量（数组），一个为<code>nums</code>，之后的操作直接对<code>nums</code>进行，另一个为<code>prototype</code>，保留了数据的原始状态。那对于nums，可以直接修改其指向构造函数里传入的数组。但是对于<code>prototype</code>，我们不能只是简单的修改其也指向那个数组，因为一旦这两个引用都指向同一片空间，我们修改了<code>nums</code>，那其实也就修改了<code>prototype</code>，所以我们需要单独拷贝<code>nums</code>数组到<code>prototype</code>中。</p>
<p>对于重置操作，我们只用返回<code>prototype</code>即可。</p>
<p>那对与打乱操作，在方法一中，我们是创建了不重复的随机数序列，用这个随机数序列确定每个元素要放到的新的位置，这样操作的时间开销比较大，那我们想是否能避免创建一个不重复的随机数序列，只用创建若干个随机数就好了。方法一中，随机数代表的是新的元素下标，因此它不能有重复。那如果允许重复的话，随机数就不能代表的是新的元素的下标，而可以是原始的元素，并且这个前面一个元素被消除后，后面的元素就自动向前补齐。这样，我们随便从原始的元素序列中取元素，每取到一个元素，就把它放到新的数组的末尾。通过随机取元素，而不是放到随机的位置上避免对随机数过多的要求。</p>
<p>我们考虑将原始的数组放到一个<code>List</code>中，这样通过随机数可以确定我们要从这个<code>List</code>中取出哪个数字。这个随机数是可以重复的，因为从<code>List</code>中取出一个数字后，它会自动向前补齐，所以哪怕我们一直取的都是一个数都可以。但我们在这里要注意，这个随机数的取值范围每次都是变化的，因为每一次取出来之后<code>List</code>的大小就会减少，我们不能让下标越界。</p>
<ol>
<li>初始化
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，我们需要将<code>prototype</code>拷贝一份</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>重置
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，直接返回<code>prototype</code>即可</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>打乱
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，首先将数组整个转换成List，然后将List中的元素随机取出来放到一个新的数组中</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
</ol>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span>[] protype;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        len = nums.length;</span><br><span class="line">        protype = <span class="keyword">new</span> <span class="title class_">int</span>[len];<span class="comment">//避免空指针异常</span></span><br><span class="line">        System.arraycopy(nums,<span class="number">0</span>,protype,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> protype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span>[] shuffled = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> random.nextInt(list.size());<span class="comment">//避免越界</span></span><br><span class="line">            shuffled[i] = list.remove(randomIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shuffled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3>
<p>方法一是通过将原来的数放到一个随机的位置来实现打乱的效果，方法二是通过随机取出来原来的数放到固定位置来实现打乱的操作。那其实还有一种方法，即通过随机交换两个数来实现同样的效果。我们将nums里的数随机和后面的一个数进行交换也能达到打乱的效果，并且这样的思路不需要额外的辅助空间，而且只需要遍历一遍就可以完成。</p>
<p>打乱</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution4</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">int</span>[] protype;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution4</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        len = nums.length;</span><br><span class="line">        protype = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        System.arraycopy(nums,<span class="number">0</span>,protype,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> protype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(len-i) + i;<span class="comment">//将这个数与其后面的随机一个数进行交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[index];</span><br><span class="line">            nums[index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍</title>
    <url>/2023/01/11/%E7%AE%97%E6%B3%95/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<h1 id="打家劫舍"><a class="markdownIt-Anchor" href="#打家劫舍"></a> 打家劫舍</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>这也是一道非常典型的动态规划的题目。我们首先还是通过暴力枚举，找到这道题目的规律。但实际上这道题的规律太明显了，甚至不用枚举。我们一个房间一个房间的进去，进入第k间房子，我们只有两个选择：如果偷的话，我们获得的利润就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">f(k-2)+k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>，如果我们不偷的话，我们获得的利润就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(k-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>那么很自然的，我们需要考虑一下<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>这个函数的意义：这里我们将其定义为第<em>i</em>天能获得<u>最大</u>利润。首先不得不承认，每一天只能设置一个利润，我们要设置一天有多种状态的话，最后的状态转移方程就会很复杂。定义好了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>这个函数，我们很自然的就得到了最后的状态转移方程：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mtext>−</mtext><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)=max(f(i−2])+nums[i],f(i−1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mord">−</span><span class="mord">2</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>然后考虑一下边界条件：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f(0)=nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>。在设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>时，由于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>代表的是第<em>1</em>间房子能获得的最大利润，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>就不能只是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，它应该是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的最大值。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，只用遍历数组一遍即可</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，用一个哈希表（或者数组）来存储记录每一个房间能获得的最大利润
<ul>
<li>当然也可以使用滚动数组的方法来实现算法的原地工作，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>因为其实状态转移方程里只用到了前两个状态的值，并且最后输出的结果就是最后一个状态的值</li>
</ul>
</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,nums[<span class="number">0</span>]);</span><br><span class="line">        map.put(<span class="number">1</span>,Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; len; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> Math.max(map.get(i-<span class="number">1</span>),nums[i]+map.get(i-<span class="number">2</span>));</span><br><span class="line">            map.put(i,money);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(len-<span class="number">1</span>);<span class="comment">//返回最后一个房间能获得的最大利润即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prepre</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> prepre;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">2</span>) <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> pre;</span><br><span class="line">            pre = Math.max(temp,prepre+nums[i]);</span><br><span class="line">            prepre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>找出字符串中第一个匹配项的下标</title>
    <url>/2022/12/06/%E7%AE%97%E6%B3%95/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87/</url>
    <content><![CDATA[<h1 id="找出字符串中第一个匹配项的下标"><a class="markdownIt-Anchor" href="#找出字符串中第一个匹配项的下标"></a> 找出字符串中第一个匹配项的下标</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给你两个字符串 <code>haystack</code>和<code>needle</code>，请你在 <code>haystack</code>字符串中找出<code>needle</code>字符串的第一个匹配项的下标（下标从 0 开始）。如果<code>needle</code>不是 <code>haystack</code>的一部分，则返回  -1 。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>这道题其实就是串的模式匹配算法。那么最简单的就是暴力匹配。</p>
<p>我们可以让主串和子串一一匹配，用指针<em>i</em>和<em>j</em>记录主串和子串现在匹配的元素下标。如果匹配失败，则下一次主串指针<em>i</em>回溯到上一次匹配开始的位置，子串指针从0开始重新匹配。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>，其中<em>m</em>为子串的长度，<em>n</em>为主串的长度</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> haystack.length(), len2 = needle.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;<span class="comment">//记录一下本次匹配开始下标，方便匹配失败时回溯</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len2; j++)&#123;</span><br><span class="line">              	<span class="comment">//匹配失败，则需要回溯到本次匹配开始的位置</span></span><br><span class="line">              	<span class="comment">//不能直接break</span></span><br><span class="line">                <span class="keyword">if</span> (haystack.charAt(i) != needle.charAt(j))&#123;</span><br><span class="line">                    i = temp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">//如果主串已经匹配完了，但是子串还没匹配完，则匹配失败</span></span><br><span class="line">                <span class="keyword">if</span> (i == len1 -<span class="number">1</span> &amp;&amp; j &lt; len2 -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">              	<span class="comment">//如果匹配成功，则主串指针也向前移动</span></span><br><span class="line">                <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) i ++;</span><br><span class="line">              	<span class="comment">//如果此时子串指针已经到子串尾，代表匹配成功</span></span><br><span class="line">                <span class="keyword">if</span> (j == len2 - <span class="number">1</span>) <span class="keyword">return</span> i - len2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3>
<p>我一开始也认为自己能很轻松的做出来暴力匹配算法，但其实我实现的过程也不是非常轻松的，调试的过程也耗费了我不少时间。</p>
<ul>
<li>主串指针的回溯
<ul>
<li>当指针<em>i</em>和<em>j</em>指向的元素不相等时代表匹配失败，此时需要回溯主串和子串指针。</li>
<li>子串指针直接回到0即可，但是子串指针需要返回到上一次匹配开始的位置，而不能直接break。因为在和子串匹配的过程中其实i在第二层循环里也在不停的向前移动，如果直接退出第二层循环，那么i指向的元素早已经不是一开始进入第二层循环时的元素了</li>
</ul>
</li>
<li>主串指针和子串指针移动的顺序
<ul>
<li>我发现很多优秀的编程习惯都是先判断异常情况，再去处理正常程序。也就是一进入循环，先判断指针是否会越界、指向的元素不符合我们的设计等等这些情况，再去处理我们设想的情况。例如在这个问题中，我们先处理匹配失败的各种情况，然后再处理匹配成功的情况</li>
<li>那么按照这个思想，我们在第二层循环中需要考虑首先移动哪个指针，或者说如何判断已经完全匹配成功了。这一切的前提是指针是不能越界的。</li>
<li>如果先移动子串指针，当子串指针移动到末尾时，子串最后一个元素我们还没有比较，无法判断结果。因此我们需要先移动外层的指针。</li>
</ul>
</li>
</ul>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="kmp算法"><a class="markdownIt-Anchor" href="#kmp算法"></a> KMP算法</h3>
<p>KMP算法的讲解网上有太多了，我在这里就不赘述了。</p>
<p>虽然我之前已经学习过很多次这个算法，但是没想到今天实现的过程中还是花费了我相当大的精力，尤其是next数组的构建、数组下标的处理，这些都非常需要耐心。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，我们最多只用将两个字符串遍历一次</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，需要构建一个<code>next</code>数组</li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getNext(String needle)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> needle.length();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len];<span class="comment">//next数组的长度和子串长度一样</span></span><br><span class="line">      	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>；<span class="comment">//从下标为1的元素开始构建next数组，因为next[0]=0</span></span><br><span class="line">        <span class="comment">//j是next数组中元素的值</span></span><br><span class="line">        <span class="comment">//当子串在j匹配失败时，子串指针直接回溯到next[j]的位置</span></span><br><span class="line">        <span class="comment">//j也是一个指针，指向的是子串中i-1个元素最长前缀的后一位元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; len; i ++)&#123;</span><br><span class="line">          	<span class="comment">//如果匹配失败</span></span><br><span class="line">          	<span class="comment">//那么j就需要向前移动到next[j-1]的位置</span></span><br><span class="line">          	<span class="comment">//j的值不能小于1，第0个元素就不能再往前回溯了</span></span><br><span class="line">            <span class="keyword">while</span> (needle.charAt(i) != needle.charAt(j) &amp;&amp; j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//匹配成功</span></span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(i) == needle.charAt(j)) j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> haystack.length(), len2 =needle.length();</span><br><span class="line">        <span class="type">int</span>[] next = getNext(needle);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">          	<span class="comment">//匹配失败，主串指针无需回溯</span></span><br><span class="line">          	<span class="comment">//子串指针根据next数组的值进行回溯</span></span><br><span class="line">          	<span class="comment">//第0个元素就匹配失败的话，子串指针也不需要回溯</span></span><br><span class="line">            <span class="keyword">while</span> (haystack.charAt(i) != needle.charAt(j) &amp;&amp; j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//匹配成功</span></span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) j++;</span><br><span class="line">            <span class="keyword">if</span> (j == len2) <span class="keyword">return</span> i - len2 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意-2"><a class="markdownIt-Anchor" href="#注意-2"></a> 注意</h3>
<ul>
<li>有关于<code>next</code>数组的意义
<ul>
<li><code>next[i] = j</code>意味着当子串在<em>i</em>的位置匹配失败时，子串指针直接回溯到<code>next[i]</code>的位置，而不是直接返回到<em>0</em>，重头开始比较</li>
<li>那么我们就可以认为<em>j</em>其实也是一个指针，它指向的是下一次需要回溯的位置</li>
<li>那么在子串<em>j</em>前面的元素其实就是最长前缀（已经匹配好了的元素），那么换句话说<em>j</em>指向的就是这个元素<em>i</em>最长前缀的后一位元素</li>
</ul>
</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8u6mrsp42j316b0obdhr.jpg" alt="" /></p>
<ul>
<li>
<p>如何确定next数组的值</p>
<ul>
<li>当子串指针指向元素i时，我们已经确定了<code>next[i-1]</code>，那我们如何确认<code>next[i]</code>呢
<ul>
<li>假定<em>i</em>=17</li>
</ul>
</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8u6y2ad8hj31mq0g8t9w.jpg" alt="" /></p>
<ul>
<li>
<p>有以下两种情况</p>
<ul>
<li><em>i</em>指向的元素和j指向的元素相同</li>
<li>那么<em>j</em>可以直接后移，因为<em>j</em>指向的是最长前缀的后一位</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8u74vo4f2j31p10jbgn2.jpg" alt="" /></p>
<ul>
<li><em>i</em>指向的元素和<em>j</em>指向的元素不同</li>
<li>那么<em>j</em>不能直接简单的后移或者前移几位，它需要向前移动到如图所示的部分（其中紫色的部分都是相等的）</li>
<li>那我们可以判断一下紫色部分是谁的最长前缀，我们按照题目的情况分析。<code>next[16]=8</code>，即<code>next[i]=j</code>的话，子串第<em>i</em>个元素和第<em>j-1</em>元素的值是相同的。</li>
<li>那么<em>j</em>指向的就是<code>next[7]</code>，因为下标为<em>7</em>和<em>2</em>的元素的值是相同的</li>
<li>也就是说如果<em>i</em>指向的元素和<em>j</em>指向的元素不同，那么<code>j=next[j-1]</code></li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8u7aphy8qj31pb0iuabo.jpg" alt="" /></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组</title>
    <url>/2022/11/23/%E7%AE%97%E6%B3%95/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="旋转数组"><a class="markdownIt-Anchor" href="#旋转数组"></a> 旋转数组</h1>
<p align="right">11.8</p>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给你一个数组，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>最直观的方法是直接计算出<code>nums</code>数组中每个元素新位置的下标<code>i</code>，把这些元素按照新的下标位置重新摆放到一个新的数组<code>arr</code>中。当<code>nums</code>数组中的每个元素都计算出新的下标位置后，再将整个<code>arr</code>数组重新拷贝回<code>nums</code>数组中即可</p>
<ul>
<li>这种方法因为需要遍历整个数组，所以它的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>又因为这种方法需要计算好每个nums数组中元素的新位置后，才能进行拷贝操作，所以它的空间复杂度也是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];<span class="comment">//申请的辅助空间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newPosition</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录每个元素在轮转之后的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++) &#123;<span class="comment">//遍历整个数组，计算每个元素的新下标</span></span><br><span class="line">            newPosition = (i + k) % nums.length;</span><br><span class="line">            arr[newPosition] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新数组拷贝至原数组</span></span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3>
<p>该方法非常容易想到，并且实现起来也很容易，但在这里需要说明一下Java语言中数组拷贝的方法<sup><a href="#ref1">[1]</a></sup></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos, Object dest, <span class="type">int</span> desPos, <span class="type">int</span> length)</span></span><br><span class="line"><span class="comment">//形参列表的含义</span></span><br><span class="line"><span class="comment">//（原数组，原数组的开始位置，目标数组，目标数组的开始位置，拷贝元素个数）</span></span><br><span class="line"><span class="comment">//其中目标数组是要拷贝到的数组</span></span><br></pre></td></tr></table></figure>
<p><code>System.arraycopy()</code>方法是本地的方法，不需要导入任何包，其余的方法大多是基于该方法而实现的，因此在这里着重介绍一下这个方法。</p>
<p>当使用这个方法的时候，需要复制到一个已经分配内存单元的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用法示例：</span></span><br><span class="line"><span class="type">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">System.arraycopy(a1, <span class="number">1</span>, a2, <span class="number">3</span>, <span class="number">3</span>);<span class="comment">//将a1从第一个位置开始，拷贝3个数，到a2的第三个数后面</span></span><br><span class="line">System.out.println(Arrays.toString(a1)); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">System.out.println(Arrays.toString(a2)); <span class="comment">// [0, 0, 0, 2, 3, 4, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>在方法一的基础上，我们可以尝试尽量减少辅助空间的使用。</p>
<p>我们发现，之所以要申请辅助空间，是因为拷贝数组过程中会覆盖原数据。按照这个思路，我们不难发现在拷贝数组时，有些数据其实我们是允许它们被覆盖的，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>
<p>我们将输出的部分分成两段<code>[5,6,7]</code>以及<code>[1,2,3,4]</code>，我们可以先只将<code>[5,6,7]</code>挪到辅助数组里，允许<code>[1,2,3,4]</code>覆盖掉后面的内容，最后将辅助数组中的内容再拷贝到前面空缺的地方。按照这样的思路，<code>arr</code>数组的就不需要是备份整个nums数组，而是将<code>nums</code>数组一分为二，备份其中较小的一段即可。</p>
<ul>
<li>这种方法在拷贝数组的过程中还是遍历了整个数组，所以它的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>这种方法所申请的辅助空间虽然只需要备份数组中一部分的内容，但是它的空间复杂度还是与问题规模<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>成正比，空间复杂度还是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">      	<span class="keyword">if</span>(k == <span class="number">0</span>)<span class="comment">//这种情况下不需要操作</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//辅助数组的大小</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; (nums.length-k))&#123;<span class="comment">//移动的距离超过数组的一半</span></span><br><span class="line">            length = nums.length-k;<span class="comment">//拷贝后半部分</span></span><br><span class="line">            <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">            <span class="comment">//将少的那一部分（后半部分）拷贝到arr中</span></span><br><span class="line">            System.arraycopy(nums, <span class="number">0</span>, arr, <span class="number">0</span>, length);</span><br><span class="line">            <span class="comment">//将前半部分直接后移到目标位置</span></span><br><span class="line">            System.arraycopy(nums, length, nums, <span class="number">0</span>, k);</span><br><span class="line">            <span class="comment">//将arr数组移动到前面空缺的位置</span></span><br><span class="line">            System.arraycopy(arr, <span class="number">0</span>, nums, k, length);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//移动的距离小于数组的一半</span></span><br><span class="line">            length = k;<span class="comment">//拷贝后半部分</span></span><br><span class="line">            <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">            <span class="comment">//同理</span></span><br><span class="line">            System.arraycopy(nums, nums.length-k, arr, <span class="number">0</span>, k);</span><br><span class="line">            System.arraycopy(nums, <span class="number">0</span>, nums, k, nums.length-k);</span><br><span class="line">            System.arraycopy(arr, <span class="number">0</span>, nums, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3>
<p>在方法二的基础上，我们其实已经发现，旋转数组后会将原来的数组分成两个部分。</p>
<p>按照这个思路，我们可以继续探索这其中的规律：当我们将数组的元素向右移动 <em>k</em> 次后，尾部<code>k</code>个元素会移动至数组头部，其余元素向后移动<code>k</code>个位置。</p>
<p>这种效果等价于：我们先将这个数组进行逆序反转，然后再逆序反转前一部分，以及后一部分，我们还是以杠杠的例子做展示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">原始数组</td>
<td style="text-align:center"><code>1,2,3,4,5,6,7</code></td>
</tr>
<tr>
<td style="text-align:center">逆序</td>
<td style="text-align:center"><code>7,6,5,4,3,2,1</code></td>
</tr>
<tr>
<td style="text-align:center">翻转<code>[0,3]</code>上的元素</td>
<td style="text-align:center"><code>[5,6,7],[4,3,2,1]</code></td>
</tr>
<tr>
<td style="text-align:center">翻转[4,7]上的元素</td>
<td style="text-align:center"><code>[5,6,7],[1,2,3,4]</code></td>
</tr>
</tbody>
</table>
<ul>
<li>这个方法需要将每个元素都翻转两边，因此时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>这个方法没有申请任何多余的辅助空间，因此空间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)<span class="comment">//这种情况下不需要操作</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">        reverse(nums,<span class="number">0</span>,(nums.length-<span class="number">1</span>));<span class="comment">//逆序整个数组</span></span><br><span class="line">        reverse(nums,<span class="number">0</span>,k-<span class="number">1</span>);<span class="comment">//逆序前半部分</span></span><br><span class="line">        reverse(nums,k,(nums.length-<span class="number">1</span>));<span class="comment">//逆序后半部分</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组nums下标为a到b之间的数进行交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= (b-a)/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            swap(nums, (a+i), (b-i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == b)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        nums[a] = nums[a] ^ nums[b];</span><br><span class="line">        nums[b] = nums[a] ^ nums[b];</span><br><span class="line">        nums[a] = nums[a] ^ nums[b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法四"><a class="markdownIt-Anchor" href="#方法四"></a> 方法四</h2>
<p>方法四是我在看了参考答案后才明白的一种方法，借助移动过程中的数学推导，该方法也可以用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的空间复杂度解决这个问题，但由于时间问题今天就不再整理了！回去休息了！</p>
<p>Reference <a name="ref1"><font color="black">[1]https://blog.csdn.net/u011669700/article/details/79323251</font></a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转图像</title>
    <url>/2022/11/27/%E7%AE%97%E6%B3%95/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h1 id="旋转图像"><a class="markdownIt-Anchor" href="#旋转图像"></a> 旋转图像</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给定一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>的二维矩阵<code>matrix</code>表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在<u>原地</u>旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>我们可以通过多次翻转操作来实现旋转的效果</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>首先将数组沿着对角线交换</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">4</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">6</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>然后将每一行再翻转一次</p>
<table>
<thead>
<tr>
<th style="text-align:center">7</th>
<th style="text-align:center">4</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>这样便完成了一次旋转操作。</p>
<p>我们对其中的数组下标的规律做一个总结：</p>
<ol>
<li>数组沿对角线交换：<code>matrix[i][j]</code>与<code>matrix[j][i]</code>交换</li>
<li>每一行进行翻转：第<code>i</code>行<code>matrix[i][j]</code>与<code>matrix[i][length-1-j]</code>交换</li>
</ol>
<ul>
<li>时间复杂度：只需要遍历一次通过两次翻转操作就可以完成旋转的效果，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：原地工作，空间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">                swap(matrix,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            reverse(matrix,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        matrix[i][j] = matrix[i][j] ^ matrix[j][i];</span><br><span class="line">        matrix[j][i] = matrix[i][j] ^ matrix[j][i];</span><br><span class="line">        matrix[i][j] = matrix[i][j] ^ matrix[j][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= (matrix.length-<span class="number">1</span>)/<span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[i][matrix.length-<span class="number">1</span>-j];</span><br><span class="line">            matrix[i][matrix.length-<span class="number">1</span>-j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>当然我们也可以通过旋转操作来解决这个问题。直接旋转整个数组太困难，那我们可以一层一层的旋转，不难发现每一层矩形框的旋转都是符合同一个规律的。自外向内一共有不超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>层矩形框，对于第<code>times</code>层矩形框（从外向内计数），我们只需要循环交换其4个部分即可。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8jh0wx7pjj30w60u0diy.jpg" alt="" /></p>
<p>由于不能使用额外的存储空间，所以我们只能一个元素一个元素的交换。我们循环交换每个部分的第一个数，然后是第二个数...</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8jhmjo7h2j30xt0u0jt0.jpg" alt="" /></p>
<p>总结一下交换的规律：</p>
<p>第times层里有<code>len=matrix.length - 2*times</code>个数第0个数的坐标为<code>matrix[times][times+i]</code>,第1个数的坐标为<code>matrix[times+i][times+len-1]</code>，第2个数为<code>matrix[times+len-1][times+lem-i-1]</code>，第3个数为<code>matrix[times+len-i-1][times]</code></p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix.length != matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(times &lt;= (nums &gt;&gt; <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums - (times &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[times][times + i];</span><br><span class="line">                matrix[times][times + i] = matrix[times + len - i - <span class="number">1</span>][times];</span><br><span class="line">                matrix[times + len - i - <span class="number">1</span>][times] = matrix[times + len - <span class="number">1</span>][times + len - i - <span class="number">1</span>];</span><br><span class="line">                matrix[times + len - <span class="number">1</span>][times + len - i - <span class="number">1</span>] = matrix[times + i][times + len - <span class="number">1</span>];</span><br><span class="line">                matrix[times + i][times + len - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            ++times;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>将有序数组转换为二叉搜索树</title>
    <url>/2022/12/29/%E7%AE%97%E6%B3%95/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="将有序数组转换为二叉搜索树"><a class="markdownIt-Anchor" href="#将有序数组转换为二叉搜索树"></a> 将有序数组转换为二叉搜索树</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给你一个整数数组<code>nums</code>，其中元素已经按升序排列，请你将其转换为一棵高度平衡二叉搜索树。</p>
<p>高度平衡 二叉树是一棵满足：每个节点的左右两个子树的高度差的绝对值不超过<em>1</em>的二叉树</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>我们知道，中序遍历一个二叉搜索树的结果就是一个升序的数组，那么这道题其实就等价于将一个中序遍历的结果转换成一个二叉搜索树。当然我们知道只有一个中序的遍历结果是不能唯一确认一棵树的。但其实这个对我们来说就更容易了，我们可以随意确定树的形态，只要满足条件即可。</p>
<p>树的根节点肯定是数组最中间的那个元素，那根节点的左孩子应该就是数组前半部分的中点元素，右孩子就是数组后半部分的中点元素…这样下来，每个节点的左孩子肯定小于根节点，右孩子肯定大雨根节点。为什么设置成中点呢，主要就是为了图方便，我们可以将左孩子设定为中点左边一个元素、右孩子设置为中点右边一个元素，或者将左孩子设置成左三分之一点的元素，右孩子设置成右三分之一点的元素等等都可以，只要所有的节点遵循统一的规则就好。</p>
<p>那这样的思路其实就非常类似二分查找，那这道题其实就可以照猫画虎，用二分查找的递归解法来实现。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，我们需要</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,nums.length-<span class="number">1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//递归出口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);<span class="comment">//根节点为中点元素</span></span><br><span class="line">        root.left = helper(start, mid-<span class="number">1</span>, nums);<span class="comment">//左孩子是前半部分的中点</span></span><br><span class="line">        root.right = helper(mid+<span class="number">1</span>, end, nums);<span class="comment">//右孩子是后半部分的中点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组2</title>
    <url>/2022/11/23/%E7%AE%97%E6%B3%95/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%842/</url>
    <content><![CDATA[<h1 id="旋转数组2"><a class="markdownIt-Anchor" href="#旋转数组2"></a> 旋转数组2</h1>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给你一个数组，将数组中的元素向右轮转<code>k</code>个位置，其中<code>k</code>是非负数</p>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<p>在这之前我们已经能用两种方法解决这个问题，分别是申请辅助空间和翻转数组这两种方法。这次的方法是<strong>环状替换</strong>法。</p>
<p>方法一中使用额外数组的原因在于如果我们直接将每个数字放至它最后的位置，这样被放置位置的元素会被覆盖从而丢失。因此，从另一个角度，我们可以仅仅将被替换的<u>那一个元素</u>保存在变量<code>temp</code>中，从而避免了额外数组的开销。在这种方法里，每一轮可以确定一个数<code>a</code>的最终位置<code>b</code>，我们先将数<code>b</code>拷贝出来，这样就能避免等下将<code>a</code>放过来时覆盖了<code>b</code>的信息，拷贝好信息后我们就能将<code>a</code>直接放过去。然后在下一轮中，我们可以再去考虑<code>b</code>的最终位置，假设是<code>b'</code>，然后不停的重复上述过程。</p>
<p>具体来说，我们不妨假设一个很长的数组向右移动3个位置。我们从位置<code>0</code>开始，根据规则，位置<code>0</code>的元素将会被放置到<code>(0+3)%n=3</code>的位置上，我们先拷贝这个位置上的元素到临时变量temp里，然后将<code>0</code>位置的元素直接放过来，这样就确定了0位置元素的最终位置。然后我们再考虑位置<code>3</code>的元素的最终位置，它的最终位置是<code>6</code>，我们先拷贝<code>6</code>位置元素的信息，然后再把3位置的元素放过来...以此类推。</p>
<p>容易发现，当回到初始位置<code>0</code>时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们可以设置一个计数器，每确定好一个数的最终位置，计数器就加一，当计数器的数量刚好等于数组中的元素个数时程序就可以结束了。</p>
<p>###代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录交换了多少个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//从第一个数开始交换</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt; nums.length) &#123;<span class="comment">//直到所有的数都交换了一遍</span></span><br><span class="line">        <span class="comment">//注意，判断循环结束的条件不能加等号</span></span><br><span class="line">        <span class="comment">//移动了一个数，计数器才加一，如果等于了还进入循环的话，就会移动length+1个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[start];<span class="comment">//存储上一轮的b</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">toSwap</span> <span class="operator">=</span> (start + k) % nums.length;<span class="comment">//找到a下一个要交换的数b的下标</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(toSwap != start)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[toSwap];<span class="comment">//将b拷贝出来，因为等下a要覆盖它</span></span><br><span class="line">                nums[toSwap] = pre;<span class="comment">//将a（也就是上一轮的b）放到它的位置上</span></span><br><span class="line"></span><br><span class="line">                pre = temp;<span class="comment">//这一轮的b成为下一轮的a</span></span><br><span class="line">                toSwap = (toSwap + k) % nums.length;<span class="comment">//找到下一轮b的位置</span></span><br><span class="line">                count ++;<span class="comment">//找到了一个数a的最终位置</span></span><br><span class="line">            &#125;</span><br><span class="line">          	</span><br><span class="line">            nums[toSwap] = pre;<span class="comment">//当下一个位置与初始位置相同时，将上一轮的数放到初始位置</span></span><br><span class="line">            count ++;</span><br><span class="line">            start ++;<span class="comment">//从下一个数再开始</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小栈</title>
    <url>/2023/01/13/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h1 id="最小栈"><a class="markdownIt-Anchor" href="#最小栈"></a> 最小栈</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>设计一个支持<code>push</code>，<code>pop</code>，<code>top</code>操作，并能在常数时间内检索到最小元素的栈。实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象。</li>
<li><code>void push(int val)</code> 将元素<code>val</code>推入堆栈。</li>
<li><code>void pop()</code> 删除堆栈顶部的元素。</li>
<li><code>int top()</code> 获取堆栈顶部的元素。</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
</ul>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>其实这道题前半部分就是要实现一个栈的数据结构。这里有三个思路。第一个思路是完全自己手动写一个栈，但是要频繁涉及到数组的扩容等等，有些麻烦。第二个是完全借助Java里已经实现的Stack数据结构，这个方法在实现前几个功能时非常方便，但是在实现求最小元素时可能有些复杂，因为栈这个数据结构并不是很方便遍历里面的所有元素。第三个是借助Java里实现的其他数据结构，例如List来更方便的求最小元素。</p>
<p>这里我们对第一个思路没有做尝试，我们从第三个思路开始。前几个功能都很容易实现，通过List的add()和remove()方法配合一个指针就能实现。最后一个求最小值的方法，我们就借助List这个数据结构非常容易遍历的特点，遍历一遍求出整个数据结构里的最小值。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，入栈的时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，寻找最小元素的时间复杂度还是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack1</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; minstack;</span><br><span class="line">    <span class="type">int</span> top;<span class="comment">//指向栈顶位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack1</span><span class="params">()</span> &#123;</span><br><span class="line">        minstack = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);<span class="comment">//初始化容量为10</span></span><br><span class="line">        top = -<span class="number">1</span>;<span class="comment">//栈顶元素指向-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        minstack.add(++top,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        minstack.remove(top--);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.get(top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.min(minstack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>方法一虽然能通过，但是运行时间非常长，甚至达到了3000ms，因此我们尝试改进以上方法。方法一最慢的地方就在于求最小值，因为其他部分时间复杂度其实都是常数级别的。那改进的方法也很简单，也就是用空间换时间，也就是我们要想办法记录下栈中的最小值。</p>
<p>首先最理想情况下，我们能否只用一个变量就记录下最小值呢。这个答案是否定的，因为如果只用一个变量的话，我们弹栈时如果恰好把这个最小值弹出去了，我们就无法确定下一个最小值，到头来还是要重新遍历一遍。那所以我们考虑到要记录下一系列的最小值。</p>
<p>因为栈里面删除元素不会随机删除，而是只删除栈顶的元素，所以我们可以一个萝卜一个坑，同样设置一个最小栈来装原本栈中元素所对应的的最小值。当一个元素a入栈时，我们记录此时栈中最小元素i，接着，当元素b入栈时，我们只用比较i和b的关系，将其中的较小值（不妨假设是i）弹入到最小栈中。这样一来，假如b弹走了，最小栈的栈顶元素也相应弹出就好了。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，只有入栈需要遍历一遍</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，用空间换时间，用一个最小栈记录下每个状态所对应的最小值</li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack2</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack;<span class="comment">//用来记录数据</span></span><br><span class="line">    Stack&lt;Integer&gt; min;<span class="comment">//用来记录每个数据对应的最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack2</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        min = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        min.push(Integer.MAX_VALUE);<span class="comment">//首先入一个最大值进去，避免需要对第一次弹入数据特殊处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        min.push(Math.min(min.peek(),val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        min.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共前缀</title>
    <url>/2022/12/13/%E7%AE%97%E6%B3%95/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3>
<p>前面一周由于忙着完成研究生学校那边的任务以及寒假离校的事情，我暂停了博客的更新。现在终于回到家里了，我计划借助寒假的时间完成Java的学习！</p>
<h1 id="最长公共前缀"><a class="markdownIt-Anchor" href="#最长公共前缀"></a> 最长公共前缀</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>编写一个函数来查找字符串数组中的最长公共前缀</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>这道题我最直观的想法就是一一比对，我用第一个字符串的第一个字符去和其他所有字符串的第一个字符比较。如果这个字符在其他所有字符串里都存在，那么它就属于最长公共前缀，否则不属于，直接返回前面的公共前缀即可。</p>
<p>在我第一次按照这个思路编写的时候总是容易出现数组越界的问题，也就是遍历着遍历着发现后面的数组已经遍历完了。此时按照逻辑应该暂停程序，直接返回前面的最长前缀，但是这里的一些细节我一直处理不好，所以我干脆索性一开始直接找到最短的那个字符串，用它来遍历，如果它遍历完了那么就直接返回。</p>
<ul>
<li>时间复杂度：由于我需要将所有字符串比对一遍，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m\times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，其中<em>m</em>是字符串数组中的字符串的平均长度，<em>n</em>是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//由于最长前缀需要不停的增加，因此采用StringBuffer的数据类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> strs.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">      	<span class="comment">//寻找最短的字符串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minStr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> strs[minStr].length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].length() &lt; minLen) minStr = i;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//用最短的字符串进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs[minStr].length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> strs[minStr].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; )&#123;<span class="comment">//与其他字符串进行比较</span></span><br><span class="line">                <span class="keyword">if</span> (ch != strs[j].charAt(i))&#123;<span class="comment">//发生不一致，则直接返回前面的最长子串</span></span><br><span class="line">                    <span class="keyword">return</span> sb.toString();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  	<span class="comment">//如果这个字符和其他所有的字符串都比较完了，则可以开始比较下一个字符</span></span><br><span class="line">                    <span class="keyword">if</span> (j == len - <span class="number">1</span>)&#123;</span><br><span class="line">                        sb.append(ch);</span><br><span class="line">                      	<span class="comment">//如果比较到了某个字符串的最后一个字符，则可以直接返回前面的最长子串</span></span><br><span class="line">                        <span class="keyword">if</span> (i == strs[j].length() - <span class="number">1</span>) <span class="keyword">return</span> sb.toString();</span><br><span class="line">                        j = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        j ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>不难发现，我最原始的想法很简单，但是写出来的的代码很臃肿，需要考虑很多情况。那我们继续按照这个思路，看能不能优化。上面方法最麻烦的地方其实就在于：我每次都是一个字符一个字符的比较，这样我需要考虑很多细枝末节的情况，尤其是在处理指针越界的部分。那么为了改善这个问题，我们不妨一块一块的比较。</p>
<p>具体来说，第一个字符串和第二个字符串比较一下，取它们的最长子串，然后拿这个最长子串和第三个字符比较…这样操作起来就方便很多了。</p>
<p><u>方法一中的最长前缀是慢慢变长的，而这种方法的最长前缀是慢慢变短的</u></p>
<ul>
<li>时间复杂度：这种方法和上面的方法本质上还是一样的，所以时间复杂度还是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m\times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3>
<ul>
<li>通过从下标为1的开始检查可以有效处理数组中只有一个元素的特殊情况</li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> strs.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">      	<span class="comment">//直接从下标为1的字符串开始比</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len;i ++)&#123;</span><br><span class="line">         		<span class="comment">//注意，是每次拿前缀和字符串进行相比，而不是字符串和字符串进行比较</span></span><br><span class="line">            prefix = commonPrefix(strs[i],prefix);</span><br><span class="line">          	<span class="comment">//如果此时的前缀已经为空则不需要再继续比较下去了</span></span><br><span class="line">            <span class="keyword">if</span> (prefix.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//返回str1和str2的前缀</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonPrefix</span><span class="params">(String str1, String str2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> str1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> str2.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> len1 &lt; len2 ? len1 : len2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; index &lt; minLen; index++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(index) != str2.charAt(index))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3>
<p>按照这个将最长前缀逐渐缩短的策略，其实还有更简洁的方法</p>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];<span class="comment">//默认第一个字符串是最长子串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      	<span class="comment">//将前缀与所有字符串进行比较</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; strs.length)&#123;</span><br><span class="line">          	<span class="comment">//如果这个前缀不是当前字符串的前缀</span></span><br><span class="line">            <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>)&#123;</span><br><span class="line">              	<span class="comment">//那么就一个字符一个字符的缩短这个前缀，直达当前字符串前面包含这个前缀</span></span><br><span class="line">                prefix = prefix.substring(<span class="number">0</span>,prefix.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;<span class="comment">//再比较下一个字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子数和</title>
    <url>/2023/01/10/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E5%92%8C/</url>
    <content><![CDATA[<h1 id="最大子数和"><a class="markdownIt-Anchor" href="#最大子数和"></a> 最大子数和</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给你一个整数数组<code>nums</code>，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong>是数组中的一个连续部分。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>这是一道动态规划的问题，那我们就按照动态规划的步骤来解决这道题。首先我们通过暴力枚举，来找找看这道题的规律。</p>
<p>我们以<code>nums = [-2,1,-3,4,-1,2,1,-5,4]</code>为例。最直观的求最大子数和的方法是，从<code>nums[0]</code>开始，计算它的子数和，那分别有<em>9</em>种情况：第一种<code>sums1=nums[0]</code>，第二种<code>sums2=nums[0]+nums[1]</code>，第三种<code>sums2=nums[0]+nums[1]+nums[2]…nums[2]</code>有<em>8</em>种情况<code>sums1=nums[2]</code>，第二种<code>sums2=nums[2]+nums[3]</code>…那其实我们可以大致感觉出来，大致的规律是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f(n)=f(n-1)+nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>。</p>
<p>当如果这部分的子数是一直正数的话，这规律是成立的。那还有一种情况，一部分子数是一直为负数，那这样时候，前面的数都是累赘，最大的子数和其实就是<code>nums[i]</code>自身。那经过修正，状态转移方程其实就是$f(i)=max\left { f(i−1)+nums[i],nums[i] \right } <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，那边界条件当然就是</mtext></mrow><annotation encoding="application/x-tex">，那边界条件当然就是</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">界</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">然</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span></span></span></span>f(0)=nums[0]$这个特殊情况了。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，用动态规划的方法，我们只用遍历一遍数组即可求出最大子数和</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，我们可以用一个容器存储下来每个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>的值，然后在计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>时直接取出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的值
<ul>
<li>这里我的思维惯性让我直接先用哈希表作为这个容器，这样做的好处就是对应关系非常清晰，但是缺点就是很臃肿，时间性能不是很好</li>
<li>然后我想到了用数组存储，因为刚好数组的下标和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>的值一一对应，可以做到非常轻量</li>
<li>但其实我们可以用前天做的那道题的思路
<ul>
<li>这道题只考虑到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>二者之间的关系，那我用一个变量直接存储<code>pre</code>的值也能满足需求</li>
<li>那空间复杂度就变成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="代码1"><a class="markdownIt-Anchor" href="#代码1"></a> 代码1</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,nums[<span class="number">0</span>]);<span class="comment">//用哈希表记录f(i)的值，这里是初始化边界条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Math.max(map.get(i-<span class="number">1</span>)+nums[i],nums[i]);</span><br><span class="line">            map.put(i,sum);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//遍历一遍哈希表的value值，找到其中最大的那个，记为最大子数和</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry: map.entrySet())&#123;</span><br><span class="line">            maxSum = Math.max(maxSum,entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Integer[] sums = <span class="keyword">new</span> <span class="title class_">Integer</span>[nums.length];<span class="comment">//用Integer的数组来记录，方便之后直接读取数组中的最大值</span></span><br><span class="line">        sums[<span class="number">0</span>] = nums[<span class="number">0</span>];<span class="comment">//自动装箱机制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            sums[i] = Math.max(sums[i-<span class="number">1</span>]+nums[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.max(Arrays.asList(sums));<span class="comment">//利用Collections.max()方法直接返回数组中的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>], preSum = nums[<span class="number">0</span>];<span class="comment">//只记录前一个的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            preSum = Math.max(preSum+nums[i],nums[i]);</span><br><span class="line">            maxSum = Math.max(maxSum,preSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="知识点回顾"><a class="markdownIt-Anchor" href="#知识点回顾"></a> 知识点回顾</h2>
<h3 id="map的遍历方式"><a class="markdownIt-Anchor" href="#map的遍历方式"></a> map的遍历方式</h3>
<h4 id="for-each的方式"><a class="markdownIt-Anchor" href="#for-each的方式"></a> for-each的方式</h4>
<ul>
<li>在<code>map</code>中其实每一个数据都是用键值对来存储的，那这一对其实对应的数据结构是<code>entry</code></li>
<li>我们首先将<code>map</code>中的键值对全部转换为<code>entry</code>集合，然后对表的遍历就转化为对<code>entry</code>集合的遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer,String&gt; entry: map.entrySet())&#123;</span><br><span class="line">    entry.getKey();<span class="comment">//对键进行操作</span></span><br><span class="line">    entry.getValue();<span class="comment">//对值进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>基于这种方式可以更近一步</li>
<li>如果我们只用遍历表中的<code>key</code>或者<code>value</code>，我们其实不用把整个键值对全部转换为<code>entry</code>集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer key: map.keySet())&#123;</span><br><span class="line">		<span class="comment">//key就是所获得的键</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String value: map.values())&#123;</span><br><span class="line">		<span class="comment">//value就是所获得的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用迭代器进行遍历"><a class="markdownIt-Anchor" href="#用迭代器进行遍历"></a> 用迭代器进行遍历</h4>
<ul>
<li>值的注意的是，图<code>Map</code>是没有迭代器的（没有继承<code>Iterator</code>接口），只有集合<code>Set</code>才有</li>
<li>因此，我们首先将Map中的键值对全部转换为<code>entry</code>集合，然后用迭代器对其进行遍历</li>
<li>注意：迭代器的类型是<code>Map.Entry</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">		<span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;Integer,String&gt; entry = iterator.next();</span><br><span class="line">        entry.getKey();</span><br><span class="line">        entry.getValue();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回数组中的最值"><a class="markdownIt-Anchor" href="#返回数组中的最值"></a> 返回数组中的最值</h3>
<ul>
<li>借助 <code>Collections.max()</code>和<code>min()</code> 方法来快速返回数组中的最值。这里以最大值为例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span> &amp; Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; T <span class="title function_">max</span><span class="params">(Collection&lt;? extends T&gt; coll)</span> </span><br></pre></td></tr></table></figure>
<blockquote>
<p>Returns the maximum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection).<br />
This method iterates over the entire collection, hence it requires time proportional to the size of the collection.<br />
Params:<br />
coll – the collection whose maximum element is to be determined.<br />
Returns:<br />
the maximum element of the given collection, according to the natural ordering of its elements.</p>
</blockquote>
<ul>
<li>参数：输入的一定是<code>Collection</code>的子类，并且这个子类实现了<code>Comparable</code>接口
<ul>
<li><code>Collection</code>的子类包括<code>List</code> <code>Set</code> <code>Queue</code></li>
<li>因此如果想要返回数组中的最值，需要先将数组转化为以上的类型</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="comment">//max()方法需要的是一个`Collection`的子类</span></span><br><span class="line"><span class="comment">//借助Arrays.asList()方法将一个数组转换成一个List</span></span><br><span class="line"><span class="comment">//不能是基本数据类型int，因为int没有实现Comparable接口</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Collections.max(Arrays.asList(nums));</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Collections.min(Arrays.asList(nums));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的字母异位词</title>
    <url>/2022/12/02/%E7%AE%97%E6%B3%95/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="有效的字母异位词"><a class="markdownIt-Anchor" href="#有效的字母异位词"></a> 有效的字母异位词</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给定两个字符串<em>s</em>和<em>t</em>，编写一个函数来判断<em>t</em>是否是<em>s</em>的字母异位词。（若<em>s</em>和<em>t</em>中每个字符出现的次数都相同，则称<em>s</em>和<em>t</em>互为字母异位词）</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>这道题其实和昨天的题（<a href="https://keveinkk.github.io/2022/12/01/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/">字符串中第一个唯一字符</a>）非常类似，那么我很自然的就想到用一个<code>times[26]</code>数组统计每个字符串中的每个字符出现的次数，然后比较每个字符串的<code>times[26]</code>数组，如果两个字符串的这个两个数组相同，那么它们就是字母异位词，反之就不是。</p>
<ul>
<li>时间复杂度：只用将每个字符串遍历一遍就可以得到它的<code>times[26]</code>数组，然后比较两个<code>times[26]</code>数组是通过调用<code>Arrays.equals()</code>方法，它在底层也是将两个数组再遍历一遍，因此时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，申请了两个<code>times[26]</code>数组</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">  <span class="type">int</span>[] times1 = times(s);</span><br><span class="line">  <span class="type">int</span>[] times2 = times(t);</span><br><span class="line">  <span class="keyword">return</span> Arrays.equals(times1,times2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计字符串s中各个字符出现的频率</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] times(String s)&#123;</span><br><span class="line">  <span class="type">int</span>[] times = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">  	times[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3>
<ul>
<li>
<p><code>Arrays.equals(int[] a, int[] a2)</code></p>
<blockquote>
<p>Returns <code>true</code> if the two specified arrays of ints are <em>equal</em> to one another. Two arrays are considered equal if both arrays contain the same number of elements（两个数组包含的元素个数相同）, and all corresponding pairs of elements in the two arrays are equal（两个数组中对应的元素相同）. In other words, two arrays are equal if they contain the same elements in the same order（长度相同、元素顺序相同）. Also, two array references are considered equal if both are <code>null</code>（两个数组都为空时也相同）.</p>
</blockquote>
<ul>
<li>在Arrays类中 equals的实现是这样的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] a2)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (a==a2)<span class="comment">//如果两个引用指向同一块空间（包括都为null的特殊情况）</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (a==<span class="literal">null</span> || a2==<span class="literal">null</span>)<span class="comment">//只有一个为空则直接返回false</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> a.length;<span class="comment">//不要经常调用.length的属性</span></span><br><span class="line">  <span class="comment">//而是将这个属性赋给一个变量，调用这个变量</span></span><br><span class="line">	<span class="keyword">if</span> (a2.length != length)<span class="comment">//长度不等则直接返回false</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ArraysSupport.mismatch(a, a2, length) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ArraysSupport.mismatch(a,a2,length)</li>
</ul>
<blockquote>
<p>The <strong>mismatch()</strong> is a method that is defined under the Arrays class of Java.util package and it is used with respect to the two arrays passed as an argument in the mismatch method. This method returns the index at which two arrays passed as a parameter to the mismatch() function have the first unequal element（返回第一个不相等元素的下标）. It is quite useful to check whether two arrays contain the same corresponding elements or not（用于判断两个数组是否拥有对应相同的元素）. This responds when a mismatch occurs. If both arrays have corresponding elements same then this function returns -1（两个数组完全相同时返回-1）. We can understand its working by considering the following example:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mismatch</span><span class="params">(<span class="type">short</span>[] a, <span class="type">int</span> aFromIndex,</span></span><br><span class="line"><span class="params">                               <span class="type">short</span>[] b, <span class="type">int</span> bFromIndex,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> length)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (length &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[aFromIndex] != b[bFromIndex])</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">aOffset</span> <span class="operator">=</span> Unsafe.ARRAY_SHORT_BASE_OFFSET + (aFromIndex &lt;&lt; LOG2_ARRAY_SHORT_INDEX_SCALE);</span><br><span class="line">    <span class="type">int</span> <span class="variable">bOffset</span> <span class="operator">=</span> Unsafe.ARRAY_SHORT_BASE_OFFSET + (bFromIndex &lt;&lt; LOG2_ARRAY_SHORT_INDEX_SCALE);</span><br><span class="line">    i = vectorizedMismatch(</span><br><span class="line">      a, aOffset,</span><br><span class="line">      b, bOffset,</span><br><span class="line">      length, LOG2_ARRAY_SHORT_INDEX_SCALE);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    i = length - ~i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; length; i++) &#123;<span class="comment">//本质上还是遍历两个数组</span></span><br><span class="line">    <span class="keyword">if</span> (a[aFromIndex + i] != b[bFromIndex + i])</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>还有一种方法也可以快速的判断两个字符串中字符出现的频率是否是相同的。<em>t</em> 是s的异位词等价于<strong>两个字符串排序后相等</strong>。因此我们可以对字符串<em>s</em>和<em>t</em>分别排序，看排序后的字符串是否相等即可判断。</p>
<ul>
<li>时间复杂度：通过调用Arrats.sort()方法来对字符串进行排序，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，然后再判断两个排好序的数组是否相等，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，总的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：不需要额外的存储空间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">  <span class="type">char</span>[] arr1 = s.toCharArray();</span><br><span class="line">  <span class="type">char</span>[] arr2 = t.toCharArray();</span><br><span class="line">  Arrays.sort(arr1);</span><br><span class="line">  Arrays.sort(arr2);</span><br><span class="line">  <span class="keyword">return</span> Arrays.equals(arr1,arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的数独</title>
    <url>/2022/11/25/%E7%AE%97%E6%B3%95/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h1 id="有效的数独"><a class="markdownIt-Anchor" href="#有效的数独"></a> 有效的数独</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>请你判断一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><mo>×</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">9\times9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>的数独是否有效。只需要根据以下规则 ，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>宫内只能出现一次</li>
</ol>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>最直接的思路就是按照三条规则进行判断，看看每一行、每一列、每一个九宫格是否都满足要求</p>
<ul>
<li>时间复杂度：每检查一条规则就需要遍历一次二维数组，所以时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>3</mn><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(3N^{2} )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">3</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：这种方法需要申请三个一维数组来记录每个数字出现的次数，空间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>3</mn><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(3N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">      	<span class="comment">//遍历每一行以及每一列，检查每一行/列是否有效</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!judge(board,i))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//检查每一个九宫格是否有效</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i = i + <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j = j + <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!judge(board,i,j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断第n行和第n列是否正确</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] times1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>];<span class="comment">//记录每一个数字出现的次数</span></span><br><span class="line">      	<span class="comment">//检查第n行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[n][i] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">              	<span class="comment">//通过Character.getNumericValue(char)来获取字符内的数字</span></span><br><span class="line">                times1[Character.getNumericValue(board[n][i])]++;</span><br><span class="line">                <span class="keyword">if</span>(times1[Character.getNumericValue(board[n][i])] == <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//检查第n列</span></span><br><span class="line">        <span class="type">int</span>[] times2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][n] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                times2[Character.getNumericValue(board[i][n])]]++;</span><br><span class="line">                <span class="keyword">if</span>(times2[Character.getNumericValue(board[i][n])]] == <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断第一格为n，m的九宫格是否正确</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] times = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>];</span><br><span class="line">      	<span class="comment">//三个数字三个数字的跳跃</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[n+i][m+j] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    times[Character.getNumericValue(board[n+i][m+j])]]++;</span><br><span class="line">                    <span class="keyword">if</span>(times[Character.getNumericValue(board[n+i][m+j])]] == <span class="number">2</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3>
<ul>
<li>
<p>字符的比较</p>
<ul>
<li><code>char</code>是一个基本数据类型，只能用<code>==</code>来比较相等，如果想用<code>equals()</code>方法来比较，则要用<code>char</code>的封装对象<code>Character</code></li>
<li><code>String</code>是一个引用数据类型，用<code>==</code>来比较时比较的是两个字符串的引用是否指向同一个地址，要比较字符串内容是否相等时需要使用<code>equals()</code>方法</li>
</ul>
</li>
<li>
<p>字符的转化</p>
<ul>
<li>将<code>char</code>转化为<code>int</code></li>
<li><code>char</code>不能直接转化为<code>int</code>，直接转化得到的是相应字符的ASCII编码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)a;</span><br><span class="line"><span class="comment">//num=51,51是3的ASCII编码</span></span><br></pre></td></tr></table></figure>
<ul>
<li>利用<code>char</code>的封装类<code>Character</code>, 通过如下静态方法就可以直接实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNumericValue</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getNumericValue((<span class="type">int</span>)ch);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Character.getNumericValue(a);</span><br><span class="line"><span class="comment">//num=3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过两个字符直接相减（减'0'）就可以得到<code>int</code>值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> a - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="comment">//num=3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>方法一每检查一条规则就需要重新遍历一遍二维数组，这样其实很浪费时间，我们可以采用<strong>空间换时间</strong>的方法。</p>
<p>我们可以只用将数组遍历一遍，在这一次遍历的过程中记录下数组的三个信息，即</p>
<ol>
<li>每一行数字出现的次数 <code>row[i][j]= 3</code>代表第<code>i</code>行，数值为j的数出现了3次</li>
<li>每一列数字出现的次数 <code>colum[i][j] = 2</code>代表第<code>i</code>列，数值为<code>j</code>的数出现了2次</li>
<li>每一个九宫格内数字出现的次数 <code>subbox[i][j][k] = 1</code>代表在第<code>[i,j]</code>的九宫格里数字<code>k</code>出现了1次</li>
</ol>
<ul>
<li>时间复杂度：只用遍历一遍二维数组，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：需要两个二维数组、一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn><mo>×</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">3\times 3\times 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>的三维数组，空间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>3</mn><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(3N^{2} )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">3</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">      	<span class="comment">//第一个9代表有9行，第二个9代表最多数值有9个（数独里没有10和0）</span></span><br><span class="line">        <span class="type">int</span>[][] rows = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">      	<span class="comment">//同理</span></span><br><span class="line">        <span class="type">int</span>[][] columns = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">      	<span class="comment">//第一个3代表九宫格最多有3行，第二个3代表九宫格最多有3列，第三个9代表数值有9个</span></span><br><span class="line">        <span class="type">int</span>[][][] subboxes = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">      	<span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">              	<span class="comment">//获取每个格子里的字符数据</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">              	<span class="comment">//只要是数字</span></span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                  	<span class="comment">//减&#x27;0&#x27;是为了获取int数据</span></span><br><span class="line">                  	<span class="comment">//减1是为了将数据和数组下标需要匹配上，数值为1存储在0，数值为9存储在8</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                  	<span class="comment">//在一次遍历中，可以更新三个数组的信息</span></span><br><span class="line">                    rows[i][index]++;<span class="comment">//在第i行，该数字出现了一次</span></span><br><span class="line">                    columns[j][index]++;<span class="comment">//在第j列，该数字出现了一次</span></span><br><span class="line">                    subboxes[i/<span class="number">3</span>][j/<span class="number">3</span>][index]++;<span class="comment">//在该数字出现的九宫格里，该数字出现了一次</span></span><br><span class="line">                    <span class="keyword">if</span> (rows[i][index] &gt; <span class="number">1</span> || columns[j][index] &gt; <span class="number">1</span> || subboxes[i / <span class="number">3</span>][j / <span class="number">3</span>][index] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//只要有一个条件不满子就无效</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>对数器和比较器</title>
    <url>/2022/11/23/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%BE%83%E5%99%A8%20&amp;%20%E5%AF%B9%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="对数器"><a class="markdownIt-Anchor" href="#对数器"></a> 对数器</h1>
<ul>
<li>用自己产生随机数的方法来检验自己的编写算法是否正确</li>
<li>现有两个方法
<ul>
<li>方法A：想要测试的目标方法</li>
<li>方法B：容易实现，但是性能较差的方法</li>
</ul>
</li>
<li>实现一个随机样本产生器，使A和B同时运行随机生成的样本，检查结果是否一致</li>
<li>若不一致，则可以使用print的方法进行人工干预</li>
</ul>
<h4 id="java产生随机数"><a class="markdownIt-Anchor" href="#java产生随机数"></a> Java产生随机数</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.random()						<span class="comment">//[0,1)之间所有的小数，等概率的返回一个</span></span><br><span class="line">Math.random()*N					<span class="comment">//[0,N)之间所有的小数，等概率返回一个</span></span><br><span class="line">(<span class="type">int</span>)(Math.random()*N)	<span class="comment">//[o,N)之间所有的整数，等概率返回一个</span></span><br></pre></td></tr></table></figure>
<h3 id="比较器"><a class="markdownIt-Anchor" href="#比较器"></a> 比较器</h3>
<ul>
<li>重载比较运算符</li>
<li>比较器可以很好的应用在特殊标准的排序上，因为我们可以自定义排序标准</li>
</ul>
<h5 id="自定义排序标准"><a class="markdownIt-Anchor" href="#自定义排序标准"></a> 自定义排序标准</h5>
<ul>
<li>
<p><code>Arrays.sort()</code></p>
<ul>
<li><code>Arrays.sort()</code>重载了四类方法
<ol>
<li><code>Arrays.sort(T[] a)</code>: 对指定的T型数组按数字升序排序</li>
<li><code>Arrays.sort(T[] a, int formIndex, int toIndex)</code>: 对指定的T型数组在下标[formIndex, toIndex]之间排序</li>
<li><code>Arrays.sort(T[] a, Comparator&lt;? supre T&gt; c)</code>: 根据比较器产生的顺序对指定对象数组进行排序</li>
<li><code>Arrasy.sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c</code>): ...</li>
</ol>
</li>
</ul>
</li>
<li>
<p><code>Arrays.sort(T[] a)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">LENGTH</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">//产生长度为20的数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">30</span>;<span class="comment">//数组元素的值在[0,30)之间</span></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[LENGTH];</span><br><span class="line">    arr = randomGener(LENGTH,N);</span><br><span class="line">    System.out.print(<span class="string">&quot;随机产生的数组为：&quot;</span>);</span><br><span class="line">    display(arr);</span><br><span class="line">    Arrays.sort(arr);<span class="comment">//对arr进行升序排序</span></span><br><span class="line">    System.out.print(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">    display(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h83jzswsmnj31bi0hq0us.jpg" alt="" /></p>
</li>
<li>
<p><code>Arrays.sort(T[] a, int formIndex, int toIndex)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[LENGTH];</span><br><span class="line">arr2 = randomGener(LENGTH,N);</span><br><span class="line">System.out.print(<span class="string">&quot;随机产生的数组为：&quot;</span>);</span><br><span class="line">display(arr2);</span><br><span class="line">Arrays.sort(arr2,<span class="number">0</span>,<span class="number">9</span>);<span class="comment">//只对前半部分进行排序</span></span><br><span class="line">System.out.print(<span class="string">&quot;只对前半部分排序后的数组为：&quot;</span>);</span><br><span class="line">display(arr2);</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h83k3fliumj31de0ca40d.jpg" alt="" /></p>
</li>
<li>
<p><code>Arrays.sort(T[] a, Comparator&lt;? supre T&gt; c)</code></p>
</li>
<li>
<p><strong>注意这里的数据类型不能是基本数据类型</strong></p>
<ul>
<li>创建一个学生类，包含姓名、年级、年龄三个属性，分别对后两个属性进行升序和降序排序</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重载比较器</span></span><br><span class="line"><span class="comment">//按照 数据类型的属性a的升序排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> class 类名 <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;数据类型&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> 数据类型 compare(数据类型 o1, 数据类型 o2) &#123;</span><br><span class="line">    <span class="comment">//当返回值为负数时，第一个参数在前</span></span><br><span class="line">    <span class="comment">//当返回值为正数时，第二个参数在前</span></span><br><span class="line">    <span class="comment">//当返回值为0时，顺序无所谓</span></span><br><span class="line">    <span class="keyword">if</span>(o1.属性a &lt; o2.属性a)</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//第一个数先输出，第一个数小，所以时升序</span></span><br><span class="line">    <span class="keyword">if</span> (o1.属性a &gt; o2.属性a)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//第二个数先输出，第二个数小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Student;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentSort</span> &#123;</span><br><span class="line">    <span class="comment">//重载比较器</span></span><br><span class="line">    <span class="comment">//根据年级升序排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GradeAscendingComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(o1.grade &lt; o2.grade)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (o1.grade &gt; o2.grade)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载比较器</span></span><br><span class="line">    <span class="comment">//根据年龄降序排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AgeDescendingComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">//降序：大的先输出</span></span><br><span class="line">        <span class="comment">//o2&gt;o1，则先输出o2</span></span><br><span class="line">        <span class="comment">//o2&lt;o1，则先输出o1</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.age - o1.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;aaa&quot;</span>,<span class="number">8</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;bbb&quot;</span>,<span class="number">10</span>,<span class="number">15</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;ccc&quot;</span>,<span class="number">5</span>,<span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        Student[] stus = &#123;s1,s2,s3&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生信息为：&quot;</span>);</span><br><span class="line">        print(stus);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;按照年级升序排序的学生信息为：&quot;</span>);</span><br><span class="line">        Arrays.sort(stus,<span class="keyword">new</span> <span class="title class_">GradeAscendingComparator</span>());</span><br><span class="line">        print(stus);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;按照年龄降序排序的学生信息为：&quot;</span>);</span><br><span class="line">        Arrays.sort(stus,<span class="keyword">new</span> <span class="title class_">AgeDescendingComparator</span>());</span><br><span class="line">        print(stus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Student[] stus)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stus.length ; i++)&#123;</span><br><span class="line">            System.out.println(stus[i].name + <span class="string">&quot; &quot;</span> + stus[i].grade + <span class="string">&quot; &quot;</span> + stus[i].age);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h83kwq4abej30u00vkq4u.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>爬楼梯</title>
    <url>/2023/01/05/%E7%AE%97%E6%B3%95/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="爬楼梯"><a class="markdownIt-Anchor" href="#爬楼梯"></a> 爬楼梯</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>假设你正在爬楼梯。需要<code>n</code>阶你才能到达楼顶。每次你可以爬<code>1</code>或<code>2</code>个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<h2 id="方法一递归"><a class="markdownIt-Anchor" href="#方法一递归"></a> 方法一：递归</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<h4 id="穷举分析找到规律"><a class="markdownIt-Anchor" href="#穷举分析找到规律"></a> 穷举分析，找到规律</h4>
<ul>
<li>当台阶数是<em>1</em>时，有<em>1</em>种跳法，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(1)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>当台阶数是<em>2</em>时，有<em>2</em>种跳法，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">f(2)=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
<li>当台阶数是<em>3</em>时，可以选择从台阶<em>1</em>处跳两级，或者从台阶<em>2</em>处跳一级，那也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(3)=f(1)+f(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></li>
<li>当台阶数是<em>4</em>时，可以选择从台阶<em>2</em>处跳两级，或者从台阶<em>3</em>处跳一级，那也就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(4)=f(2)+f(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></li>
<li>……</li>
</ul>
<h5 id="确定最优子结构"><a class="markdownIt-Anchor" href="#确定最优子结构"></a> 确定最优子结构</h5>
<ul>
<li>根据穷举的分析那我们就很容易找到规律</li>
<li>当台阶数是<em>n</em>时，可以选择从台阶<em>n-2</em>处跳两级，或者从台阶<em>n-1</em>处跳一级，那也就是**<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)=f(n-2)+f(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>**</li>
</ul>
<h4 id="确定边界条件"><a class="markdownIt-Anchor" href="#确定边界条件"></a> 确定边界条件</h4>
<ul>
<li>显然，当台阶数分别为1和2时，跳法是不满足以上我们找到的规律的</li>
<li>因此边界条件就是
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(1)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">f(2)=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
</ul>
</li>
</ul>
<h5 id="写出状态转移方程"><a class="markdownIt-Anchor" href="#写出状态转移方程"></a> 写出状态转移方程</h5>
<p>$f(n)=\left{\begin{matrix}<br />
1\text{,n=1} \<br />
2\text{,n=2} \<br />
f(n-1)+f(n-2)\text{,else}<br />
\end{matrix}\right.  $</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^{n} )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，递归时间复杂度 = 解决一个子问题时间$\times <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>子问题个数。解决一个子问题的时间是</mtext></mrow><annotation encoding="application/x-tex">子问题个数。解决一个子问题的时间是</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">题</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">解</span><span class="mord cjk_fallback">决</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">题</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">是</span></span></span></span>O(1)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，但是解决</mtext></mrow><annotation encoding="application/x-tex">，但是解决</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">但</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">解</span><span class="mord cjk_fallback">决</span></span></span></span>n=k<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>的问题需要完全从</mtext></mrow><annotation encoding="application/x-tex">的问题需要完全从</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">题</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">完</span><span class="mord cjk_fallback">全</span><span class="mord cjk_fallback">从</span></span></span></span>n=1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>开始，一直到</mtext></mrow><annotation encoding="application/x-tex">开始，一直到</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">开</span><span class="mord cjk_fallback">始</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">到</span></span></span></span>n=k-1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，并且解决到</mtext></mrow><annotation encoding="application/x-tex">，并且解决到</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">解</span><span class="mord cjk_fallback">决</span><span class="mord cjk_fallback">到</span></span></span></span>n=i<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>时，又要从</mtext></mrow><annotation encoding="application/x-tex">时，又要从</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">又</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">从</span></span></span></span>n=1<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>开始重新计算一直计算到</mtext></mrow><annotation encoding="application/x-tex">开始重新计算一直计算到</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">开</span><span class="mord cjk_fallback">始</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">计</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">计</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">到</span></span></span></span>n=i-1$</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^{n} )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>) + climbStairs(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>使用带备忘录的方法，也就是用空间换时间。我们在计算时间复杂度的时候发现，其实很多东西都在重复计算，例如：我们在计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>的时候算了一边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span>，那我们在计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>20</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(20)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>的时候可能又算了一遍<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span>。我们将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span>的值算第一遍的时候记录下来，然后之后如果还需要用到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">5</span><span class="mclose">)</span></span></span></span>时，就可以直接直接查找，省去了计算的过程。</p>
<p>用于存储的数据结构一般使用哈希表。我一开始的时候想的是用链表来存储，然后根据下标来查找，但其实这个方法有一个问题：其实我们计算的过程不一定是连贯的。并不是我们先算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>然后算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>再算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span>，我们可能是跳着算的，那么就会导致链表不连贯，存储发生问题。所以最后还是用哈希表，一个key对应一个value来存储</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，所有的函数值只用计算一遍即可</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，需要用一个哈希表记录计算的结果</li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自顶向下，使用迭代来计算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//用哈希表存储</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(n)) <span class="keyword">return</span> map.get(n);<span class="comment">//如果哈希表中已经记录了对应的值，则直接返回即可</span></span><br><span class="line">        map.put(n,climbStairs(n-<span class="number">1</span>)+climbStairs(n-<span class="number">2</span>));<span class="comment">//如果没有，则需要计算，并且把计算的结果存储到哈希表中</span></span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自底向上，使用循环来计算</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            map.put(i,map.get(i-<span class="number">1</span>) + map.get(i-<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>移动零</title>
    <url>/2022/11/23/%E7%AE%97%E6%B3%95/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="移动零"><a class="markdownIt-Anchor" href="#移动零"></a> 移动零</h1>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。<strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>我最先联想到昨天做过的数组轮转问题，我每找到一个0，我就把这个0移动到数组的最后，这样的情况下前面的非零的数的顺序也不会有变化。</p>
<p>这是一个非常简单的想法，我再进步一的优化。每一次轮转也不需要轮转数组中的所有元素，只用把第一个为零的元素（前面的元素已经满足要求，不动即可）转移到最后一个不为0的元素（再后面的元素都为0也满足要求）之后就好了。我设置了两个指针low 和 high，分别指向第一个为0的元素，以及最后一个不为0的元素。</p>
<p>进一步我发现，high指针（从后往前找到第一个非零元素）其实不会怎么移动，每一轮下来要么不动（前面没有0，不需要轮转），要么就向前移动一个（一轮下来只会找到一个0）。然而low指针（从前往后找到第一个零元素）的移动跨度可能会非常大，每一轮都是在上一轮的基础上继续向后寻找，找下一个零元素。所以可以在流程开始之前就确定high指针的位置，然而low指针的位置就要根据每一轮动态的变化了。</p>
<p>在每一轮里，一旦low指针找到了一个0元素，那么就把low和high之间的元素左轮转一个位置，这样0元素就到了这个区间最后的位置，区间中的数相对位置不变的向前移动了一位。</p>
<p>一次轮转之后，high指针要前移一位（因为0元素被放到了最后），low指针不变（因为新向前移动的数还没有判断是否为0），所以我们要再次寻找下一个0元素。</p>
<ul>
<li>这种方法首先需要遍历一整遍数组，在每一轮中，一旦需要轮转元素，就又要遍历一遍这一轮的所有数，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{2} )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，并且由于又要遍历数组，又要实现轮转，代码的长度也很长</li>
<li>由于不需要额外的辅助空间，空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//low标记第一个为0的下标，high标记最后一个不为0的下标</span></span><br><span class="line">		<span class="comment">//确定high指针的位置</span></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[high] != <span class="number">0</span>) </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			high --;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">			<span class="comment">//i寻找从low 到 high 第一个0</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low;</span><br><span class="line">			<span class="keyword">while</span>(i &lt; high)&#123;</span><br><span class="line">				<span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">					low = i;</span><br><span class="line">					turnLeft(nums,low,high);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				i ++;</span><br><span class="line">			&#125;</span><br><span class="line">			high --;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//nums数组从i到j下标所有数向左轮转一位</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">turnLeft</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    	reverse(nums,i,j);</span><br><span class="line">    	reverse (nums,i,j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换nums数组中i和j两个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (i == j) </span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	nums[i] = nums[i] ^ nums[j];</span><br><span class="line">    	nums[j] = nums[i] ^ nums[j];</span><br><span class="line">    	nums[i] = nums[i] ^ nums[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使nums数组中i到j间的数逆序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    		swap(nums,i++,j--);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>双指针其实不一定要呆板的规定一个指针从前往后遍历，另一个从后往前遍历。我们可以根据不同的特点重新设置两个指针的功能，一般而言双指针可以将数组划分成三个部分，根据三个部分不同的功能再来设置指针的位置。</p>
<p>比如在这一题中，可以设置一个指针<code>right</code>指向已经整理过的非零数组的末尾，另一个指针left指向待处理的数。也就是说，<code>right</code>指针左边全部是非零元素，<code>left</code>指针右边全部是待处理的元素，<code>right</code>指针和left指针中间都是0</p>
<p><code>left</code>指针不停的向后移动，<code>left</code>指针每碰到一个数，如果这个数为0，那就跨过它继续向后找，同时<code>right</code>指针向后移动一位；如果不是0，就把它放到非0元素序列的末尾(right指针指向的地方)。</p>
<p>这样一方面确保了非零元素之间相对位置的有序（按照遍历到的顺序调整的数，所以调整之后也是有序的），并且两个指针移动的方向相同，只用遍历一遍数组，每一轮中也只用交换两个数的位置，操作更简单。</p>
<ul>
<li>这种方法只用遍历一遍数组，如果left指针遇到了非零数，也只用做简单的交换操作，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左指针指向非零元素的末尾</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//右指针指向待调整的数</span></span><br><span class="line">		<span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">      <span class="comment">//如果是0，则继续向后遍历</span></span><br><span class="line">      <span class="comment">//如果非0，则将其向前移动</span></span><br><span class="line">			<span class="keyword">if</span> (nums[right] != <span class="number">0</span> ) &#123;</span><br><span class="line">				swap(nums,left,right);</span><br><span class="line">				left ++;</span><br><span class="line">			&#125;</span><br><span class="line">			right ++;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换nums数组中i和j两个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (i == j) </span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	nums[i] = nums[i] ^ nums[j];</span><br><span class="line">    	nums[j] = nums[i] ^ nums[j];</span><br><span class="line">    	nums[i] = nums[i] ^ nums[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表</title>
    <url>/2022/12/23/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="环形链表"><a class="markdownIt-Anchor" href="#环形链表"></a> 环形链表</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给你一个链表的头节点head，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数pos来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回true。 否则，返回false。</p>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>借助今天刚好在学的<code>HashSet</code>无序且不能重复的特性，我们可以把链表中的节点一一都放到哈希表中，如果哈希表中添加元素失败，则代表有个节点被重复添加了，证明这是一个环形链表；否则当链表顺利遍历完，所有节点成功添加，则代表这个链表中不存在环。</p>
<p>我起初会担心，如果一个链表中两个节点，虽然不存在环，但是它们的数据部分存储相同的值，这会不会也会导致节点添加失败。但其实是不用担心的，我们在<code>HashSet</code>中，设置泛型为<code>ListNode</code>，这样，只有节点的数据部分和指针部分都完全相同，才会导致节点添加失败</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，需要将整个链表遍历一次</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，需要将整个链表中所有的节点放到一个哈希表里才能判断</li>
</ul>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">          	<span class="comment">//添加成功add方法返回true，添加失败返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!set.add(head)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>这道题还有一个非常巧妙的方法，也就是快慢指针方法。</p>
<p>我们设置两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，快慢指针都指向起点的头节点。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，如果链表中不存在环，那么当慢节点到达链表尾部时，程序结束。如果链表中存在环，那么在环中每移动一次，快慢指针的距离就会更近一个节点，环最长有<em>N</em>个节点，那最多走<em>N</em>轮即可。</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>猜数游戏</title>
    <url>/2022/11/23/%E7%AE%97%E6%B3%95/%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="猜数游戏"><a class="markdownIt-Anchor" href="#猜数游戏"></a> 猜数游戏</h1>
<h3 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h3>
<p>我在做Java一个简单的猜数游戏时突发奇想，能不能编写一个程序让计算机自己产生一个随机数，自己再猜。</p>
<h2 id="方法一二分查找法"><a class="markdownIt-Anchor" href="#方法一二分查找法"></a> 方法一：二分查找法</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>解决这个问题很容易就能想到用二分查找来高效的解决，但是我在实际做的过程中发现自己对二分查找的理解还是差了一点。</p>
<p>先看看我的第一个版本的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">guessNum</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(flag &lt; <span class="number">0</span>)&#123;<span class="comment">//猜小了，则输出右半部分的中点</span></span><br><span class="line">    <span class="keyword">return</span> (mid + high) / <span class="number">2</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;<span class="comment">//猜大了，则输出左半部分的中点</span></span><br><span class="line">    <span class="keyword">return</span> (low + mid) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (count &lt;= <span class="number">100</span> &amp;&amp; guess != numToguess)&#123;</span><br><span class="line">	<span class="keyword">if</span> (guess &gt; numToguess)&#123;</span><br><span class="line">		System.out.println(guess + <span class="string">&quot; 大于 &quot;</span> + numToguess + <span class="string">&quot;猜大了，请再试一次&quot;</span>);</span><br><span class="line">		guess = guessNum(<span class="number">1</span>,a,guess);</span><br><span class="line">		count ++;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(guess + <span class="string">&quot; 小于 &quot;</span> + numToguess + <span class="string">&quot;猜小了，请再试一次&quot;</span>);</span><br><span class="line">    a = guess;</span><br><span class="line">    guess = guessNum(-<span class="number">1</span>,guess,b);</span><br><span class="line">    count ++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分查找的精髓在于<u>每一次查找之后都能舍弃另一半的信息</u>，然而运行我上面的代码会发现，我每次猜测的数据都在左右不停的摇摆。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8dp35qixlj30vm0midhs.jpg" alt="" /></p>
<p>在熟悉通过数组来实现二分查找后，我发现自己并不能很轻松的解决这个问题，我开始思考原因。</p>
<p>在数组里之所以每次都能做到精确的划分出目标所在的区间，是因为我们巧妙的设置了<code>low</code>和<code>high</code>两个指针。每一次比较之后，都根据目标和中间数据的大小关系来调整<code>low</code>或者<code>high</code>指针，而每次查找的数据都是在<code>low</code>和<code>high</code>指针之间查找，并不会超过这个区域。也就是说，<u>二分查找之所以能每查找一轮都能舍弃另一半的原因，在于只在<code>low</code>和<code>high</code>指针之间查找，每查找一轮都要修改这个区间</u>。</p>
<p>那么想要解决我现在的问题我们就要重新检查我们是否真的发挥了<code>low</code>和<code>high</code>指针的作用。不难发现，在<code>guess = guessNum(1,a,guess);</code>和<code>guess = guessNum(-1,guess,b);</code>两个关键的划分区间的操作中，我的a和b指针从来都没有发生过改变，也就是查找的范围一直没有变：要么就在最左边查找、要么就在最右边查找，无法做到真正的二分。</p>
<p>要解决这个问题，我们只需要根据每一轮查到的结果来及时调整<code>low</code>或者<code>high</code>指针即可，以下是完整的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Random</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> random;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> low;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHigh</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.random;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRandom</span><span class="params">(<span class="type">int</span> random)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.random = random;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLow</span><span class="params">(<span class="type">int</span> low)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.low = low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHigh</span><span class="params">(<span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.high = high;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Random()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Random(<span class="type">int</span> random)&#123;</span><br><span class="line">        <span class="built_in">this</span>.random = random;</span><br><span class="line">    &#125;</span><br><span class="line">    Random(<span class="type">int</span> random, <span class="type">int</span> low, <span class="type">int</span> high)&#123;</span><br><span class="line">        <span class="built_in">this</span>.random = random;</span><br><span class="line">        <span class="built_in">this</span>.low = low;</span><br><span class="line">        <span class="built_in">this</span>.high = high;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//产生一个在low～high之间的随机数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">randGen</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数字区间&quot;</span>);</span><br><span class="line">        java.util.<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner((System.in));</span><br><span class="line">        setLow(scanner.nextInt());</span><br><span class="line">        setHigh(scanner.nextInt());</span><br><span class="line">        <span class="type">int</span> <span class="variable">ran</span> <span class="operator">=</span> getLow() - <span class="number">1</span> + (<span class="type">int</span>)(Math.random() *(getHigh()-getLow()));</span><br><span class="line">        setRandom(ran);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//返回low与high的中点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mid</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span>.getLow() + <span class="built_in">this</span>.getHigh()) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">LIMIT_GUESS</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//控制猜测的次数，避免死循环</span></span><br><span class="line">    <span class="keyword">private</span> Random random;<span class="comment">//Random是Guess的一个属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Guess</span><span class="params">(Random random)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.random = random;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Random <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">guess</span><span class="params">()</span>&#123;</span><br><span class="line">        getRandom().randGen();<span class="comment">//产生随机数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">guess</span> <span class="operator">=</span> getRandom().mid();<span class="comment">//猜测中点的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt;= LIMIT_GUESS &amp;&amp; guess != getRandom().getRandom())&#123;</span><br><span class="line">            <span class="keyword">if</span> (guess &gt; getRandom().getRandom())&#123;</span><br><span class="line">                System.out.println(guess + <span class="string">&quot; 大于 &quot;</span> + getRandom().getRandom() + <span class="string">&quot;猜大了，请再试一次&quot;</span>);</span><br><span class="line">                getRandom().setHigh(guess);<span class="comment">//猜大了，则及时调整high指针</span></span><br><span class="line">                guess = getRandom().mid();</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(guess + <span class="string">&quot; 小于 &quot;</span> + getRandom().getRandom() + <span class="string">&quot;猜小了，请再试一次&quot;</span>);</span><br><span class="line">                getRandom().setLow(guess);<span class="comment">//猜小了，则及时调整low指针</span></span><br><span class="line">                guess = getRandom().mid();</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜！猜对了，是 &quot;</span> + guess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">Guess</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Guess</span>(random);</span><br><span class="line">        test.guess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8dq3yz1rjj30vm0tutbc.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>验证二叉搜索树</title>
    <url>/2022/12/25/%E7%AE%97%E6%B3%95/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="验证二叉搜索树"><a class="markdownIt-Anchor" href="#验证二叉搜索树"></a> 验证二叉搜索树</h1>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效二叉搜索树BST定义如下：</p>
<ul>
<li>
<p>节点的左子树只包含小于当前节点的数。</p>
</li>
<li>
<p>节点的右子树只包含大于当前节点的数。</p>
</li>
<li>
<p>所有左子树和右子树自身必须也是二叉搜索树。</p>
</li>
</ul>
<h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h2>
<h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3>
<p>我们知道二叉搜索树的特性是，二叉搜索树<strong>中序遍历</strong>得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。</p>
<p>最简单的思路就是我们先中序遍历一遍整个二叉树，得到一个序列，然后再遍历一遍整个序列。如果这个序列中的数值是升序排列的，那么就代表这是一个二叉搜索树，否则就不是</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，先将二叉树中的所有节点遍历一遍，得到中序遍历的结果，然后再遍历一遍这个结果即可。</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="二叉树的遍历"><a class="markdownIt-Anchor" href="#二叉树的遍历"></a> 二叉树的遍历</h3>
<h4 id="前序遍历"><a class="markdownIt-Anchor" href="#前序遍历"></a> 前序遍历</h4>
<h5 id="递归实现"><a class="markdownIt-Anchor" href="#递归实现"></a> 递归实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">preOrderTraverse1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//遍历的结果放到一个List中输出</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>)&#123;</span><br><span class="line">        list.add(root);<span class="comment">//先将根节点添加到最后的结果中</span></span><br><span class="line">        preOrderTraverse1(root.left);<span class="comment">//再访问左孩子</span></span><br><span class="line">        preOrderTraverse1(root.right);<span class="comment">//最后访问右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="迭代实现"><a class="markdownIt-Anchor" href="#迭代实现"></a> 迭代实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">preOrderTraverse2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="literal">null</span>)&#123;<span class="comment">//如果还有根结点</span></span><br><span class="line">            list.add(temp);<span class="comment">//每次访问到的都是根节点，将跟节点添加到结果中</span></span><br><span class="line">            stack.push(temp);<span class="comment">//根结点入栈</span></span><br><span class="line">            temp = temp.left;<span class="comment">//寻找它的左孩子</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//到达叶子节点后</span></span><br><span class="line">            temp = stack.pop();<span class="comment">//根据栈返回上一个节点</span></span><br><span class="line">            temp = temp.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h4>
<h5 id="递归实现-2"><a class="markdownIt-Anchor" href="#递归实现-2"></a> 递归实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">inOrderTraverse1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>)&#123;</span><br><span class="line">        inOrderTraverse1(root.left);</span><br><span class="line">        list.add(root);</span><br><span class="line">        inOrderTraverse1(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="迭代实现-2"><a class="markdownIt-Anchor" href="#迭代实现-2"></a> 迭代实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">inOrderTraverse2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(temp);</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            temp = stack.pop();<span class="comment">//叶子结点弹出的都是左孩子</span></span><br><span class="line">            list.add(temp);<span class="comment">//将左孩子加入结果list中</span></span><br><span class="line">            temp = temp.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h4>
<h5 id="递归实现-3"><a class="markdownIt-Anchor" href="#递归实现-3"></a> 递归实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">postOrderTraverse1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>)&#123;</span><br><span class="line">        postOrderTraverse1(root.left);</span><br><span class="line">        postOrderTraverse1(root.right);</span><br><span class="line">        list.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="迭代实现-3"><a class="markdownIt-Anchor" href="#迭代实现-3"></a> 迭代实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrderTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    TreeNode cur, pre = <span class="literal">null</span>;</span><br><span class="line">		Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        cur = stack.peek();</span><br><span class="line">        <span class="keyword">if</span> ((cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) || (pre != <span class="literal">null</span> &amp;&amp; (pre == cur.left || pre == cur.right))) &#123;</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            stack.pop();</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>)</span><br><span class="line">            		stack.push(cur.right);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>)</span><br><span class="line">            		stack.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();<span class="comment">//用栈来辅助遍历二叉树</span></span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//最后的遍历结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历：左-根-右</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>)&#123;<span class="comment">//只要没有找到最左边的叶子结点，就一直向下寻找</span></span><br><span class="line">                stack.push(node);<span class="comment">//每找到一个节点，就入栈</span></span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//找到了最左边的叶子结点后</span></span><br><span class="line">                node = stack.pop();<span class="comment">//最左边的叶子节点出栈</span></span><br><span class="line">                list.add(node);<span class="comment">//加入到最后遍历的结果中</span></span><br><span class="line">                node = node.right;<span class="comment">//向后回退，从左孩子退到根结点，再从根结点退到右孩子</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//遍历最后的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; list.size();i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i).val &lt;= list.get(i-<span class="number">1</span>).val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h2>
<h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3>
<p>当然我们也不一定需要再单独遍历一遍中序遍历的结果，对于结果的处理可以完美的融入遍历的过程中。</p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，在遍历的过程中就可以完成对结果的检验</li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">      	<span class="comment">//用于记录前一个节点的值</span></span><br><span class="line">      	<span class="comment">//注意需要使用长整型，因为节点数值的取值范围是全部整型</span></span><br><span class="line">      	<span class="comment">//如果直接使用int，则比较的结果有误差</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">              	<span class="comment">//遍历到左孩子，将左孩子与前面一个节点进行比较</span></span><br><span class="line">                <span class="keyword">if</span> (temp.val &lt;= pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                pre = (<span class="type">long</span>) temp.val;<span class="comment">//更新前一个节点的值</span></span><br><span class="line">                root = temp.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三</h2>
<h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3>
<p>用递归的方法来实现这道题。我们知道，如果二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。那我们就根据这个值的大小来设计递归函数。</p>
<p>我们不停的判断一个节点的取值范围是否是合法的。</p>
<ul>
<li>
<p>如果是一个左节点：那它的取值范围是小于根结点，并且大于根结点的最小值</p>
</li>
<li>
<p>如果是一个右节点：那它的取值范围是大于根结点，并且小于根结点的最大值</p>
</li>
<li>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，将所有节点的取值范围检查一遍即可</p>
</li>
<li>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，我们的递归深度就是所有的节点数，有多少个节点我们就需要递归多少次</p>
</li>
</ul>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      	<span class="comment">//注意取值范围要真包含int的取值范围</span></span><br><span class="line">        <span class="keyword">return</span> valid(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(TreeNode node, <span class="type">long</span> low, <span class="type">long</span> up)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.val &lt;= low || node.val &gt;= up) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> valid(node.left, low, node.val) &amp;&amp; valid(node.right, node.val, up);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2022/11/23/%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="计数排序"><a class="markdownIt-Anchor" href="#计数排序"></a> 计数排序</h1>
<h5 id="算法描述"><a class="markdownIt-Anchor" href="#算法描述"></a> 算法描述</h5>
<ul>
<li>计数排序是一种<u>稳定</u>的排序算法。使用一个额外数组<code>C</code>，其中第<code>i</code>个元素是待排序数组<code>arr</code>中值等于<code>i</code>的元素个数，然后根据数组<code>C</code>来将<code>arr</code>中的元素放到正确的位置
<ul>
<li>假设现在对学校里的所有学生按照年龄进行排序，则申请一个0到30的数组C</li>
<li>遍历一遍所有学生的年龄，如果一个学生的年龄是18，则<code>C[18]++</code></li>
<li>遍历结束后，顺序输出数组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>×</mo><mi>C</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i\times C[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>即可</li>
</ul>
</li>
<li>它只能对整数进行排序</li>
<li>计数排序的核心在于：将输入的数据转化为键存储在额外开辟的数组空间中</li>
</ul>
<h5 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countSotr</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//遍历数组，求数组的最大值和最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            max = (max &gt; nums[i]) ? max : nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组中所有的数的取值都比max小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> max + <span class="number">1</span>;<span class="comment">//申请的辅助空间的数组长度</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            arr[nums[i]]++;<span class="comment">//arr[i]存储着nums中值为i的元素的个数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指向nums数组的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[i] &gt; <span class="number">0</span>)&#123;<span class="comment">//使每一个arr[i]都输出完</span></span><br><span class="line">                nums[index] = i;</span><br><span class="line">                index ++;</span><br><span class="line">                arr[i] --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="算法分析"><a class="markdownIt-Anchor" href="#算法分析"></a> 算法分析</h5>
<ul>
<li>时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，由于计数排序不是比较排序，它的速度远快于任何排序算法</li>
<li>空间复杂度：计数排序中所使用的辅助空间与数组中的最大值有关，所以当数组中的数很大时，计数排序需要很夸张的辅助空间。</li>
<li>也因此，计数排序不适用于大部分的情况，但对于某些特定的情况，计数排序的效率会非常的高</li>
</ul>
<h3 id="完整代码"><a class="markdownIt-Anchor" href="#完整代码"></a> 完整代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">LENGTH</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[LENGTH];</span><br><span class="line">        nums = randomGen(LENGTH,MAX);</span><br><span class="line">        <span class="type">int</span>[] test = (<span class="type">int</span>[])Arrays.copyOf(nums,nums.length);</span><br><span class="line"></span><br><span class="line">        countSotr(nums);</span><br><span class="line">        Arrays.sort(test);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(nums,test))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;排序成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countSotr</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//遍历数组，求数组的最大值和最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            max = (max &gt; nums[i]) ? max : nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组中所有的数的取值都比max小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> max + <span class="number">1</span>;<span class="comment">//申请的辅助空间的数组长度</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            arr[nums[i]]++;<span class="comment">//arr[i]存储着nums中值为i的元素的个数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指向nums数组的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[i] &gt; <span class="number">0</span>)&#123;<span class="comment">//使每一个arr[i]都输出完</span></span><br><span class="line">                nums[index] = i;</span><br><span class="line">                index ++;</span><br><span class="line">                arr[i] --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomGen(<span class="type">int</span> length, <span class="type">int</span> max)&#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; length; i++)&#123;</span><br><span class="line">            nums[i] = (<span class="type">int</span>) (Math.random()*max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h84s2ozzlij30u60cyjs7.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
