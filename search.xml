<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java - 1st Week - Summary</title>
    <url>/2022/11/07/Java/Java%20-%201st%20Week%20-%20Summary/</url>
    <content><![CDATA[<h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><p align="right">10.26-11.05</p>

<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我决定从22.10.26开始重新扎实的再次学习一遍Java语言，并且计划将自己的学习过程以博客的形式记录下来。</p>
<p>由于很多知识在前期都已经学过了，因此第一周的学习还是非常容易上手的，但我在之前的学习中忽略了很多细小的知识点，或者没有弄清楚其中的原理，因此这篇博客着重回顾这些容易被我忽视的内容。</p>
<h2 id="常用的终端命令"><a href="#常用的终端命令" class="headerlink" title="常用的终端命令"></a>常用的终端命令</h2><p>在Mac上快捷打开Terminal的方式：通过 <strong>聚焦搜索</strong> 快捷键 <code>command + space</code>的方式，搜索<code>ter</code>即可</p>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>clear</code></td>
<td align="center">清空屏幕中的内容</td>
</tr>
<tr>
<td align="center"><code>command + q</code></td>
<td align="center">退出终端</td>
</tr>
<tr>
<td align="center"><code>command + w</code></td>
<td align="center">关闭当前窗口</td>
</tr>
<tr>
<td align="center"><code>control + c</code></td>
<td align="center">结束当前进程</td>
</tr>
</tbody></table>
<h3 id="与目录有关操作"><a href="#与目录有关操作" class="headerlink" title="与目录有关操作"></a>与目录有关操作</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>cd + folder_name</code></td>
<td align="center">进入名为folder_name的文件夹</td>
</tr>
<tr>
<td align="center"><code>cd + -</code></td>
<td align="center">回到上一个访问的目录</td>
</tr>
<tr>
<td align="center"><code>cd + /</code></td>
<td align="center">回到根目录</td>
</tr>
<tr>
<td align="center"><code>cd + ../</code></td>
<td align="center">回到当前目录的上一级</td>
</tr>
<tr>
<td align="center"><code>pwd</code></td>
<td align="center">显示当前目录</td>
</tr>
<tr>
<td align="center"><code>ls</code></td>
<td align="center">显示当前目录下的所有文件</td>
</tr>
</tbody></table>
<h2 id="Java语言简介"><a href="#Java语言简介" class="headerlink" title="Java语言简介"></a>Java语言简介</h2><ul>
<li><p>Java语言三大模块</p>
<ol>
<li>Java SE 标准版</li>
<li>Java EE 企业版</li>
<li>Java ME 微型版</li>
</ol>
</li>
<li><p>Java特性</p>
<ol>
<li>简单：Java不再支持多继承、Java屏蔽了指针的概念、Java底层使用C++实现</li>
<li>面向对象：纯粹的面向对象编程</li>
<li>可移植性：Java可以一次编译，在多个平台上运行<ul>
<li>Java程序运行在Java虚拟机JVM上，JVM运行在操作系统上，而不是直接运行在操作系统上，这样就可以屏蔽底层的差异</li>
</ul>
</li>
<li>多线程</li>
<li>健壮性：借助GC机制，也就是自动垃圾回收机制，Java语言运行中产生的垃圾可以自动回收，不需要程序员手动处理</li>
</ol>
</li>
<li><p>Java的加载与执行</p>
<ul>
<li><p>Java程序的长记性分为 <u>编译</u> 和 <u>运行</u> 两个阶段</p>
</li>
<li><p><u>编译</u>：将.java的源文件 转换为 .class的字节码文件</p>
<ul>
<li><code>javac</code> 命令是java编译器工具，可以在Terminal中直接使用</li>
<li>使用规则：<code>javac java源文件的路径</code></li>
<li>Java源文件在编译时可以生成多个字节码文件，字节码文件可以跨平台使用</li>
<li><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7wjly2gi1j31e80dw75n.jpg"></li>
<li>使用javac命令后，在.java文件的目录下就会生成.class的字节码文件</li>
<li><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7wjps4dh6j312a0rkjum.jpg"></li>
</ul>
</li>
<li><p><u>运行</u>：将.class的字节码文件 转化为 可执行的二进制文件</p>
<ul>
<li><p><code>java</code> 命令是java运行工具，java命令会启动JVM，JVM会启动 <code>ClassLoader</code> 类加载器，类加载器在硬盘上搜索字节码文件，然后将其装载到JVM上</p>
</li>
<li><p>使用规则</p>
<ol>
<li>首先将目录切换到字节码文件所在的目录下</li>
<li>输入 <code>java 类名</code>（注意不要加后缀名.class）！</li>
</ol>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7wjr20x2oj31ge0qw78b.jpg"></p>
</li>
</ul>
</li>
<li><p>有关于 <code>javac</code> 与 <code>java</code>  命令</p>
<ul>
<li>这两个命令配置在JDK的bin目录下，而<code>echo $JAVA_HOME</code>指向了JDK的安装目录</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7wjyo0f32j31e80dwjtd.jpg"></p>
<ul>
<li><p>我们需要了解系统是如何搜索一个命令的</p>
<ul>
<li>当我们输入一个命令 <code>ping 1.1.1.1</code>时，系统会在当前目录下搜索这个命令.如果当前目录下没有这个命令，那么系统会在环境变量PATH指定的路径中继续进行搜索（这个命令不止包含Java中的命令），如果还找不到的话系统会报错</li>
<li>也就是说 <strong>PATH 的作用是指定命令搜索路径</strong>，在命令行下面执行命令如<code>javac</code>编译时，它会到PATH变量所指定的路径中查找看是否能找到相应的命令程序</li>
</ul>
</li>
<li><p>我们还需要了解系统是如何搜索到一个类的</p>
<ul>
<li>CLASSPATH：指定类的搜索路径，要是用已经编写好的类时没需要通过这个路径找到它们</li>
<li>CLASSPATH下包含JDK安装目录下的lib子目录中的 <code>dt.jar</code> 以及 tools.jar 以及 当前目录</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>JVM &amp; JDK &amp; JRE之间的关系</p>
<ul>
<li>JVM：Java虚拟机，Java程序在JVM上运行</li>
<li>JRE：Java程序运行环境</li>
<li>JDK：Java开发工具包，包含JVM和JRE</li>
</ul>
</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li><p>Java程序中的注释仅出现在Java的源程序<code>.java</code>中，起到对源码说明的作用，不会出现在字节码<code>.class</code>文件中</p>
</li>
<li><p>注释类型</p>
<ol>
<li>单行注释</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//单行注释</span><br></pre></td></tr></table></figure>

<ol>
<li>多行注释</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">多行注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>javadoc注释</strong>：<code>javadoc</code>命令可以提取javadoc注释，自动生成帮助文档</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*javadoc注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="针对HelloWorld的程序解释"><a href="#针对HelloWorld的程序解释" class="headerlink" title="针对HelloWorld的程序解释"></a>针对HelloWorld的程序解释</h2><ul>
<li>一个Java源文件可以定义多个类<ul>
<li>每个<code>class</code>经过java命令的编译，都会生成对应的<code>.class</code>文件</li>
</ul>
</li>
<li>一个Java源文件可以不包含<code>public</code>类<ul>
<li>但是一个Java源文件中只能有一个<code>public</code>类，并且这个类的名称必须和源文件的名称一直</li>
</ul>
</li>
<li>每一个类（不一定是公开类）都可以编写自己的<code>main</code>方法，每一个类都可以作为程序的入口<ul>
<li>在命令窗口执行某一个类时，这个类必须有自己的<code>main</code>方法</li>
</ul>
</li>
</ul>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>标识符包括：类名、方法名、变量名、接口名、常量名</li>
<li>命名规则：只能又数字、字母（<u>包括汉字</u>）、_、$组成，不能以数字开始，严格区分大小写，关键字不能作为标识符，长度不限</li>
<li>命名规范<ol>
<li>类、接口名：首字母大写（记住HelloWorld）</li>
<li>变量名、方法名：首字母小写（记住main）</li>
<li>常量名：全部大写</li>
</ol>
</li>
</ul>
<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><ul>
<li>字面值即数据，也就是C语言中的常量值</li>
<li>包括 整型、浮点型、布尔型、字符型、字符串</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>内存中的一块空间，由 **数据类型 名称 字面值 **三部分组成</p>
</li>
<li><p>变量是内存中存储数据的最基本的单元</p>
</li>
<li><p>变量的声明和赋值可以一起完成，并且可以重复的赋值，但是只能声明一次</p>
<ul>
<li>这一点在for循环里需要注意，不能出现以下代码！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量的分类</p>
<ol>
<li><p>局部变量</p>
<p>在方法体中声明的变量叫做局部变量，局部变量在声明后必须手动的赋值进行初始化，否则不能使用！</p>
</li>
<li><p>成员变量</p>
<p>在方法体之外、类体之内声明的变量叫做成员变量，成员变量可以不用手动初始化，系统可以自动初始化</p>
</li>
</ol>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>数据类型主要用于指导JVM在运行程序时给不同的数据分配合适的内存空间</p>
</li>
<li><p>数据类型的分类</p>
<ol>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ol>
</li>
<li><p>基本数据类型</p>
<ul>
<li>四大类，八小种<ol>
<li>整型：<code>byte short int long</code></li>
<li>浮点型：<code>float double</code></li>
<li>布尔型：<code>boolean</code></li>
<li>字符型：<code>char</code></li>
</ol>
</li>
<li>需要注意的是String不属于基本数据类型，属于引用数据类型</li>
<li>基本数据类型所占的空间大小</li>
</ul>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">占用空间大小（字节）</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">1</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">-32768~32797</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Char</td>
<td align="center">2</td>
<td align="center">0~65535</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><ul>
<li><p>字符编码是人为定义的，用来实现计算机二进制和文字之间的转换</p>
</li>
<li><p>常见的ASCII码：</p>
<ol>
<li>‘a’&#x3D;97</li>
<li>‘A’&#x3D;63</li>
<li>“0”&#x3D;48</li>
</ol>
</li>
<li><p>Java使用Unicode编码（UTF-8），标识符支持中文等其他语言</p>
<ul>
<li>Unicode编码详见参考视频<sup><a href="#ref1">[1]</a></sup></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DataType.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataType</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">decimal</span> <span class="operator">=</span> ((<span class="type">int</span>)<span class="string">&#x27;中&#x27;</span>);<span class="comment">//获取中的unicode编码</span></span><br><span class="line">		System.out.println(decimal);</span><br><span class="line">		<span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> Integer.toHexString(decimal);</span><br><span class="line">		System.out.println(hex);</span><br><span class="line"></span><br><span class="line">		a = <span class="string">&#x27;\u4e2d&#x27;</span>;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果：</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7wm10wb5ij30my0940tc.jpg"></p>
</li>
<li><p>转义字符 \ </p>
<ul>
<li>转义字符可以将后面紧接着的字符 从 <u>普通含义</u> 转换成 特殊转义字符 或者 将 <u>特殊转义字符</u> 转换成 <u>普通字符</u></li>
<li>例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出转义字符</span></span><br><span class="line">System.out.println(<span class="string">&quot;\\&quot;</span>);<span class="comment">//将 特殊的转义字符 变成 普通的 \</span></span><br><span class="line"><span class="comment">//输出单引号</span></span><br><span class="line">System.out.println(<span class="string">&quot;\&#x27;&quot;</span>);<span class="comment">//将 特殊的&#x27; 变成 普通的 &#x27;</span></span><br><span class="line"><span class="comment">//输出制表符</span></span><br><span class="line">System.out.println(<span class="string">&quot;\t&quot;</span>);<span class="comment">//将 普通的t 变成 特殊的制表符</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><ul>
<li>Java语言中的<u>默认整型</u>是<code>int</code>型，如果需要使用long，需要在字面值后添加L或者l，一般添加大写L以免混淆</li>
<li>整型字面值三种表达方式：十进制（默认），八进制（字面值以0开始），十六进制（字面值以0x开始）</li>
</ul>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><ol>
<li><p>小容量向大容量转换</p>
<ul>
<li><p>小容量可以自动转换为大容量，称为自动类型转换机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="comment">//编译通过，123是系统默认的整型，即int，系统自动将小容量的int转换为大容量的long</span></span><br><span class="line"><span class="type">long</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2147483648</span>;</span><br><span class="line"><span class="comment">//编译报错，2147483648是系统默认的int型，但2147483648超过了int的范围</span></span><br><span class="line"><span class="comment">//将2147483648整型按照long进行处理，末尾加L</span></span><br><span class="line"><span class="type">long</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">2147483648L</span>;</span><br><span class="line"><span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>大容量向小容量转换</p>
<ul>
<li><p>大容量需要通过强制类型转换才能变成小容量</p>
</li>
<li><p>强制类型转换虽然可以通过编译，但是在运行时也有可能损失精度</p>
</li>
<li><p>强制类型转换的原理：将前面多余的位数忽略，取后面几位</p>
</li>
<li><p><u>例外</u></p>
<ul>
<li><code>byte short char</code> 类型在取值范围内时可以不需要强制类型转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//虽然10是默认的int型，但是10没有超过byte的取值范围，不需要强制类型转换</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><ul>
<li><p><code>float</code> 单精度，四个字节；<code>double</code> 双精度，八个字节</p>
</li>
<li><p>所有的浮点型字面值默认被当作<code>double</code>来处理，如果需要使用<code>float</code> 需要在字面值后面添加f&#x2F;F</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.1</span>;</span><br><span class="line"><span class="comment">//编译报错，大精度转换为小精度需要强制类型转换</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>关于布尔类型只需要注意的是，Java中的布尔类型不能用0或者1来表示</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>运算符中需要细节较多的只有逻辑运算符 以及 位运算符，有关于算术运算符以及关系运算符就不再赘述了，位运算符会在算法部分详细展开</p>
<p>逻辑运算符中需要格外关注的是 <strong>短路现象</strong></p>
<ul>
<li>逻辑运算运算符要求左右两边算子都是布尔类型，并且最后运算结果也是布尔类型</li>
<li>短路现象：因为某个事件的发生导致程序运行步骤改变<ul>
<li>普通与&amp;：将运算符两边的算子都运算，两边都为真，结果才为真</li>
<li>短路与&amp;&amp;：一旦左边的算子为假，则忽视右边的算子，直接输出结果</li>
<li>短路或|| 和 普通或｜同理</li>
</ul>
</li>
<li>短路现象使运算更高效，但如果两边的算子都不得不计算时就无法使用短路现象了</li>
</ul>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符包括：基本赋值运算符，以及 扩展赋值运算符</p>
<p>这里着重讨论扩展赋值运算符，包括：+&#x3D; -&#x3D; &#x2F;&#x3D; %&#x3D;</p>
<p>–&gt;可以这样理解+&#x3D;：先做加法运算，再做赋值运算</p>
<p>需要注意的是：拓展赋值运算符并不会修改运算结果的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">a = a + <span class="number">1</span>;<span class="comment">//编译报错，在做加法运算时需要强制类型转换</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">b += <span class="number">1</span>;<span class="comment">//编译通过，相当于 b = (byte)(b + 1);</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串连接运算符"><a href="#字符串连接运算符" class="headerlink" title="字符串连接运算符"></a>字符串连接运算符</h4><ul>
<li>“+”运算符有两个作用：<ol>
<li>进行加法运算</li>
<li>字符串连接</li>
</ol>
</li>
<li>当 + 运算符两边的<u>都是</u>数字的话，进行加法运算，否则进行字符串连接</li>
<li>进行字符串连接后运算的结果还是字符串类型</li>
<li>一个表达式中出现多个+时，运算的优先级相同，按照从左到右的顺序依次运算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 + 2 + 3 --&gt; 6</span><br><span class="line">1 + 2 + &quot;3&quot; --&gt; 33</span><br><span class="line">1 + (2 + &quot;3&quot;) --&gt; 123</span><br></pre></td></tr></table></figure>

<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>控制语句都是一些十分基础的语法，但是为了实现一些功能，这其中还涉及了一些相关的其他语法，这里单独列举出来</p>
<h4 id="接收用户键盘的输入"><a href="#接收用户键盘的输入" class="headerlink" title="接收用户键盘的输入"></a>接收用户键盘的输入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.Scanner scanner ;= <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">uerInput</span> <span class="operator">=</span> scanner.next();<span class="comment">//接收用户字符串的输入</span></span><br><span class="line"><span class="type">int</span> <span class="variable">uerInput</span> <span class="operator">=</span> scanner.nextInt();<span class="comment">//接收用户整型的输入</span></span><br><span class="line"><span class="type">double</span> <span class="variable">uerInput</span> <span class="operator">=</span> scanner.nextDouble();<span class="comment">//接收用户浮点型的输入</span></span><br></pre></td></tr></table></figure>

<h4 id="判断两字符串是否相等"><a href="#判断两字符串是否相等" class="headerlink" title="判断两字符串是否相等"></a>判断两字符串是否相等</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a;</span><br><span class="line"><span class="type">boolean</span> a.equals(String b);<span class="comment">//当两字符串相等时返回true，否则返回false</span></span><br><span class="line">a == b;<span class="comment">//判断的是两个字符串的地址是否相同</span></span><br></pre></td></tr></table></figure>

<h4 id="Switch中的case穿透现象"><a href="#Switch中的case穿透现象" class="headerlink" title="Switch中的case穿透现象"></a>Switch中的case穿透现象</h4><ul>
<li><code>Switch</code>以及<code>case</code>后可以接<code>int String</code>类型，当接受byte short char类型时系统可以将它们直接自动转换成上述两类型</li>
<li><code>Siwtch</code>的<code>case</code>穿透现象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			java语句<span class="number">1</span>;</span><br><span class="line">			<span class="comment">//break;----&gt;case穿透现象:无论2是否匹配，直接执行Java语句2</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			java语句<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//------&gt;因为有break，所以只会执行Java语句2</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//case的合并</span></span><br><span class="line">			java语句<span class="number">3</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h4 id="控制循环语句"><a href="#控制循环语句" class="headerlink" title="控制循环语句"></a>控制循环语句</h4><ol>
<li><p><code>break</code>语句</p>
<ul>
<li><code>break</code>表示中断</li>
<li><code>break</code>可用在循环语句以及<code>switch</code>语句中</li>
<li>默认情况下<code>break</code>终止的是距离它最近的循环</li>
<li>当然<code>break</code>也可以中断指定的循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：break + 循环名字（需要前给每个循环取名字）0</span></span><br><span class="line">for1:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>: i++)&#123;</span><br><span class="line">  for2:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; k ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">5</span>)</span><br><span class="line">      <span class="keyword">break</span> for1;<span class="comment">//中断for1的循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>continue</code>语句</p>
<ul>
<li>continue表示继续，即忽略本轮循环中剩余的语句，直接进入下一轮循环</li>
</ul>
</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法的作用"><a href="#方法的作用" class="headerlink" title="方法的作用"></a>方法的作用</h3><p>提高代码的复用性，使得代码可以重复利用</p>
<h3 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h3><p>方法是一段代码片段，这个代码片段可以完成某个特定的功能，并且可以被重复调用(invoke)</p>
<h3 id="方法的语法结构"><a href="#方法的语法结构" class="headerlink" title="方法的语法结构"></a>方法的语法结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 返回值类型 方法名 (形式参数列表)&#123;</span><br><span class="line">	方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修饰符列表：<code>public static</code><ul>
<li>这部分是可选项，不是必须的</li>
</ul>
</li>
<li>返回值类型<ul>
<li>这里着重强调返回值为<code>void</code>的类型<ul>
<li>当方法结束后不返回任何数据时，返回值为void</li>
<li>返回值为<code>void</code>的方法中也可以编写 <code>return;</code> ，代表该方法执行结束(类似<code>break</code>的作用)</li>
</ul>
</li>
<li><code>return</code>语句<ul>
<li>只要带有<code>return</code>关键字的语句被执行，则<code>return</code>语句所在的方法执行结束</li>
<li>在同一个作用域中，<code>return</code>语句下面不能编写任何代码，因为这些代码永远不会被执行</li>
</ul>
</li>
<li>在调用一个有返回值的方法时，我们可以选择接受这个值也可以选择不接受</li>
</ul>
</li>
<li>方法名<ul>
<li>按照规范，方法名的首字母需要小写(参见<code>main</code>方法)，且需要遵循驼峰命名原则</li>
</ul>
</li>
<li>形参列表<ul>
<li>形参数量可以有多个，也可以没有，多个形参之间由逗号隔开</li>
</ul>
</li>
</ul>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>方法如果只被定义而不调用的话，方法是不会被执行的</p>
<p>调用时的语法规则（修饰符列表中包含<code>static</code>关键字时）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类名.方法名.(实参列表)；</span><br></pre></td></tr></table></figure>

<p>在同一个类中类名可以省略不写，即类名省略时默认在同一个类中寻找方法</p>
<h3 id="方法执行过程中的内存分配"><a href="#方法执行过程中的内存分配" class="headerlink" title="方法执行过程中的内存分配"></a><u>方法执行过程中的内存分配</u></h3><p>方法如果只是定义而不调用的话，系统是不会为其分配其运行所需要的空间</p>
<p>JVM内存划分主要包含三大块内容</p>
<ol>
<li>方法区内存<ul>
<li>方法代码片段属于字节码文件的一部分，字节码文件在类加载时将整个代码片段放到方法区内存当中</li>
<li>在JVM的三块内存区中，方法区内存是最先有数据的</li>
<li>代码片段虽然只有一份，但是可以被重复调用，每次调用都需要为其在栈内存分配新的、独立的内存空间</li>
</ul>
</li>
<li>栈内存<ul>
<li>每次调用方法时，在栈内存中为其分配运行所需要的空间<ul>
<li>这个栈空间中主要包含了这个方法内的局部变量等信息</li>
</ul>
</li>
<li>方法执行结束后，该方法所占用的空间全部释放</li>
<li>从一个方法的栈内存向另一个方法的栈内存通过形参列表传递值，传递的是数据的值而不是内存地址</li>
</ul>
</li>
<li>堆内存<ul>
<li>等待学习…</li>
</ul>
</li>
</ol>
<h3 id="方法的重载Overload"><a href="#方法的重载Overload" class="headerlink" title="方法的重载Overload"></a>方法的重载Overload</h3><ul>
<li>作用：使功能近似的方法使用起来像一个方法一样，便于变成</li>
<li>使用条件：<ol>
<li>在同一个类中</li>
<li>方法名相同</li>
<li>形参列表不同（包括数量不同、类型不同、顺序不同）</li>
</ol>
</li>
<li>方法重载与<u>方法名</u>和参数列表有关，与<u>修饰列表</u>和<u>返回值</u>无关</li>
</ul>
<p>Reference <a name="ref1"><font color="black">[1]https://share.api.weibo.cn/share/346380011,4823082769059607.html?weibo_id&#x3D;4823082769059607</font></a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java - 2nd Week - Summary</title>
    <url>/2022/11/17/Java/Java%20-%202nd%20Week%20-%20Summary/</url>
    <content><![CDATA[<h1 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h1><p align="right">11.06-11.17</p>

<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这周所学习的内容主要是Java中面向对象的相关内容。虽然在前三年学习了很多相关的课程，自认为对面向对象的思想已经有些理解了，但如今再次回顾起来才发现自己有很多相关知识都已经忘记了，这周的学习相比于上周更加有难度。</p>
<h2 id="面向对象的编程"><a href="#面向对象的编程" class="headerlink" title="面向对象的编程"></a>面向对象的编程</h2><p>###面向过程和面向对象的区别</p>
<ol>
<li>面向过程<ul>
<li>面向过程强调的是整个流程中的前后因果关系，没有独立体的概念</li>
<li>一个步骤和一个步骤之间因为前后的因果关系组合成一个模块，一个模块和一个模块之间因为因果关系构成一个系统…</li>
<li>当其中一个因果关系破裂，整个系统都会受到影响</li>
<li><u>优点</u>：当业务逻辑简单时，可以达到快速开发的效果，前期投入成本低</li>
<li><u>缺点</u>：难以解决较为复杂的业务；高耦合，扩展性弱</li>
</ul>
</li>
<li>面向对象<ul>
<li>将现实世界分割成不同的单元，每个单元都是一个独立的对象，在一个 确定的环境下，将各个单元协作起来，就可以构成一个系统</li>
<li>面向对象强调的是对象，将所需要的独立体以及它们的功能进行组合，即可完成整个流程</li>
<li><u>优点</u>：低耦合，扩展性强，可以实现更加复杂的业务</li>
<li><u>缺点</u>：前期投入成本高</li>
</ul>
</li>
</ol>
<h3 id="面向对象开发的三个步骤"><a href="#面向对象开发的三个步骤" class="headerlink" title="面向对象开发的三个步骤"></a>面向对象开发的三个步骤</h3><ol>
<li>面向对象的分析：Objected-Oriented Analysis</li>
<li>面向对象的设计：OOD</li>
<li>面向对象的编程：OOP</li>
</ol>
<h2 id="面向对象的三大特征：封装-继承-多态"><a href="#面向对象的三大特征：封装-继承-多态" class="headerlink" title="面向对象的三大特征：封装 继承 多态"></a>面向对象的三大特征：封装 继承 多态</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><ul>
<li>对象：对客观事物的抽象</li>
<li>类：对对象的抽象，代表了一类具有共同特征的事物</li>
<li>类通过<u><strong>实例化</strong></u>创建对象，因此对象又被称作实例</li>
<li>对象通过<u>抽象</u>的到类</li>
</ul>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul>
<li><p>类是对对象的抽象，而对象主要有两类信息</p>
<ol>
<li>状态信息：类的属性</li>
<li>动作信息：类的方法</li>
</ol>
</li>
<li><p>语法结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] class 类名&#123;</span><br><span class="line">	属性<span class="number">1</span>；</span><br><span class="line">	...</span><br><span class="line">	方法<span class="number">1</span>；</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Java中数据类型分为基本数据类型和引用数据类型，而所有的<code>class</code>都是引用数据类型</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>用来描述对象的状态信息</li>
<li>属性一般都是各类数据，通常采用变量的方式来定义</li>
<li>属性变量是成员变量，可以在未初始化的情况下直接使用</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>用来描述对象的动作信息，或者功能</li>
</ul>
</li>
</ul>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul>
<li><p>对象的创建</p>
<ul>
<li>语法结构：<code>new 类名()</code></li>
<li>new运算符的作用是创建对象，在堆内存中开辟空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Student</code> 是数据类型，代表<code>stu</code>这个引用是学生类</li>
<li><code>stu</code> 是引用存放于栈内存中，存储的数据指向堆内存中<code>Student</code>对象的内存地址</li>
<li><code>new Student()</code> 是调用 <code>Student()</code>构造函数创建一个学生类的对象</li>
</ul>
</li>
<li><p>对象和引用</p>
<ol>
<li>对象：通过构造函数<code>/new</code>运算符在堆内存中开辟的内存空间称为对象</li>
<li>引用：<ul>
<li><strong>引用</strong>也是一种变量，但存储的是另一个对象的<u>内存地址</u></li>
<li>Java中没有指针的概念，只能通过引用的方式去访问堆内存</li>
<li>当一个对象没有引用指向它时，它将会被自动回收</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="基本数据类型-和-引用数据类型的区别"><a href="#基本数据类型-和-引用数据类型的区别" class="headerlink" title="基本数据类型 和 引用数据类型的区别"></a><strong>基本数据类型</strong> 和 <strong>引用数据类型</strong>的区别</h5><ol>
<li>存储的数据不同<ul>
<li>基本数据类型的数据保存数据本身</li>
<li>引用数据类型的数据保存<strong>引用值</strong>，引用值指向内存空间的一块地址，而非该内存空间上的数据本身</li>
</ul>
</li>
<li>初始化过程不同<ul>
<li>基本数据类型在声明时系统就会为其分配内存空间</li>
<li>引用数据类型在声明时只是给变量分配了引用空间，而没有分配数据空间，并不会在堆内存中就开辟相关的空间</li>
</ul>
</li>
<li>数据传递方式不同<ul>
<li>基本数据类型是<strong>值传递</strong><ul>
<li>方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一份拷贝，在方法中对这个拷贝的形参做修改，不改变实参的值</li>
</ul>
</li>
<li>引用数据类型是<strong>引用传递</strong><ul>
<li>方法调用时，实参的引用被传递给方法中相应的形参，在方法执行过程中，形参和实参指向同一块内存地址，方法执行后再访问该内存地址，会发现实参被改变了</li>
</ul>
</li>
<li><strong><u>参数传递的本质</u></strong><ul>
<li>方法调用涉及参数传递时，Java只遵循的其实只有一种机制：<strong>将变量中存储的“值”传递过去</strong>，只不过这个值有的时候时字面值，有的是内存地址</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="实例变量-和-静态变量"><a href="#实例变量-和-静态变量" class="headerlink" title="实例变量 和 静态变量"></a>实例变量 和 静态变量</h5><p>二者都属于<u>成员变量</u>，定义在方法体之外，类体之中</p>
<ol>
<li>实例变量<ul>
<li>一个类中，每个对象都具有同一种属性，但是属性的值会随着对象的不同而不同，例如用户类中的“账号”，这种属性称为实例变量。<u>只能通过对象去访问这种属性</u></li>
<li>只有创建了对象，才会为实例变量开辟内存空间</li>
<li>实例变量的访问：<code>引用.变量名</code></li>
</ul>
</li>
<li>静态变量<ul>
<li>在类体中，用<code>static</code>关键字修饰的变量称为静态变量</li>
<li>一个类中，所有的对象都具有同一种属性，并且所有对象的这种属性的值都相同，这种属性称为静态变量</li>
<li>在初始化类时，就会为静态变量开辟内存空间</li>
<li>静态变量的访问：<code>类.变量名</code></li>
</ul>
</li>
</ol>
<h4 id="JVM内存空间"><a href="#JVM内存空间" class="headerlink" title="JVM内存空间"></a>JVM内存空间</h4><p>JVM内存一共被划分为三类，分别为：栈内存、方法区内存，以及堆内存</p>
<ol>
<li><strong>栈内存</strong>：一个线程拥有一个栈内存。栈内存中主要存储的是方法体中的局部变量。调用方法时，在栈内存中为其分配空间，称为压栈；方法调用结束时，释放栈内存中的空间，称为出栈</li>
<li><strong>方法区内存</strong>：一个JVM虚拟机只有一个方法区内存。方法的代码片段以及整个类的代码片段都存储于方法区内存中，成员变量中的静态变量也存储于方法区中</li>
<li><strong>堆内存</strong>：通过<code>new</code>运算符创建的对象存储于堆内存中，对象中的实例变量也存储于堆内存中</li>
</ol>
<h4 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a><code>NullPointerException</code></h4><ul>
<li>空指针异常：<code>java.lang.NullPointerException</code></li>
<li>当空引用访问<u>实例相关</u>的数据时一定会发生空指针异常</li>
<li>实例相关的数据指的是这个数据的访问必须有对象的参与</li>
<li>空指针异常可以通过编译，但是在运行期间会报错！</li>
</ul>
<h3 id="封装-1"><a href="#封装-1" class="headerlink" title="封装"></a>封装</h3><h4 id="封装的作用"><a href="#封装的作用" class="headerlink" title="封装的作用"></a>封装的作用</h4><ol>
<li>安全性：控制外部的访问</li>
<li>有效性：复杂性封装，对外提供简单的操作入口</li>
<li>复用性：使得对象可以被反复使用</li>
</ol>
<h4 id="访问控制权限"><a href="#访问控制权限" class="headerlink" title="访问控制权限"></a>访问控制权限</h4><ul>
<li>访问控制权限修饰符用来控制元素的访问范围</li>
<li>访问控制权限修饰符可以用来修饰类、变量以及方法<ul>
<li>类只能用<code>public</code>和<code>缺省</code>修饰【内部类除外】</li>
</ul>
</li>
<li>修饰符包括：<code>public</code>, <code>protected</code>, <code>缺省</code> 以及 <code>private</code><ul>
<li><code>public</code>：公开的，在任何位置都可以访问</li>
<li><code>protected</code>：表示受保护的，在同一个包，以及子类中可以访问<ul>
<li>当某个数据只希望子类使用时，采用<code>protected</code>修饰</li>
</ul>
</li>
<li>缺省：仅仅是同一个包的类下可以访问</li>
<li><code>private</code>：私有的，只能在本类中访问</li>
</ul>
</li>
<li>修饰的范围：<code>private &lt; 缺省 &lt; protected &lt; public</code></li>
</ul>
<h4 id="封装的步骤"><a href="#封装的步骤" class="headerlink" title="封装的步骤"></a>封装的步骤</h4><ol>
<li><p>属性&#x2F;方法用访问修饰符进行修饰</p>
</li>
<li><p>对外提供简单的操作入口，通过这些简单的操作来修改&#x2F;访问被封装的内容</p>
<ul>
<li>如果不提供操作入口，那么被封装的属性将永远不会被访问</li>
</ul>
</li>
<li><p><strong><code>set</code>和<code>get</code>方法</strong></p>
<ul>
<li><p>提供对私有属性的读写操作入口</p>
</li>
<li><p>语法格式</p>
<ul>
<li>&#96;&#96;&#96;java<br>public void setValue(形参列表){<br>  this.value &#x3D; value;<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public 返回值类型 getValue()&#123;</span><br><span class="line">    return this.value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>set</code>和<code>get</code>函数的修饰符列表中不包含<code>static</code>，并且命名规范要遵循驼峰命名规则</p>
</li>
<li><p><code>set</code>和<code>get</code>函数可以在IntelliJ中自动生成：选中所需要生成<code>set</code>和<code>get</code>方法的实例变量，<code>command + N</code>选择<code>Getter and Setter</code>即可</p>
</li>
</ul>
</li>
</ol>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li>构造方法又称为构造器&#x2F;Constructor</li>
<li>语法结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 构造方法名(形参列表)&#123;</span><br><span class="line">	构造方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>与不同的方法相比较<ol>
<li>构造方法不需要指定返回值类型<ul>
<li>构造方法调用结束会返回堆地址中创建对象的<strong>引用</strong></li>
<li>构造方法的返回值类型唯一且固定，所以可以省略</li>
</ul>
</li>
<li>构造方法名和类名必须保持一致</li>
</ol>
</li>
<li><strong>构造方法的作用</strong><ul>
<li>通过调用构造方法在堆内存中创建对象，同时初始化实例变量</li>
</ul>
</li>
<li>构造方法的调用<ul>
<li><code>new 构造方法(实参列表)</code></li>
</ul>
</li>
<li>实例变量的初始化<ul>
<li>在类加载时，系统并不会初始化实例变量</li>
<li>通过构造函数来初始化实例变量</li>
</ul>
</li>
</ul>
<h5 id="缺省构造器"><a href="#缺省构造器" class="headerlink" title="缺省构造器"></a>缺省构造器</h5><ul>
<li>当一个类中没有定义任何构造方法时，系统默认为该类提供一个无参的构造方法，该方法称为缺省构造器</li>
<li>当类中显示的定义了其他构造方法时，系统就不会为器提供缺省构造器</li>
</ul>
<h5 id="构造方法的重载"><a href="#构造方法的重载" class="headerlink" title="构造方法的重载"></a>构造方法的重载</h5><ul>
<li>在一个类中可以定义多个构造方法，通过不同的形参列表重载构造方法</li>
<li>由于无参构造方法经常被使用，所以我们当我们编写了带参数的构造方法后，需要手动的为当前类提供一个无参构造方法</li>
<li><strong>每调用一次构造方法，就会在堆内存中创建不同的对象</strong>，即使调用相同的构造方法</li>
</ul>
<h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><h5 id="this关键字的作用"><a href="#this关键字的作用" class="headerlink" title="this关键字的作用"></a>this关键字的作用</h5><ul>
<li><code>this</code>关键字用于引用 方法或构造函数中的 当前对象</li>
<li><code>this</code>是一个<strong>引用变量</strong>，保存的是指向当前对象自身的地址</li>
<li><code>this</code>存储于堆内存中</li>
<li>初始化对象的过程中，都会初始化该对象的<code>this</code>关键字</li>
</ul>
<h5 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h5><ol>
<li>出现在实例方法中，用于指向当前正在执行这个动作的对象<ul>
<li>一般通过<code>this</code>访问的都是实例变量&#x2F;方法，而在访问这个实例变量&#x2F;方法的大多都是该对象本身，所以<code>this.</code>可以省略</li>
<li><code>this</code>不能出现在带有<code>static</code>的方法中，不过静态的方法也不是实例方法</li>
</ul>
</li>
<li>用来区分局部变量和实例变量<ul>
<li>常用于构造方法中，用于区分时，不能省略<code>this.</code></li>
</ul>
</li>
<li>用来调用其他构造方法<ul>
<li>通过当前构造方法调用其他构造方法</li>
<li>语法结构<code>this(实参列表)；</code></li>
<li>用这种方法调用构造方法时，这条语句必须出现在构造方法的<strong>第一行</strong></li>
</ul>
</li>
</ol>
<h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><ul>
<li>静态的</li>
<li><code>static</code>可以用来修饰变量和方法，所修饰的变量称为静态变量，所修饰的方法称为静态方法</li>
<li><code>static</code>所修饰的元素都是类级别的特征，与具体的对象无关</li>
<li>也因此，静态变量和静态方法在类加载时就初始化了，内存在方法区中开辟，不需要通过对象来初始化</li>
<li>直接通过<code>类名.</code>访问<code>static</code>所修饰内容</li>
</ul>
<h5 id="实例方法-和-静态方法"><a href="#实例方法-和-静态方法" class="headerlink" title="实例方法 和 静态方法"></a>实例方法 和 静态方法</h5><p>与实例变量与静态变量的关系相似</p>
<ol>
<li>实例方法<ul>
<li>每个对象都有具有这种行为，但是每个对象执行这个方法后所产生的结果<u>不同</u>，这样的方法称为实例方法</li>
<li>绝大部分的动作都被定义为实例方法，因为动作都需要具体的对象参与</li>
</ul>
</li>
<li>静态方法<ul>
<li>每个对象都具有这种行为，并且每个对象执行这个方法后所产生的结果<u>相同</u>，这样的方法称为静态方法</li>
<li>静态方法的动作行为不属于某一个对象，而是可以提升至整个类级别</li>
<li>在静态方法中无法直接访问实例变量或者实例方法<ul>
<li>调用静态方法时没有对象的参与，而实例变量和实例方法需要对象才能访问</li>
<li>可以在静态方法中创建一个对象，再去访问实例变量和实例方法</li>
<li>绝大部分的方法类工具都被定义为静态方法，可以在不创建对象的情况下调用，便于使用</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="静态变量和方法的访问"><a href="#静态变量和方法的访问" class="headerlink" title="静态变量和方法的访问"></a>静态变量和方法的访问</h5><ul>
<li>静态变量&#x2F;方法可以通过<code>类名.静态变量名</code>来直接访问</li>
<li>所有的静态数据既可以通过类名的方式访问，也可以通过对象的方式访问<ul>
<li>当通过引用（对象）来访问时，即使这个引用指向null，也不会出现空指针异常的情况</li>
<li>因为本质上是通过这个引用所在的类来访问静态的数据，不需要引用的存在！</li>
</ul>
</li>
</ul>
<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><ul>
<li><p>语法格式</p>
<ul>
<li>&#96;&#96;&#96;java<br>static{<br>Java语句;<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 静态代码块在类加载时执行，并且只执行一次</span><br><span class="line"></span><br><span class="line">- 静态代码块在类中可以编写多个，遵循自上而下依次执行</span><br><span class="line"></span><br><span class="line">- 静态代码块在加载类时就执行了，比主函数执行的还要提前</span><br><span class="line"></span><br><span class="line">- 作用</span><br><span class="line"></span><br><span class="line">  - 静态代码块可以用来&lt;u&gt;记录类加载时刻&lt;/u&gt;，可以在类加载时刻执行一些特定的动作</span><br><span class="line">  - 可以在静态代码块中记录日志、完成初始化工作以及一些准备工作</span><br><span class="line"></span><br><span class="line">#### 实例代码块</span><br><span class="line"></span><br><span class="line">- 语法格式</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    &#123;</span><br><span class="line">    	Java语句；</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>实例代码块可以编写多个，遵循自上而下的顺序依次执行</p>
</li>
<li><p>实例代码块在构造函数之前执行，<u>构造函数</u>执行一次实例代码块就执行一次</p>
</li>
<li><p>作用</p>
<ul>
<li>实例代码块可以用来记录对象初始化时刻</li>
</ul>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><ul>
<li>继承的基本作用是<u>代码复用</u>，有了继承之后才有方法的<strong>覆盖和多态机制</strong></li>
<li>继承允许创建分等级层次的类</li>
<li><strong>继承的数据类型</strong><ol>
<li>私有的、缺省的不支持继承</li>
<li>父类的构造函数不支持继承</li>
<li>其余的都支持继承</li>
</ol>
</li>
<li>Java语言中只支持单继承，一个类不能同时继承很多个类（C++中支持多继承）</li>
<li>Java中的间接继承<ul>
<li>D extends C, C extends B, B extends A，则D直接继承C，间接继承B和A</li>
</ul>
</li>
<li>当Java中一个类没有显示的继承任何类时，该类<strong>默认继承</strong>JavaSE中的<code>java.lang.Object</code>类</li>
</ul>
<h4 id="继承的语法结构"><a href="#继承的语法结构" class="headerlink" title="继承的语法结构"></a>继承的语法结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表]class 父类&#123;</span><br><span class="line">	类体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[修饰符列表] class 子类名 extends 父类&#123;</span><br><span class="line">	类体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>父类又称为基类，超类(Superclass)</li>
<li>子类又称为派生类(Subclass)</li>
</ul>
<h4 id="方法的覆盖"><a href="#方法的覆盖" class="headerlink" title="方法的覆盖"></a>方法的覆盖</h4><h5 id="方法的覆盖Override"><a href="#方法的覆盖Override" class="headerlink" title="方法的覆盖Override"></a>方法的覆盖Override</h5><ul>
<li>又称为方法的重写Overwrite</li>
<li>当父类中的方法无法满足当前子类的要求时，子类有必要将父类继承过来的方法进行重写</li>
<li>方法重写发生在具有<strong>继承关系的父子类之间</strong></li>
<li>重写的方法必须和父类的方法的<u>返回值类型</u>、<u>方法名</u>、<u>形参列表</u>相同<ul>
<li>直接复制粘贴父类的方法，然后修改<u>方法体</u>中内容即可</li>
</ul>
</li>
<li>子类重写的方法访问权限可以更低，但不能更高</li>
<li>抛出的异常可以更少，但不能更多</li>
</ul>
<h5 id="方法的重载Overload"><a href="#方法的重载Overload" class="headerlink" title="方法的重载Overload"></a>方法的重载Overload</h5><ul>
<li>在同一个类中，方法完成的功能相似时，建议方法名相同，这样方便编程</li>
<li>重载的方法必须<ol>
<li>在同一个类中</li>
<li>方法名相同</li>
<li>参数列表不同</li>
</ol>
</li>
<li>方法重载与一下因素无关<ol>
<li>返回值</li>
<li>修饰符列表</li>
</ol>
</li>
</ul>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><ul>
<li>表示最终的、不可变的</li>
<li><code>final</code>修饰的类是无法被继承的</li>
<li><code>final</code>修饰的方法是无法被覆盖的</li>
<li><code>final</code>修饰的变量只能被赋值一次<ul>
<li><code>final</code>修饰的实例变量只能手动赋值，如果采用系统直接初始化的话，则之后永远为0不能修改</li>
</ul>
</li>
<li><code>final</code>修饰的引用确定好对象后无法再被修改<ul>
<li>即这个引用指向的地址是不能修改的</li>
<li>被<code>final</code>修饰的引用所指向的对象无法被垃圾回收器回收</li>
<li>但是被<code>final</code>修饰的引用所指向的对象，它内存中存储的数据可以修改</li>
</ul>
</li>
</ul>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ul>
<li><p><code>final</code>修饰的实例变量都是不可变的，这种变量一般都和<code>static</code>联合使用，被称为常量</p>
<ul>
<li>不可变的实例变量如果在每个对象中都保存一份的话会造成空间浪费</li>
</ul>
</li>
<li><p>语法格式</p>
<p><code>public static final 数据类型 常量名 = 值;</code></p>
</li>
<li><p>常量名的命名规范：所有字母大写，每个单词之间通过下划线来连接</p>
</li>
<li><p>由于常量在声明后无法被修改，所以被<code>public</code>修饰也是十分安全的</p>
</li>
</ul>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><ul>
<li><p>Java中引入包机制主要是为了方便程序管理。不同功能的类被分别放到不同的包当中，便于查找、管理和维护</p>
</li>
<li><p><code>package</code>的定义</p>
<ul>
<li>在Java源程序的第一行上编写<code>package</code>语句</li>
<li><code>package</code>只能编写一个语句</li>
<li>语法结构：<code>package 包名;</code></li>
</ul>
</li>
<li><p>包的命名规范：</p>
<ul>
<li>前缀 + 发起者名 + 项目名 + 模块名</li>
<li>包名要求<strong>全部小写</strong>，包名也是标识符，必须遵循标识符的命名规范</li>
</ul>
</li>
<li><p>一个包对应一个目录，目录之间用<code>.</code>分隔开</p>
<ul>
<li>例如：<code>pers.kevin.javase.day1117</code>就会生成四个目录</li>
</ul>
</li>
<li><p>一旦使用包机制后，<strong>类的名称就会改变</strong></p>
<ul>
<li>我们编写一个Test类，当使用如上的包后，Test类的名称就会变成<code>pers.kevin.javase.day1117.Test</code></li>
</ul>
</li>
<li><p>包名的省略</p>
<ul>
<li><p>当两个类在同一个包下时，可以省略包名</p>
</li>
<li><p>当两个类不在同一个包下时，一定要在类前加上完整的包名</p>
</li>
</ul>
</li>
</ul>
<h4 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a><code>import</code>关键字</h4><ul>
<li><code>import</code>语句用来完成导入其他类，同一个包下的类不需要导入，不在同一个包下的类需要手动导入</li>
<li>语法格式：<ul>
<li><code>import 类名;</code></li>
<li><code>import 包名.*;</code>代表引入这个包下的所有类</li>
</ul>
</li>
<li><code>import</code>语句需要编写到<code>package</code>语句之下，<code>class</code>语句之上</li>
<li><code>java.lang.*</code>不需要手动引入</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象、类与对象、空指针异常</title>
    <url>/2022/11/09/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11/</url>
    <content><![CDATA[<h1 id="Java面向对象1"><a href="#Java面向对象1" class="headerlink" title="Java面向对象1"></a>Java面向对象1</h1><h3 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h3><ul>
<li>面向过程强调整个流程中的前后因果关系，没有独立体的概念<ul>
<li>一个步骤和一个步骤之间因为<strong>前后因果关系</strong>组合成一个模块，一个模块和一个模块之间因为因果关系构成一个系统，但是当因果关系破裂时，整个流程都会受到影响</li>
<li>优点：<ol>
<li>业务逻辑简单时，可以达到快速开发的效果</li>
<li>前期投入较低</li>
</ol>
</li>
<li>缺点：<ol>
<li>难以解决非常复杂的业务；</li>
<li>高耦合，当一个步骤出现问题时，整个系统都会收到影响；</li>
<li>缺少复用性的功能</li>
</ol>
</li>
</ul>
</li>
<li>面向对象强调的是对象，关心每个独立体所能带来的功能，忽略对象内功能的具体实现<ul>
<li>将现实世界分割成不同的单元，每个单元都是一个独立的对象，在一个确定的环境下，将各个单元协作起来，就可以构成一个系统</li>
<li>将所需要的独立体以及它们的功能进行组合即可完成整个流程</li>
<li>优点：<ol>
<li>低耦合</li>
<li>扩展性强</li>
<li>可以实现更加复杂的业务</li>
</ol>
</li>
<li>缺点：<ol>
<li>前期投入成本高，需要进行大量的系统分析与设计</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h5 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h5><p><strong><u>封装、继承、多态</u></strong></p>
<h5 id="基于面向对象开发设计三步骤"><a href="#基于面向对象开发设计三步骤" class="headerlink" title="基于面向对象开发设计三步骤"></a>基于面向对象开发设计三步骤</h5><ol>
<li>面向对象的分析：OOA：Object-Oriented-Analysis</li>
<li>面向对象的设计：OOD</li>
<li>面向对象的编程：OOP</li>
</ol>
<h3 id="类和对象的概念"><a href="#类和对象的概念" class="headerlink" title="类和对象的概念"></a>类和对象的概念</h3><ul>
<li>对象：对客观事物的抽象</li>
<li>类：对对象的抽象，代表了一类具有共同特征的事物</li>
<li>实例化：类通过实例化得到对象，因此对象又被称作实例</li>
<li>抽象：对对象进行抽象的到类</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h5 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] class 类名&#123;</span><br><span class="line">	属性;</span><br><span class="line">	方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类主要描述的是 <strong>状态</strong> + <strong>动作</strong> 两种信息</p>
<ul>
<li>属性：描述的是类的状态信息</li>
<li>方法：描述的是类的动作信息</li>
</ul>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li>属性通常采用变量的方法是来定义<ul>
<li>因为状态一般都是数据信息，例如身高<code>int</code>、性别char、心情<code>String</code>等，而数据需要以变量的方式存储</li>
</ul>
</li>
<li>在类体当中，方法之外定义的变量称为<strong>成员变量</strong><ul>
<li>这里再次回顾 成员变量 和 局部变量之间的区别</li>
<li>成员变量在没有赋值的情况下可以直接使用，因为系统会自动对其进行初始化为<code>void</code>，存储于内存中的堆内存区</li>
<li>局部变量（定义在方法体中的变量）在声明后必须进行手动赋值才能使用，存储于内存中的栈区</li>
</ul>
</li>
</ul>
<h5 id="基本数据类型-和-引用数据类型的区别-1"><a href="#基本数据类型-和-引用数据类型的区别-1" class="headerlink" title="基本数据类型 和 引用数据类型的区别[1]"></a><strong>基本数据类型</strong> 和 <strong>引用数据类型</strong>的区别<sup><a href="#ref1">[1]</a></sup></h5><ul>
<li>Java中所有的<code>class</code>都是<strong>引用类型</strong>，而非四大基础数据类型</li>
<li>Java中数据类型分为两大类，即四大类基本数据类型，以及引用数据类型</li>
</ul>
<ol>
<li><p>存储的数据不同</p>
<ul>
<li>基本数据类型<ul>
<li>基本类型的数据保存原始值，即它存储的值就是数据本身</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>引用数据类型的数据保存的<strong>引用值</strong>，引用值指向内存空间的地址，代表某个对象的引用，二分该对象本身</li>
</ul>
</li>
</ul>
</li>
<li><p>初始化过程不同</p>
<ul>
<li>基本数据类型<ul>
<li>基本类型在声明时系统就会为其分配内存空间</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>引用类型在声明时只给变量分配了引用空间，而没有分配数据空间</li>
</ul>
</li>
</ul>
</li>
<li><p>数据传递方式不同</p>
<ul>
<li><p>基本数据类型：<strong>值传递</strong></p>
<ul>
<li>方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一份拷贝，**后面方法中的操作都是对形参这个值的修改，不影响实际参数的值</li>
</ul>
</li>
<li><p>引用数据类型：<strong>引用传递</strong></p>
<ul>
<li>也称为传地址，方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数；在方法执行过程中，形参和实参指向同一块内存地址，**方法执行中对引用的操作将会影响到实际对象</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="对象的创建与使用"><a href="#对象的创建与使用" class="headerlink" title="对象的创建与使用"></a>对象的创建与使用</h3><ul>
<li>实例变量<ul>
<li>在成员变量中存在实例变量和静态变量两种，这里先介绍实例变量<ul>
<li>在一个类中，每个对象可能都有同一种数据。例如：在学生类中，每个学生的都有<code>int num</code>学号信息，但是每个对象的学号都不相同。因此要访问学号信息，必须先创建对象，通过对象来访问这个信息</li>
<li>如果不创建对象，则实例变量的内存空间是不存在的</li>
</ul>
</li>
<li>不能通过“类”直接访问的变量称为实例变量（或者对象变量）</li>
</ul>
</li>
<li>对象的创建<ul>
<li>语法结构<ul>
<li><code>new 类名( );</code></li>
<li><code>new</code>运算符的作用是创建<strong>对象</strong>，在JVM<u>堆内存</u>中开辟新的内存空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>	</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Student</code> 是一个引用数据类型</li>
<li><code>s</code> 是一个变量名，这个局部变量存放在栈内存中，它存储的是对象在堆内存的地址<ul>
<li>区分引用类型变量和局部类型变量二者之间的关系：</li>
<li>这两种是对数据类型的不同的分类，局部变量和成员变量是一种分类，引用类型和基本数据类型是另一种分类。</li>
</ul>
</li>
<li><code>new Student( )</code> 是一个学生类的对象，这个对象存放在堆内存中</li>
</ol>
<ul>
<li><p>对象与引用</p>
<ul>
<li><p>new运算在堆内存中开辟的内存空间称为对象</p>
</li>
<li><p>引用也是一个变量，存储的是另一个Java对象的内存地址</p>
</li>
<li><p>Java中没有指针的概念，只能通过引用的方式去访问堆内存中对象内部的实例变量。</p>
</li>
<li><p>—-&gt;进一步的，当一个对象没有引用指向它时，它就会被自动回收</p>
</li>
</ul>
</li>
<li><p>访问实例变量</p>
<ul>
<li>语法结构<ul>
<li>读取数据：<code>引用.变量名</code></li>
<li>修改数据：<code>引用.变量 = 值</code></li>
</ul>
</li>
</ul>
</li>
<li><p>编写一个例子检验成员变量初始化的值，并对其进行修改</p>
<ul>
<li>首先写一个Student学生类，在学生类中定义了不同类型的属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">boolean</span> sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>再在Test类中实例化一个Student对象，检查其初始化后各个属性的默认值是多少；然后对其进行修改</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="comment">//通过引用的方式去访问成员变量</span></span><br><span class="line">		System.out.println(stu.age);<span class="comment">//int默认值为0</span></span><br><span class="line">		System.out.println(stu.name);<span class="comment">//String默认值为null</span></span><br><span class="line">		System.out.println(stu.sex);<span class="comment">//boolean默认值为false</span></span><br><span class="line">		<span class="comment">//通过引用的方式修改实例变量</span></span><br><span class="line">		stu.age = <span class="number">20</span>;</span><br><span class="line">		System.out.println(stu.age);</span><br><span class="line">		System.out.println(stu.name);</span><br><span class="line">		System.out.println(stu.sex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在<code>javac</code>编译过程中，需要保证先进入两个<code>class</code>文件共同的目录下，否则系统会报错，提示找不到<code>Student</code>类</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7yyhst6g2j30tc0fawg4.jpg"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7yyl6yacoj30tc0fawfv.jpg"></p>
<h3 id="JVM内存区的回顾"><a href="#JVM内存区的回顾" class="headerlink" title="JVM内存区的回顾"></a>JVM内存区的回顾</h3><ul>
<li>堆内存和方法区内存各有一个，一个线程有一个栈内存</li>
<li><strong>栈内存：</strong>调用方法时，该方法所需要的内存空间在栈内存中分配，称为压栈；方法执行之后，该方法所分配到的空间释放，称为出栈。栈中主要存储的是方法体中的局部变量</li>
<li><strong>方法区内存：</strong>方法的代码片段以及<u>整个类的代码片段</u>都被存储到方法区内存中，在类加载时这些代码会载入JVM；<u>成员变量中的静态变量也存储与方法区内存中</u></li>
<li><strong>栈内存：</strong>程序执行过程中使用<code>new</code>运算符创建的对象存储在堆内存中，对象中的实例变量也存储与堆内存中</li>
</ul>
<h3 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h3><ul>
<li><p><code>java.lang.NullPointerException</code></p>
</li>
<li><p>当空引用访问<u>实例相关</u>的数据时一定会发生空指针异常！</p>
</li>
<li><p>实例相关的数据：这个数据的访问必须有对象的参与</p>
</li>
<li><p>例子：</p>
<ul>
<li>编写一个丈夫类和妻子类，他们有自己的姓名，以及对方的姓名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span>&#123;</span><br><span class="line">	String name;<span class="comment">//丈夫的姓名</span></span><br><span class="line">	Wife wife;<span class="comment">//丈夫的妻子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wife</span>&#123;</span><br><span class="line">	String name;<span class="comment">//妻子的姓名</span></span><br><span class="line">	Husband husband;<span class="comment">//妻子的丈夫</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写一个结婚类使他们结婚</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Marry</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Husband</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Husband</span>();</span><br><span class="line">		h.name = <span class="string">&quot;张三&quot;</span>;<span class="comment">//初始化一个名叫张三的丈夫</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Wife</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wife</span>();</span><br><span class="line">		w.name = <span class="string">&quot;李四&quot;</span>;<span class="comment">//初始化一个名叫李四的妻子</span></span><br><span class="line">		<span class="comment">//展示初始化之前对方的伴侣的名字</span></span><br><span class="line">		printName(h);</span><br><span class="line">		printName(w);</span><br><span class="line">    <span class="comment">//结婚</span></span><br><span class="line">		marry(h,w);</span><br><span class="line">    <span class="comment">//展示结婚后对方伴侣的名字</span></span><br><span class="line">		printName(h);</span><br><span class="line">		printName(w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//使 h 和 w 结婚</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">marry</span><span class="params">(Husband h, Wife w)</span>&#123;</span><br><span class="line">		h.wife = w;</span><br><span class="line">		w.husband = h;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//展示丈夫妻子的名字</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(Husband h)</span>&#123;</span><br><span class="line">		System.out.println(h.wife.name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//展示妻子丈夫的名字</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName</span><span class="params">(Wife w)</span>&#123;</span><br><span class="line">		System.out.println(w.husband.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h7z0hcsug4j30tc0famxw.jpg"></p>
<ul>
<li>在注释掉 展示初始化之前对方的伴侣的名字 这两行代码后，程序正常运行！</li>
<li>空指针异常可以通过编译，因为其语法没有任何问题，但是在运行期间会报错！</li>
<li>当<code>Husband h = new Husband();</code>时，会初始化一个为空的<code>Husband</code>对象，同时初始化了该<code>Husband</code>对象中wife这个引用成员变量，这个<code>wife</code>引用成员变量会被初始化为<code>null</code>。当在程序第9行时，我们用该空的引用变量去访问了<code>Wife</code>这个类中的实例变量<code>name</code>，因此程序报错！</li>
</ul>
</li>
</ul>
<p>Reference <a name="ref1"><font color="black">[1]https://zycode1561.github.io/2019/12/07/基本类型和引用类型的区别</font></a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>访问控制权限&quot;</title>
    <url>/2022/11/17/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A110/</url>
    <content><![CDATA[<h1 id="访问控制权限"><a href="#访问控制权限" class="headerlink" title="访问控制权限"></a>访问控制权限</h1><h3 id="访问控制权限修饰符"><a href="#访问控制权限修饰符" class="headerlink" title="访问控制权限修饰符"></a>访问控制权限修饰符</h3><ul>
<li>访问控制权限修饰符用来控制元素的访问范围</li>
<li>修饰符包括：<code>public</code>, <code>protected</code>, <code>缺省</code> 以及 <code>private</code></li>
<li>访问控制权限可以修饰 类 变量 方法</li>
<li>修饰的范围：<code>private &lt; 缺省 &lt; protected &lt; public</code></li>
<li>类只能用<code>public</code>和<code>缺省</code>修饰【内部类除外】</li>
</ul>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><ul>
<li>表示公开的，在任何位置都可以访问</li>
</ul>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><ul>
<li>表示受保护的，在同一个包，以及子类中可以访问</li>
<li>当某个数据只希望子类使用时，采用<code>protected</code>修饰</li>
</ul>
<h4 id="缺省"><a href="#缺省" class="headerlink" title="缺省"></a>缺省</h4><ul>
<li>仅仅是同一个包下可以访问</li>
</ul>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><ul>
<li>私有的，只能在本类中访问</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多态2</title>
    <url>/2022/11/19/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A111/</url>
    <content><![CDATA[<h1 id="多态2"><a href="#多态2" class="headerlink" title="多态2"></a>多态2</h1><h3 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h3><ol>
<li><p>私有方法无法覆盖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father&#x27;s Private Method is Exucted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        father.Print();<span class="comment">//只有在Father类中才能访问私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="comment">//继承的方法访问权限不能低于父类方法</span></span><br><span class="line">    <span class="comment">//子类可以扩展父类的功能，但不能改变父类的功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son&#x27;s Public Method is Exucted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">      	<span class="comment">//在外部类中无法访问私有方法</span></span><br><span class="line">        <span class="comment">//father.Print();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8a8za5eeoj30u80bi0tj.jpg"></p>
</li>
<li><p>方法覆盖中的返回值类型</p>
<ul>
<li>方法覆盖的条件<ol>
<li>具有继承关系的两个类</li>
<li>子类方法和父类方法具有相同的：方法名、形参列表，和相同的返回值类型</li>
</ol>
</li>
<li>当返回值类型是基本数据类型时，不允许修改</li>
<li>当返回值类型是引用数据类型时，子类可以的返回值可以变小，但不能变大<ul>
<li>父类返回一个<code>Animal</code>类时，子类可以返回<code>Animal</code>或者<code>Cat</code>类，但不能返回<code>Animal</code>的父类</li>
</ul>
</li>
</ul>
</li>
<li><p>不能被继承的方法也不能被覆盖</p>
<ul>
<li>继承：子类可以使用父类的一些成员变量和方法</li>
<li>覆盖：子类方法覆盖父类方法，要求覆盖的方法必须和父类的方法<u>方法名</u>和<u>参数</u>都相同</li>
<li>覆盖就是因为原来父类中的方法不能满足子类的要求，所以在子类中要重写父类的方法</li>
<li>如果无法继承，即子类无法使用父类的方法，那何谈重写呢，直接在子类中<u>重新定义</u>一个方法即可</li>
</ul>
</li>
<li><p>方法覆盖只针对实例方法，<strong>静态方法的覆盖没有意义</strong></p>
<ul>
<li><u>方法覆盖和多态机制联合起来使用才有意义</u><ul>
<li><code>Animal animal = new Cat()</code></li>
<li><code>animal.move()</code></li>
<li>如果没有覆盖，则<code>animal</code>这个父类引用即使指向了子类对象，它调用的<code>move()</code>方法还都是一个结果</li>
</ul>
</li>
<li>多态需要子类对象的参与，然而静态方法的执行与对象无关</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal doSome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat doSome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">//通过引用调用静态方法也可以</span></span><br><span class="line">        <span class="comment">//但本质上是通过引用所在的类调用该静态方法</span></span><br><span class="line">        animal.Print();</span><br><span class="line">        Cat.Print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8a8i56935j30ua0cqdgl.jpg"></p>
</li>
</ol>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a><code>super</code>关键字</h2><ul>
<li><p><code>this</code>关键字</p>
<ul>
<li><code>this</code>只能用于构造方法和实例方法中<ul>
<li>出现在构造方法中用于调用其他构造方法</li>
<li>出现在实例方法中用于指向调用该实例方法的对象</li>
</ul>
</li>
<li><code>this</code>不能在静态方法中使用</li>
<li>语法格式<ul>
<li><code>this.</code> 用于区分局部变量和实例变量时不能省略</li>
<li><code>this()</code> 只能出现在构造方法的第一行，用于调用本类中其他的构造函数</li>
</ul>
</li>
</ul>
</li>
<li><p><code>super</code>关键字</p>
<ul>
<li><code>super</code>只能出现在实例方法和构造方法中</li>
<li><code>super</code>不能在静态方法中使用</li>
</ul>
</li>
<li><p><code>super()</code></p>
<ul>
<li>表示通过子类的构造方法去调用父类的构造方法</li>
<li>当子类的构造方法第一个行没有显示的说明调用父类<code>super()</code>或者本类<code>this()</code> 哪种构造方法时，默认调用<code>super()</code><ul>
<li>表示通过当前子类的构造方法去调用父类无参数的构造方法</li>
<li>此时必须保证父类的无参构造方法是存在的</li>
</ul>
</li>
<li><code>super()</code>必须出现在子类构造函数的第一行<ul>
<li>这也意味着一个构造方法中只能出现一个<code>super()</code>，否则第二个就只能出现在第二行</li>
<li><code>this()</code> 和<code>super()</code>不能共存，因为它们都要求出现在构造方法的第一行</li>
</ul>
</li>
<li><strong>无论什么情况，父类的构造方法都会执行！！</strong><ul>
<li>先有父亲，才会有儿子</li>
<li>在构造任何方法时，都会第一个执行（非调用Object类的构造方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">        <span class="comment">//super();省略调用Object的构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;父类无参数构造方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//super();省略调用Father的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>);<span class="comment">//调用本类其他的构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类无参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="comment">//super();省略调用Father的构造方法</span></span><br><span class="line">      	<span class="comment">//只是省略无参的super()，如果需要调用有参数的super需要手动声明</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类有参数的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8agwv67ipj30vk0gcwfv.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="number">10</span>);</span><br><span class="line">      	<span class="comment">//因为在子类有参构造方法中采用了默认的无参数的super()，所以不会调用有参数的super(int i)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ah06h88nj30vs0feq46.jpg"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;<span class="comment">//第五个被调用</span></span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//第四个被调用</span></span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;<span class="comment">//第一个被调用</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="comment">//第二个被调用</span></span><br><span class="line">        <span class="built_in">this</span>(i,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;<span class="comment">//第三个被调用</span></span><br><span class="line">        <span class="built_in">super</span>(j);</span><br><span class="line">        System.out.println(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      	<span class="comment">//后被调用的先执行</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ahjs5w5gj30u20e23z3.jpg"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Super关键字</title>
    <url>/2022/11/21/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A112/</url>
    <content><![CDATA[<h1 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h1><h3 id="super-的原理"><a href="#super-的原理" class="headerlink" title="super()的原理"></a><code>super()</code>的原理</h3><ul>
<li>在构造方法执行过程中，调用了一连串父类的构造方法，父类的构造方法又继续向上调用它的构造方法，但实际上对象只创建了一个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="comment">//super()省略</span></span><br><span class="line">  <span class="comment">//A()&#123;&#125;</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  String b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="comment">//super()省略</span></span><br><span class="line">  <span class="comment">//B()&#123;&#125;</span></span><br><span class="line">  <span class="type">double</span> c;</span><br><span class="line">  String d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8chljmt9bj31990lzmys.jpg"></p>
<ul>
<li><code>super(实参)</code>的作用是：<strong>初始化当前对象的父类特征</strong></li>
<li>调用<code>super()</code>时并<strong>不会创建一个父类的对象</strong>，从始至终只创建了<strong>一个</strong>对象。通过<code>super()</code>将父类的特征<strong>继承</strong>下来，变成子类自己的。也就是说，子类和它通过<code>super()</code>创建的父类之间的关系是<strong>包含关系</strong>，子类包含了父类的特征。<strong>而<code>super</code>指向的就是当前对象的那部分父类特征</strong><ul>
<li>在上述列子中，<code>super</code>代表的就是<code>a</code>和<code>b</code></li>
<li>虽然<code>a</code>和<code>b</code>是父类<code>A</code>的特征（属性），但子类<code>B</code>一旦继承下来就是属于它自己的了</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vip</span> <span class="keyword">extends</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; is shopping&quot;</span>);<span class="comment">//this指向vip自己</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name + <span class="string">&quot; is shopping&quot;</span>);<span class="comment">//super指向子类中的父类特征属性</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot; is shopping&quot;</span>);<span class="comment">//this可以省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Vip</span> <span class="variable">vip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vip</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        vip.shopping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8cifgs87pj30vs0fw75e.jpg"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8cij8eqqvj317n0o5taj.jpg"></p>
<ul>
<li><p>当通过<code>this</code>来访问<code>name</code>这个属性时，因为<code>name</code>在Vip这个对象的内存中，所以可以访问到</p>
</li>
<li><p>当通过<code>super</code>来访问<code>name</code>这个属性时，因为<code>name</code>是Vip这个对象的父类属性，所以也可以访问到</p>
</li>
<li><p><strong><code>super</code>是<code>this</code>指向对象的一块空间</strong></p>
</li>
<li><p>当我们在Vip类中也添加一个名为<code>name</code>的属性</p>
<ul>
<li>Java允许子类中出现和父类一样的同名属性</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vip2</span> <span class="keyword">extends</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    String name;<span class="comment">//子类中的name属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip2</span><span class="params">()</span>&#123;</span><br><span class="line">      	<span class="comment">//super();</span></span><br><span class="line">      	<span class="comment">//this.name = null;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Vip2</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);<span class="comment">//将name初始化给了父类的name，而子类中的name没有初始化</span></span><br><span class="line">      	<span class="comment">//this.name = null;在一个构造方法中如果没有给属性手动初始化，系统将会自动为其赋默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; is shopping&quot;</span>);<span class="comment">//this指向的子类的name</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name + <span class="string">&quot; is shopping&quot;</span>);<span class="comment">//super指向父类的name</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot; is shopping&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8cizu8qcfj30vu0lcac3.jpg"></p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8cj0c63umj31dx0shju5.jpg"></p>
<h3 id="super-的使用情况"><a href="#super-的使用情况" class="headerlink" title="super.的使用情况"></a><code>super.</code>的使用情况</h3><ul>
<li><code>super.</code>既可以访问父类的属性，也能访问父类的方法</li>
<li>大部分情况下<code>super.</code>都是可以省略的</li>
<li>如果父类和自类具有同名属性&#x2F;方法，并且想要通过子类去访问父类的属性&#x2F;方法，则<code>super.</code>不能省略</li>
<li>Java通过<code>super.</code>来区分同名的子类和父类的属性&#x2F;方法</li>
</ul>
<h3 id="super单独使用"><a href="#super单独使用" class="headerlink" title="super单独使用"></a><code>super</code>单独使用</h3><ul>
<li><p><code>this</code>是可以直接单独使用</p>
<ul>
<li><code>this</code>是一个指向当前对象自己的引用</li>
<li>输出引用时，会自动调用引用的<code>toString()</code>方法，输出该引用地址的一个哈希</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Test2</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line">        test.doSome();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ck5gqjquj30vs0fk757.jpg"></p>
</li>
<li><p><code>super</code>不能单独引用</p>
<ul>
<li><code>super</code>不是引用，不保存内存地址，也不指向任何对象</li>
<li>它只代表当前对象内部的那一块父类型特征</li>
</ul>
</li>
</ul>
<h3 id="super不能用于静态方法中"><a href="#super不能用于静态方法中" class="headerlink" title="super不能用于静态方法中"></a><code>super</code>不能用于静态方法中</h3><ul>
<li><code>this</code>和<code>super</code>的使用需要对象的参与，只能用于实例方法中</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>封装、构造、对象与引用、参数传递</title>
    <url>/2022/11/10/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/</url>
    <content><![CDATA[<h1 id="Java面向对象2"><a href="#Java面向对象2" class="headerlink" title="Java面向对象2"></a>Java面向对象2</h1><h3 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h3><ul>
<li>IDE:Integrated Development Environment</li>
<li>在IDE中不需要额外下载JDK、不需要手动配置环境变量、不需要手动编译生成字节码文件</li>
<li>IDE提供语法检查、提供丰富的代码工具</li>
<li>IntelliJ IDEA的快捷键详见参考文献<sup><a href="#ref1">[1]</a></sup></li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h5 id="封装的作用"><a href="#封装的作用" class="headerlink" title="封装的作用"></a>封装的作用</h5><ol>
<li>安全性：控制外部的访问</li>
<li>有效性：复杂性封装，提供简单的操作入口</li>
<li>复用性：使得对象可以被反复使用</li>
</ol>
<h5 id="封装的步骤"><a href="#封装的步骤" class="headerlink" title="封装的步骤"></a>封装的步骤</h5><ol>
<li><p>所有属性私有化，使用private关键字进行修饰</p>
<ul>
<li>private表示私有的，所修饰的数据只能在本类中访问</li>
</ul>
</li>
<li><p>对外提供简单的操作入口，通过这些简单的操作入口来修改私有属性</p>
<ul>
<li>如果不提供操作入口，私有属性将永远无法被访问</li>
<li>数据的访问存在 读 和 写 两种，因此对外提供两个公开的方法<code>set</code>和<code>get</code>，用于读写私有数据</li>
</ul>
</li>
<li><p>关于<code>set</code>和<code>get</code>的细节</p>
<ul>
<li><code>set</code>方法命名规范</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> set属性名(形参列表)&#123;<span class="comment">//形参不能和私有属性的名字相同</span></span><br><span class="line">	<span class="comment">//进行安全过滤</span></span><br><span class="line">  属性名 = 形式参数;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>get</code>方法命名规范</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 返回类型 get属性名()&#123;</span><br><span class="line">  <span class="comment">//进行安全控制</span></span><br><span class="line">	<span class="keyword">return</span> 属性;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set</code>和<code>get</code>函数的修饰符列表中没有<code>static</code>关键字，直接使用 <code>引用.方法名(实参列表)</code> 来调用</li>
<li><code>set</code>和<code>get</code>函数可以在IntelliJ中自动生成：选中所需要生成<code>set</code>和<code>get</code>方法的实例变量，<code>command + N</code>选择<code>Getter and Setter</code>即可</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h81578xz2pj310a0n0acn.jpg"></p>
</li>
</ol>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>构造方法又被称作构造函数&#x2F;构造器&#x2F;Constructor</li>
<li>构造方法语法结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 构造方法名(形参列表)&#123;</span><br><span class="line">	构造方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>与普通的方法相比较</p>
<ol>
<li>构造方法不需要指定<u>返回值类型</u>， 也不需要为其指定<code>void</code>返回值类型</li>
<li>构造方法名必须和<u>类名</u>保持一致</li>
</ol>
</li>
</ul>
<h5 id="构造方法的作用"><a href="#构造方法的作用" class="headerlink" title="构造方法的作用"></a>构造方法的作用</h5><ol>
<li>通过调用构造函数用于在堆内存中<strong>创建对象</strong></li>
<li>创建对象的同时，<strong>初始化实例变量</strong></li>
</ol>
<h5 id="构造方法的调用"><a href="#构造方法的调用" class="headerlink" title="构造方法的调用"></a>构造方法的调用</h5><ul>
<li>普通方法的调用<ul>
<li>修饰符列表含有<code>static</code>关键字时：<code>类名.方法名(实参列表)</code> (在同一个类中类名可以省略)</li>
<li>修饰符列表不含<code>static</code>关键字时：<code>引用.方法名(实参列表)</code></li>
</ul>
</li>
<li>构造方法的调用<ul>
<li><code>new 构造方法(实参列表)</code></li>
</ul>
</li>
</ul>
<h5 id="有关于构造方法的返回值"><a href="#有关于构造方法的返回值" class="headerlink" title="有关于构造方法的返回值"></a>有关于构造方法的返回值</h5><ul>
<li>构造方法调用结束会返回堆地址中创建的对象的<strong>地址</strong></li>
<li>构造方法的返回值类型<strong>非常固定</strong>，永远是该类的类型，故可以它的省略返回值类型</li>
</ul>
<h5 id="缺省构造器"><a href="#缺省构造器" class="headerlink" title="缺省构造器"></a>缺省构造器</h5><ul>
<li><p>当一个类中没有定义任何构造方法时，系统默认给该类提供一个无参数的构造方法，该方法称为缺省构造器</p>
</li>
<li><p>当类中显示的定义了构造方法时，系统就不会再提供缺省构造器</p>
</li>
<li><p>构造方法支持重载</p>
<ul>
<li>在一个类中可以编写多个构造方法</li>
<li>由于无参数构造方法的常用性，手动的为当前类提供一个无参数的构造方法，避免其之后被省略</li>
<li>每调用一次构造方法就会调用一个对象，<u>调用不同的重载方法，就会创建不同的对象</u></li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8159g1t1pj310u0k0ac5.jpg"></p>
</li>
</ul>
<h5 id="初始化实例变量"><a href="#初始化实例变量" class="headerlink" title="初始化实例变量"></a>初始化实例变量</h5><ul>
<li>在类加载时，系统并不会初始化实例变量，因为实例变量需要通过对象去访问</li>
<li>在通过构造函数初始化对象时进行实例变量的初始化工作</li>
</ul>
<h3 id="对象和引用"><a href="#对象和引用" class="headerlink" title="对象和引用"></a>对象和引用</h3><h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><ul>
<li>通过构造函数在堆内存中开辟的内存空间称为对象</li>
</ul>
<h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><ul>
<li>一个指向堆内存中对象地址的变量</li>
<li>可能是局部变量(在方法中声明)；也可能是实例变量(在类中声明)</li>
<li>所有访问实例相关的数据，都需要通过引用的方式进行访问</li>
<li>一个空引用访问实例相关的数据时运行时会出现“空指针异常”</li>
</ul>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><h5 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h5><ul>
<li>方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一份拷贝，在方法中对这个拷贝的形参做修改，不改变实参的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transfer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//num是一个存放在栈区的普通变量，存储的是数据1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用前num = &quot;</span> + num);</span><br><span class="line">        add(num);<span class="comment">//传递的是num的拷贝，等价于add(10)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用后num = &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按值传递</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//n = 10</span></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="按引用传递"><a href="#按引用传递" class="headerlink" title="按引用传递"></a>按引用传递</h5><ul>
<li>方法调用时，实参的引用被传递给方法中相应的形参，在方法执行过程中，形参和实参指向同一块内存地址，方法执行后再访问该内存地址，会发现实参被改变了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transfer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="number">1</span>);<span class="comment">//test是一个存放在栈中的引用变量，它存储的是一个Test的对象的地址0x6324</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用前test.num = &quot;</span> + test.getNum());</span><br><span class="line">        add(test);<span class="comment">//传递的是Test对象的引用,等价于add(0x6324)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;调用后test.num = &quot;</span> + test.getNum());<span class="comment">//方法执行后，再访问同一个地址</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按引用传递</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Test t)</span> &#123;<span class="comment">//t = 0x6324</span></span><br><span class="line">      <span class="comment">//注意这里，t = 0x6324， 而不是t = test，本质上传递的还是值，t和test两个引用指向了同一个堆内存空间</span></span><br><span class="line">        test.setNum(test.getNum() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//对num进行了封装</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        num = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        num = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8164xm21tj30vk0ludi2.jpg"></p>
<h5 id="参数传递的本质"><a href="#参数传递的本质" class="headerlink" title="参数传递的本质"></a>参数传递的本质</h5><ul>
<li>方法调用涉及参数传递时，Java只遵循的其实只有一种机制：<strong>将变量中存储的“值”传递过去</strong>，只不过这个值有的时候时字面值，有的是内存地址</li>
<li>理解以下这个例子更能明白“传值”的含义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transfer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用前t1.num = &quot;</span> + t1.getNum());</span><br><span class="line">        System.out.println(<span class="string">&quot;调用前t2.num = &quot;</span> + t2.getNum());</span><br><span class="line"></span><br><span class="line">        swap(t1, t2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;调用后t1.num = &quot;</span> + t1.getNum());</span><br><span class="line">        System.out.println(<span class="string">&quot;调用后t2.num = &quot;</span> + t2.getNum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Test test1, Test test2)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        temp = test1;</span><br><span class="line">        test1 = test2;</span><br><span class="line">        test2 = temp;</span><br><span class="line">      <span class="comment">//方法执行后，形参test1和test2的值交换了，实参t1和t2并没有收到改变</span></span><br><span class="line">      <span class="comment">//如果在主函数里访问test1和test2的地址，会发现受到了真正的影响</span></span><br><span class="line">      <span class="comment">//如果在主函数里访问t1和t2的地址，会发现没有任何影响</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        num = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        num = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h816vu4tjej31ik0m4q5n.jpg"></p>
<ul>
<li>我们会发现，调用前后<code>t1</code>和<code>t2</code>的值并没有改变，因为方法调用时，只是将<code>t1</code>和<code>t2</code>的值（也就是两个地址）传进去了，而不是把这两个值真正的传进去</li>
</ul>
<p>Reference <a name="ref1"><font color="black">[1]https://dancon.gitbooks.io/intellij-idea/content/keymap-mac-introduce.html</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>this关键字</title>
    <url>/2022/11/13/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13/</url>
    <content><![CDATA[<h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h1><h3 id="this关键字-1"><a href="#this关键字-1" class="headerlink" title="this关键字"></a>this关键字</h3><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p><code>this</code>关键字用于引用方法或构造函数中的当前对象</p>
<ul>
<li><code>this</code>是一个引用变量，this中保存的内存地址指向自身</li>
<li><code>this</code>存储在堆内存中</li>
<li>在初始化对象过程中，都会初始化该对象的<code>this</code>关键字</li>
</ul>
<h5 id="this的使用情况"><a href="#this的使用情况" class="headerlink" title="this的使用情况"></a><code>this</code>的使用情况</h5><ol>
<li>出现在实例方法中，用于指向当前正在执行这个动作的对象<ul>
<li>一般通过<code>this</code>访问的都是实例变量&#x2F;方法，而在访问这个实例变量&#x2F;方法的大多都是该对象本身，所以<code>this.</code>可以省略</li>
<li><code>this</code>不能出现在带有<code>static</code>的方法中</li>
<li>在<code>static</code>修饰的方法中通过手动创建一个对象来访问实例变量&#x2F;方法</li>
</ul>
</li>
<li>用来区分局部变量和实例变量<ul>
<li>用于区分时，不能省略<code>this.</code></li>
</ul>
</li>
<li>用来调用其他构造方法</li>
</ol>
<h5 id="实例方法-amp-实例变量"><a href="#实例方法-amp-实例变量" class="headerlink" title="实例方法 &amp; 实例变量"></a>实例方法 &amp; 实例变量</h5><ol>
<li><p>实例变量</p>
<ul>
<li>不带<code>static</code>关键字的变量被称为实例变量，通过<code>引用.变量</code>来访问</li>
<li>当一个变量会因为不同的对象而不同时，这个变量需要被定义为实例变量，不能用<code>static</code>来修饰</li>
</ul>
</li>
<li><p>实例方法</p>
<ul>
<li>不带<code>static</code>关键字的方法被称为实例方法，通过<code>引用.方法名(形参列表)</code>来访问</li>
<li>当一个行为&#x2F;动作执行的过程中需要对象参与时，这个方法需要定义为实例方法，不能用<code>static</code>来修饰</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>实例代表这个方法&#x2F;变量时对象级别的，而不是类级别的</li>
<li>访问实例对象&#x2F;方法一定得通过引用来访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;<span class="comment">//实例对象</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String n)</span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span>&#123; <span class="comment">//实例方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例方法，代表shop这个行为是对象级别的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//实例对象的访问应该通过引用来访问！</span></span><br><span class="line"><span class="comment">//        System.out.println(name + &quot;正在购物&quot;);//省略了引用</span></span><br><span class="line">        <span class="comment">//完整写法</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;正在购物&quot;</span>);<span class="comment">//this代表当前正在执行这个行为的对象</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//实例方法的调用也应该通过引用来访问！</span></span><br><span class="line"><span class="comment">//        pay();//省略了引用</span></span><br><span class="line">      	<span class="comment">//完整写法</span></span><br><span class="line">        <span class="built_in">this</span>.pay();<span class="comment">//this代表了当前调用这个行为的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在static修饰的方法中访问实例变量&#x2F;方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">  	<span class="type">int</span> num;<span class="comment">//实例对象</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span>&#123; <span class="comment">//实例方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//在静态方法中访问实例变量的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNum</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(num);//访问失败，必须通过引用.实例变量才能访问，但是this不能出现在static的方法中</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//自己手动创建一个对象即可</span></span><br><span class="line">        System.out.println(u.num);</span><br><span class="line"><span class="comment">//				pay()；//调用失败</span></span><br><span class="line">      	u.pay();<span class="comment">//通过手动创建的对象调用</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="用于区分局部变量和实例变量"><a href="#用于区分局部变量和实例变量" class="headerlink" title="用于区分局部变量和实例变量"></a>用于区分局部变量和实例变量</h5><ul>
<li>在用于区分局部变量和实例变量时，<code>this</code>不能省略</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//封装</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line"><span class="comment">//        name = name;//编译报错，无法区分两个变量</span></span><br><span class="line">        <span class="comment">//通过this来区分实例变量和局部变量</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;<span class="comment">//等号左边的为实例变量，右边的为局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">      	<span class="comment">//此时this可以省略，因为返回的name是实例变量，不需要区分</span></span><br><span class="line">      	<span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="用来调用其他构造方法"><a href="#用来调用其他构造方法" class="headerlink" title="用来调用其他构造方法"></a>用来调用其他构造方法</h3><ul>
<li>出现在构造方法中，通过当前构造方法调用其他构造方法</li>
<li>语法结构<code>this(实参列表)；</code></li>
<li>用这种方法调用构造方法时，这条语句必须出现在构造方法的<strong>第一行</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> year;</span><br><span class="line">  <span class="keyword">private</span> month;</span><br><span class="line">  <span class="keyword">private</span> day;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Constructor</span></span><br><span class="line">    <span class="comment">//要求：在调用无参数的构造方法时，默认创建的日期是&quot;2000-10-25&quot;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">      setYear(year);</span><br><span class="line">      setMonth(month);</span><br><span class="line">      setDay(day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//这样的方式会创建两个对象</span></span><br><span class="line">      <span class="comment">//调用无参的构造函数会生成一个对象，无参构造函数中又调用一个有参的构造函数再生成一个对象</span></span><br><span class="line">  <span class="comment">//        new Date(2000, 10, 25);//调用构造函数只能通过new的方式</span></span><br><span class="line">      <span class="comment">//采用以下的方式来调用构造函数</span></span><br><span class="line">      <span class="built_in">this</span>(<span class="number">2000</span>,<span class="number">10</span>,<span class="number">25</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">      <span class="type">Date</span> <span class="variable">day1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">      System.out.print(<span class="string">&quot;采用无参数的构造函数&quot;</span>);</span><br><span class="line">      day1.printDate();</span><br><span class="line">      </span><br><span class="line">      <span class="type">Date</span> <span class="variable">day2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2022</span>,<span class="number">11</span>,<span class="number">12</span>);</span><br><span class="line">      System.out.print(<span class="string">&quot;采用带参数的构造函数&quot;</span>);</span><br><span class="line">      day2.printDate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h827qci8k8j312e0kcac7.jpg"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>static关键字</title>
    <url>/2022/11/13/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A14/</url>
    <content><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h3 id="static-1"><a href="#static-1" class="headerlink" title="static"></a>static</h3><ul>
<li>静态的</li>
<li><code>static</code>可以用来修饰变量和方法，所修饰的变量称为静态变量，所修饰的方法称为静态方法</li>
<li><code>static</code>所修饰的元素都是类级别的特征，与具体的对象无关</li>
<li>直接通过<code>类名.</code>访问<code>static</code>所修饰内容</li>
<li>静态变量&#x2F;方法在类加载时就初始化了，<strong>内存在方法区中开辟</strong>，不需要通过创建对象来初始化</li>
</ul>
<h3 id="成员变量的类型"><a href="#成员变量的类型" class="headerlink" title="成员变量的类型"></a>成员变量的类型</h3><ol>
<li>实例变量<ul>
<li>所有的对象都拥有的属性，但是这个属性随着对象的不同而不同</li>
</ul>
</li>
<li>静态变量<ul>
<li>用<code>static</code>关键字声明的变量称为静态成员变量</li>
<li>所有的对象同样拥有这个属性，但是所有对象的这个属性值都相同</li>
<li>节省内存空间<ul>
<li>当所有的对象都拥有相同的属性值，如果在堆内存中给每个属性都开辟一块空间存储冗余的数据会造成空间浪费</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="成员方法的类型"><a href="#成员方法的类型" class="headerlink" title="成员方法的类型"></a>成员方法的类型</h3><ol>
<li>实例方法<ul>
<li>方法描述的是动作，每个对象执行实例动作后产生的结果不同</li>
</ul>
</li>
<li>静态方法<ul>
<li>一个类中所有的对象执行静态方法后产生的结果都相同</li>
<li>静态方法的动作不属于对象，而是可以提升至类这个级别</li>
<li>静态方法中无法直接访问实例变量以及实例方法</li>
</ul>
</li>
<li>绝大部分动作都定义为实例方法，因为大部分动作的执行都需要对象的参与</li>
<li>大部分工具类的方法都可以被定义为静态方法，为了方便编程，大部分工具类的方法都不需要对象的参与</li>
</ol>
<h3 id="static的访问"><a href="#static的访问" class="headerlink" title="static的访问"></a>static的访问</h3><ul>
<li><p>静态变量可以通过<code>类名.静态变量名</code>来直接访问</p>
<ul>
<li>所有的静态数据既可以通过类名的方式访问，也可以通过引用的方式访问</li>
<li>当通过引用来访问时，即使这个引用指向null，也不会出现空指针异常的情况</li>
<li>因为本质上是通过这个引用所在的类来访问静态的数据，不需要引用的存在！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chinese</span> &#123;</span><br><span class="line">    <span class="type">int</span> ID;<span class="comment">//实例变量</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;China&quot;</span>;<span class="comment">//静态变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//静态变量无需在创建对象时就初始化</span></span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">people1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">people2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>(<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">people3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态变量通过类名直接访问</span></span><br><span class="line">        System.out.println(people1.ID + <span class="string">&quot; &quot;</span> + people1.name + <span class="string">&quot; &quot;</span> + Chinese.country);</span><br><span class="line">        <span class="comment">//静态变量也可以通过对象访问，但是编译器会警告</span></span><br><span class="line">        System.out.println(people2.ID + <span class="string">&quot; &quot;</span> + people2.name + <span class="string">&quot; &quot;</span> + people2.country);</span><br><span class="line">        <span class="comment">//即使是一个空对象，他的静态变量也会被初始化</span></span><br><span class="line">        System.out.println(people3.ID + <span class="string">&quot; &quot;</span> + people3.name + <span class="string">&quot; &quot;</span> + people3.country);</span><br><span class="line">        <span class="comment">//即使是一个指向空的引用，也能正常访问其静态变量</span></span><br><span class="line">        <span class="comment">//也就是说，静态变量和对象没有任何关系，只和类有关系</span></span><br><span class="line">        people3 = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(people3.country);</span><br><span class="line">        <span class="comment">//但是访问people.ID会出现空指针异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h83arj3rk4j30vq0gw3zi.jpg"></p>
</li>
</ul>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><ul>
<li>语法格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	Java语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态代码块在类加载时执行，并且只执行一次</li>
<li>静态代码块在类中可以编写多个，遵循自上而下依次执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCode</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块1的执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块2的执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h83bcjet5gj30um0eujsg.jpg"></p>
<ul>
<li><p>静态代码块在加载<code>StaticCode</code>时就执行了，比主函数执行的还要提前</p>
</li>
<li><p><strong>静态代码块的作用</strong></p>
<ol>
<li>静态代码块可以用来<u>记录类加载时刻</u>，可以在类加载时刻执行一些特定的动作</li>
<li>可以在静态代码块中记录日志、完成初始化工作以及一些准备工作</li>
</ol>
</li>
</ul>
<h3 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h3><ul>
<li>语法格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	Java语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例代码块可以编写多个，遵循自上而下的顺序依次执行</li>
<li>实例代码块在构造函数之前执行，构造函数执行一次实例代码块就执行一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InstanceCode</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造函数执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例块1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例块2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">InstanceCode</span> <span class="variable">ins1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstanceCode</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;主函数执行&quot;</span>);</span><br><span class="line">        <span class="type">InstanceCode</span> <span class="variable">ins2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstanceCode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h83bjdcoxaj30ua0leabf.jpg"></p>
<ul>
<li>实例代码块的作用：实例代码块可以用来记录对象初始化时刻</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2022/11/13/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A15/</url>
    <content><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h3 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h3><ul>
<li>继承是面向对象三大特征之一（封装、继承、多态）</li>
<li>继承的基本作用是<u>代码复用</u>，有了继承之后才有方法的覆盖和多态机制</li>
<li>继承允许创建分等级层次的类</li>
<li>语法结构</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表]class 父类&#123;</span><br><span class="line">	类体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[修饰符列表] class 类名 extends 父类&#123;</span><br><span class="line">	类体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>继承的数据类型</strong><ol>
<li>私有的不支持继承</li>
<li>构造函数不支持继承</li>
<li>其余的都支持继承</li>
</ol>
</li>
<li>Java语言中只支持单继承，一个类不能同时继承很多个类（C++中支持多继承）</li>
<li>Java中的间接继承<ul>
<li>D extends C, C extends B, B extends A，则D直接继承C，间接继承B和A</li>
</ul>
</li>
<li>当Java中一个类没有显示的继承任何类时，该类<strong>默认继承</strong>JavaSE中的java.lang.Object类</li>
</ul>
<h3 id="继承的术语"><a href="#继承的术语" class="headerlink" title="继承的术语"></a>继承的术语</h3><p>B类继承A类</p>
<ul>
<li>A类称为：父类，基类，超类(Superclass)</li>
<li>B类称为：子类、派生类(Subclass)</li>
</ul>
<p>一个简单的继承的例子</p>
<ul>
<li>银行账户类有自己的账户号码和账户余额</li>
<li>信用卡类继承账类，这样信用卡类就可以继承账户类中对于封装实例变量的set和get方法</li>
<li>在测试类中设置信用卡的账号和余额并获取其中的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//账户类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//封装的账户号码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> balance;<span class="comment">//封装的余额</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> num, <span class="type">float</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//一定得有这个缺省的构造函数</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">float</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CredictCard</span> <span class="keyword">extends</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> credit;</span><br><span class="line">  	<span class="comment">//省略自己的set和get方法，直接调用父类的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExtends</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">CredictCard</span> <span class="variable">cre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CredictCard</span>();</span><br><span class="line">        cre.setNum(<span class="number">123</span>);<span class="comment">//调用继承的方法</span></span><br><span class="line">        cre.setBalance(<span class="number">100.1f</span>);<span class="comment">//调用继承的方法</span></span><br><span class="line">        System.out.println(cre.getNum() + <span class="string">&quot; &quot;</span> + cre.getBalance());<span class="comment">//调用继承的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>方法的覆盖</title>
    <url>/2022/11/14/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A16/</url>
    <content><![CDATA[<h1 id="方法的覆盖Override"><a href="#方法的覆盖Override" class="headerlink" title="方法的覆盖Override"></a>方法的覆盖Override</h1><h3 id="方法的重载Overload"><a href="#方法的重载Overload" class="headerlink" title="方法的重载Overload"></a>方法的重载Overload</h3><ul>
<li>适用情况<ul>
<li>在同一个类中，方法完成的功能相似时，建议方法名相同，这样方便编程、代码美观</li>
</ul>
</li>
<li>使用条件<ul>
<li>在同一个类中</li>
<li>方法名相同</li>
<li>参数列表不同：类型不同、顺序不同、个数不同</li>
</ul>
</li>
<li>方法重载<ul>
<li>与方法返回值无关</li>
<li>与方法的修饰符列表无关</li>
</ul>
</li>
</ul>
<h3 id="方法覆盖Overide"><a href="#方法覆盖Overide" class="headerlink" title="方法覆盖Overide"></a>方法覆盖Overide</h3><ul>
<li><p>又称为方法重写Overwrite</p>
</li>
<li><p>适用情况</p>
<ul>
<li>当父类中的方法无法满足当前子类的要求时，子类有必要将父类继承过来的方法进行重写</li>
<li>举一个例子：父类Animal有一个动作move可以输出“动物在移动”，子类Cat和Bird继承了这两个方法，若不重写的话，两个子类调用move方法还是会输出同样的内容</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在移动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;<span class="comment">//Cat类继承动物类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125;<span class="comment">//Bird继承动物类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Animal类：&quot;</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        animal.move();</span><br><span class="line">        System.out.print(<span class="string">&quot;Cat类：&quot;</span>);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.move();</span><br><span class="line">        System.out.print(<span class="string">&quot;Bird类：&quot;</span>);</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        bird.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h84e0pyl50j30uc0feq42.jpg"></p>
</li>
<li><p>使用条件</p>
<ul>
<li>方法重写发生在具有继承关系的父子类之间</li>
<li>重写的方法必须和父类的方法的<u>返回值类型</u>、<u>方法名</u>、<u>形参列表</u>相同<ul>
<li>直接复制粘贴父类的方法，然后修改方法体中内容即可</li>
</ul>
</li>
<li>修饰符列表：子类重写的方法访问权限可以更低，但不能更高</li>
<li>抛出的异常可以更少，但不能更多</li>
<li>同样针对上述例子，进行方法重写</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在移动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟在飞翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Animal类：&quot;</span>);</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        animal.move();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Cat类：&quot;</span>);</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.move();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Bird类：&quot;</span>);</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        bird.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h84ee8k3tjj30u20dydgt.jpg"></p>
</li>
<li><p>注意</p>
<ol>
<li>私有方法不能继承，所以不能覆盖</li>
<li>构造方法不能继承，所以不能覆盖</li>
<li>静态方法不存在覆盖</li>
<li>覆盖只针对方法，不针对属性</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多态</title>
    <url>/2022/11/14/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A17/</url>
    <content><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h3 id="多态中的几个概念"><a href="#多态中的几个概念" class="headerlink" title="多态中的几个概念"></a>多态中的几个概念</h3><ul>
<li>向上转型upcasting：子类型转向父类型，又被称为自动类型转换</li>
<li>向下转型downcasting：父类型转向子类型，又被称为强制类型转换</li>
<li>无论是向上转型还是向下转型，两种类型之间都要<u>满足继承</u>的关系才能转型</li>
</ul>
<h3 id="分析一个例子"><a href="#分析一个例子" class="headerlink" title="分析一个例子"></a>分析一个例子</h3><ul>
<li>有一个动物类，动物类中有移动的方法，动物在移动时输出“动物在移动”</li>
<li>有一个鸟类，鸟类继承动物类，并且覆盖了移动的方法，鸟在移动时输出“鸟在飞翔”</li>
<li>在主函数中声明一个指向鸟的动物类引用，试分析整个程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在移动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸟在飞翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//父类型的引用指向一个子类型的对象</span></span><br><span class="line">        <span class="comment">//编译时animal是动物</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//鸟是动物</span></span><br><span class="line">        <span class="comment">//animal是动物类的引用，但指向的是鸟类的堆地址</span></span><br><span class="line">        <span class="comment">//在底层animal还是一个鸟类的引用</span></span><br><span class="line">        <span class="comment">//运行时animal是鸟</span></span><br><span class="line">        animal.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h84g7y3y5zj30u40bcmxt.jpg"></p>
<ul>
<li>Java程序分为<u>编译</u>和<u>运行</u>两个阶段</li>
<li>在编译阶段<ul>
<li>如果编译报错，则程序无法运行；编译阶段只检查语法，不会开辟内存空间，也不会运行程序</li>
<li>编译阶段编译器检查animal这个引用，它声明时的数据类型为Animal</li>
<li>在Animal.class字节码文件中有move()这个方法，所以调用animal.move()时编译通过</li>
<li>这个过程我们称为<strong>静态绑定</strong>，也就是在编译阶段绑定</li>
</ul>
</li>
<li>在运行阶段<ul>
<li>运行时animal这个引用指向的堆内存存储的是一个Bird类型的数据</li>
<li>也就是说在JVM的堆内存中真实创建的对象是一个Bird类型的对象</li>
<li>那么在运行时调用的就是Bird类中的move()方法</li>
<li>这个过程我们称为程序的<strong>动态绑定</strong>，在运行阶段绑定</li>
</ul>
</li>
<li>更进一步的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="comment">//    public void move()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;鸟在飞翔&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hatch</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;鸟在孵蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//父类型的引用指向一个子类型的对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//鸟是动物</span></span><br><span class="line">        animal.move();</span><br><span class="line">      	<span class="comment">//animal.hatch();//编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h84ggx8rmdj30u60bkgmd.jpg"></p>
<ul>
<li>此时animal.move()调用的还是Bird中的move()方法，只不过Bird中的move()方法直接继承了Animal中的方法，没有进行重写</li>
<li>当animal尝试调用Bird中的hatch()方法时，程序在编译阶段就会报错，因为在Animal.class字节码文件中Animal类没有hatch()方法，静态绑定失败！</li>
<li>总结<ol>
<li>编译时只检查语法</li>
<li><strong>运行时引用指向的是什么对象就调用该对象的方法</strong></li>
</ol>
</li>
</ul>
<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><ul>
<li><p>当调用的方法&#x2F;属性是<u>子类独有</u>的，在父类中不存在，则必须通过向下转型才能实现调用&#x2F;访问</p>
<ul>
<li><code>animal.hatch()</code></li>
</ul>
</li>
<li><p>将父类的引用强制转换为子类</p>
</li>
<li><p>强制类型转换语法格式</p>
<ul>
<li><p>子类 引用 &#x3D; (父类) 引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//animal.hatch()编译报错</span></span><br><span class="line"><span class="comment">//编译通过</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line"><span class="type">Bird</span> <span class="variable">animal2</span> <span class="operator">=</span> (Bird) animal1;</span><br><span class="line">animal2.hatch();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>java.lang.ClassCastException</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> (Cat) animal3;</span><br><span class="line"><span class="comment">//编译通过，但是运行时出错</span></span><br><span class="line"><span class="comment">//Exception in thread &quot;main&quot; java.lang.ClassCastException: class Animal.Bird cannot be cast to class Animal.Cat</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>编译期</p>
<ul>
<li><code>animal3</code>是一个父类的引用，声明时指向子类<code>Bird</code>的对象，编译通过</li>
<li>将<code>animal3</code>这个父类的引用向下转型，转换为子类<code>Cat</code>的引用，编译通过</li>
</ul>
</li>
<li><p>运行期</p>
<ul>
<li>运行期间，<code>animal3</code>这个引用初始化时指向的是堆内存中<code>Bird</code>类对象</li>
<li>在进行强制类型转换时，由于<code>Cat</code>类和<code>Bird</code>类之间不存在继承关系，<code>Bird</code>类对象无法转换成<code>Cat</code>类对象</li>
<li>出现<code>java.lang.ClassCastException</code>异常</li>
</ul>
</li>
<li><p><strong>这种异常总是在“向下转型”时发生</strong></p>
</li>
<li><p>向上转型：只要编译通过了，运行一定不会出现异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//父类型引用指向子类型对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>向下转型：存在安全隐患，即使编译通过，运行时也可能出现类型转换异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> (Cat) animal3;<span class="comment">//父类引用被强制转换为子类引用</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><ul>
<li><p>解决向下转型时出现的安全风险</p>
</li>
<li><p>语法格式</p>
<ul>
<li><code>引用 instanceof 数据类型</code></li>
<li>例如：<code>a instanceof Animal</code></li>
<li>以上表达式的运算结果类型是布尔类型<ul>
<li>当返回值是<code>true</code>时表示这个引用是当前的数据类型</li>
<li>当返回值是<code>false</code>时表示这个引用不是当前的数据类型</li>
</ul>
</li>
</ul>
</li>
<li><p>Java规范中要求：在强制类型转换之前，使用<code>instanceof</code>运算符进行判断，避免<code>ClassCastException</code>的发生</p>
<ul>
<li>避免上述例子的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//父类型引用指向子类型对象</span></span><br><span class="line"><span class="keyword">if</span> (animal3 <span class="keyword">instanceof</span> Cat)&#123;<span class="comment">//判断父类引用在底层是否指向需要的类</span></span><br><span class="line">  <span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> (Cat) animal3;<span class="comment">//如果是，再进行强制类型转换</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;不能进行强制类型转换&quot;</span>);<span class="comment">//否则报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h3><ul>
<li><p>以主人饲养宠物为例</p>
<ul>
<li>主人可以饲养多种类型的宠物，给不同类型的宠物喂食，不同的宠物会有不同的反应</li>
</ul>
</li>
<li><p>不采用多态的方法</p>
<ul>
<li>针对每一种类型的宠物，都要单独在主人<code>Owner</code>类中编写一个<code>feed(宠物类型 宠物)</code>的方法</li>
</ul>
</li>
<li><p>采用多态的方法</p>
<ul>
<li>让所有猫、狗等不同的宠物类型继承<code>Pet</code>的父类，在Owner中只用编写一个<code>feed(Pet pet)</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Owner</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//主人的姓名</span></span><br><span class="line">    <span class="keyword">private</span> Pet pet;<span class="comment">//主人拥有的宠物</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">//主人喂食</span></span><br><span class="line">  	<span class="comment">//主人面向的是抽象的Pet类，而不是具体的某一种宠物，降低耦合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Pet pet)</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;正在喂东西&quot;</span>);</span><br><span class="line">        pet.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;宠物正在吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">  	<span class="comment">//覆盖父类的eat方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小狗正在吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小猫正在吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只用在这里不停的添加新的宠物类型，而不用修改Owner类</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">//小狗类型的宠物</span></span><br><span class="line">        <span class="type">Owner</span> <span class="variable">owner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Owner</span>(<span class="string">&quot;张三&quot;</span>,pet);<span class="comment">//张三养的宠物是小狗类型</span></span><br><span class="line">        owner.feed(pet);</span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//张三养的宠物是小狗类型</span></span><br><span class="line">        owner.setPet(pet2);</span><br><span class="line">        owner.feed(pet2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多态的作用：<strong>降低程序的耦合度，提高程序的扩展力</strong></p>
</li>
<li><p>尽力多使用多态语法，父类型引用指向子类型对象</p>
</li>
<li><p><strong>面向抽象编程，而不要面向具体编程</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>final关键字</title>
    <url>/2022/11/16/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A18/</url>
    <content><![CDATA[<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><ul>
<li><p><code>final</code>关键字的作用</p>
<ul>
<li><code>final</code>是一个关键字，表示<u>最终的、不可变的</u></li>
<li><code>final</code>修饰的类是无法被继承的</li>
<li><code>final</code>修饰的方法无法被覆盖</li>
<li><code>final</code>修饰的变量一旦被赋值后，不可重新被赋值</li>
<li><code>final</code>修饰的实例变量，必须手动赋值，不能采用系统默认值</li>
<li><code>final</code>修饰的引用一旦指向一个堆内存中的对象后，不可重新指向其他对象</li>
</ul>
</li>
<li><p><code>final</code>修饰类时，被修饰的类无法再被继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> <span class="keyword">extends</span> <span class="title class_">test1</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h86z6voe8fj314a0dkgmr.jpg"></p>
</li>
<li><p><code>final</code>修饰的方法无法被覆盖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> <span class="keyword">extends</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h86zbb1qijj31ba0eu0uo.jpg"></p>
</li>
<li><p><code>final</code>修饰的变量一旦被赋值后，不能重新被赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        num1 = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        num2 = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h86zh8bkrpj30xe0pumzh.jpg"></p>
</li>
<li><p><code>final</code>修饰的实例变量，必须在声明时就手动赋值</p>
<ul>
<li>实例变量在声明时，如果不手动初始化，系统将会自动为其初始化为0</li>
<li>但是被<code>final</code>修饰的变量只能被赋值一次，所以如果初始化时不对其进行手动赋值，则它永远也不能被赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> <span class="keyword">extends</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> c;<span class="comment">//编译错误</span></span><br><span class="line">  	<span class="keyword">final</span> <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//编译通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h86zz7zq7lj30ve0n8gno.jpg"></p>
</li>
<li><p><code>final</code>修饰的引用一旦指向一个对象后，就不能再指向其他对象</p>
<ul>
<li>这也意味着，被<code>final</code>修饰的引用指向的对象无法被垃圾回收器回收</li>
<li>但是被<code>final</code>修饰的引用指向的对象的内存是可以被修改的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">test = <span class="keyword">new</span> <span class="title class_">Test</span>();<span class="comment">//编译报错</span></span><br><span class="line">test.num = <span class="number">10</span>;<span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li><p>final修饰的实例变量都是不可变的，这种变量一般都和static联合使用，被称为常量</p>
<ul>
<li>不可变的实例变量如果在每个对象中都保存一份的话会造成空间浪费</li>
</ul>
</li>
<li><p>语法格式</p>
<p><code>public static final 数据类型 常量名 = 值;</code></p>
</li>
<li><p>常量名的命名规范：所有字母大写，每个单词之间通过下划线来连接</p>
</li>
<li><p>由于常量在声明后无法被修改，所以被<code>public</code>修饰也是十分安全的</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>包</title>
    <url>/2022/11/17/Java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A19/</url>
    <content><![CDATA[<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h3 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h3><ul>
<li><p>包<code>package</code>，Java中引入包机制主要是为了方便程序管理。不同功能的类被分门别类的放到不同的软件包当中，便于查找、管理依旧维护</p>
</li>
<li><p><code>package</code>的定义</p>
<ul>
<li>在Java源程序的第一行上编写<code>package</code>语句</li>
<li><code>package</code>只能编写一个语句</li>
<li>语法结构：<code>package 包名;</code></li>
</ul>
</li>
<li><p>包的命名规范：</p>
<ul>
<li>前缀 + 发起者名 + 项目名 + 模块名<ul>
<li>前缀：<ul>
<li><code>pers</code>个人项目，独自开发</li>
<li><code>priv</code>私有项目</li>
<li><code>team</code>团队项目</li>
<li><code>com</code>公司项目</li>
</ul>
</li>
</ul>
</li>
<li>包名要求<u>全部小写</u>，包名也是标识符，必须遵循标识符的命名规范</li>
</ul>
</li>
<li><p>一个包对应一个目录，目录之间用<code>.</code>分隔开</p>
<ul>
<li>例如：<code>pers.kevin.javase.day1117</code>就会生成四个目录</li>
</ul>
</li>
<li><p>一旦使用包机制后，<strong>类的名称就会改变</strong></p>
<ul>
<li>我们编写一个Test类，当使用如上的包后，Test类的名称就会变成<code>pers.kevin.javase.day1117.Test</code></li>
<li>当使用<code>javac</code>进行编译时，由于<code>javac</code>后面接的是文件的路径，所以使用包机制后带来的类名的变化影响不大</li>
<li>我们将<code>java</code>源程序放在<u>其他目录</u>下进行编译</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h87v6qn5vcj30nm09xwez.jpg"></p>
<ul>
<li>编译通过，并且在同一个目录下生成了相应的字节码文件</li>
<li>那么我们尝试在这个目录下对其使用<code>java</code>命令</li>
</ul>
<p>![image-20221117092753802](&#x2F;Users&#x2F;hewenkai&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221117092753802.png)</p>
<ul>
<li>编译器报错，提示找不到或无法加载主类</li>
<li>那么我们修改相应的类名</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h87vbgvw9kj30pq0gl40m.jpg"></p>
<ul>
<li>编译器同样报错，提示相同的原因</li>
<li>我们将字节码文件移动到包所对应的目录下，再次尝试运行</li>
</ul>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h87wdcf69nj30pq0gldgm.jpg"></p>
</li>
<li><p>包名的省略</p>
<ul>
<li><p>当两个类在同一个包下时，可以省略包名</p>
</li>
<li><p>当两个类不在同一个包下时，一定要在类前加上完整的包名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		pers.kevin.javase.day1117.<span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">pers</span>.kevin.javase.day1117.Test();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a><code>import</code>关键字</h3><ul>
<li>import语句用来完成导入其他类，同一个包下的类不需要倒入，不在同一个包下的类需要手动导入</li>
<li>语法格式：<ul>
<li><code>import 类名;</code></li>
<li><code>import 包名.*;</code>代表引入这个包下的所有类</li>
</ul>
</li>
<li><code>import</code>语句需要编写到<code>package</code>语句之下，<code>class</code>语句之上</li>
<li>同样是上面的例子：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pers.kevin.javase.day1117.Test;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>java.lang.*不需要手动引入</li>
</ul>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义时间</title>
    <url>/2022/11/23/Java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="自定义时间"><a href="#自定义时间" class="headerlink" title="自定义时间"></a>自定义时间</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>自定义一个时间类，能够完成对时间的加减操作。</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>针对这个问题，我们需要定义一个时间类<code>MyTime</code>，其中当然必须包含三个属性<code>hour</code>，<code>minute</code>和<code>second</code>，为了安全起见，我们将这三个属性设置为私有属性。这个问题最麻烦的部分当然是对时间的各项操作，包括时间的增加、减少，具体来说，最复杂的部分应该是时间的减少。</p>
<p>我的第一个思路是直接对各项属性进行操作，例如：增加多少秒，则直接通过<code>setSecond</code>函数来实现，然后再来调整各个属性，如果秒数超过<code>60</code>则进位等等。这个思路在解决时间相加时是比较简单的，但是解决时间减少时就比较麻烦了，尤其是对秒进行相减时，需要考虑<code>hour</code>，<code>minute</code>和<code>second</code>三个属性的变化。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHour</span><span class="params">(<span class="type">int</span> hor)</span> &#123;</span><br><span class="line">    setHour((getHour() + hor) % <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMinute</span><span class="params">(<span class="type">int</span> min)</span> &#123;</span><br><span class="line">    min = min + getMinute();</span><br><span class="line">    <span class="keyword">if</span> (min &lt; <span class="number">60</span>) &#123;</span><br><span class="line">        setMinute(min);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addHour(min / <span class="number">60</span>);</span><br><span class="line">        setMinute((min % <span class="number">60</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSecond</span><span class="params">(<span class="type">int</span> sec)</span> &#123;</span><br><span class="line">    sec = sec + getSecond();</span><br><span class="line">    <span class="keyword">if</span> (sec &lt; <span class="number">60</span>) &#123;</span><br><span class="line">        setSecond(sec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addMinute(sec / <span class="number">60</span>);</span><br><span class="line">        setSecond(sec % <span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subHour</span><span class="params">(<span class="type">int</span> hor)</span> &#123;</span><br><span class="line">    hor = getHour() - hor;</span><br><span class="line">    <span class="keyword">if</span> (hor &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;时间错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setHour(hor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subMinute</span><span class="params">(<span class="type">int</span> min)</span> &#123;</span><br><span class="line">    min = getMinute() - min;</span><br><span class="line">  	<span class="comment">//这里需要考虑复杂的借位情况</span></span><br><span class="line">  	<span class="comment">//分钟只需要向小时借位，但借的位数变化很大</span></span><br><span class="line">    <span class="keyword">if</span> (min &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        subHour(min / <span class="number">60</span> * (-<span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        min = <span class="number">60</span> + min % <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">if</span> (min &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            addHour(min / <span class="number">60</span>);</span><br><span class="line">            setMinute(min % <span class="number">60</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setMinute(<span class="number">60</span> + min % <span class="number">60</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setMinute(min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subSecond</span><span class="params">(<span class="type">int</span> sec)</span> &#123;</span><br><span class="line">  	<span class="comment">//需要考虑向分、小时借位的情况</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>在写到<code>subSecond</code>方法时，我意识到这个思路太麻烦了，可能不是解决这个问题的最好办法。</p>
<p>这时，我想到能否运用<strong>面向对象的思想</strong>来解决这个问题：在时间增加时，不是直接对<code>MyTime</code>对象的一个属性进行相加，而是将要增加&#x2F;减少的时间也封装成一个<code>MyTime</code>对象，直接进行对象与对象之间的操作。然后再定义一个方法，能够调整每个对象的属性，使对象的各个属性合法（小时的取值在$0～23$之间，分钟和秒的取值在$0～59$之间）。这样，相加时，直接两个对象对应的属性相加，加完了再调整一下最后的结果；相减时，直接两个对象对应的属性相减，减完了再调整一下。</p>
<p>这个方法的好处是大大简化了时间相加减的操作。</p>
<ul>
<li>一方面，两个规范合法的对象相加减，分钟或者秒如果要借位的话也最多只用借一位（最极限的情况$0-59&#x3D;-59$），要进位的话也最多只用尽一位（$59+59&#x3D;118$），在这种情况下不用考虑一次操作对多个属性的影响。举个例子，按照方法一直接给某一个属性进行操作，比如按最复杂的秒来说，如果要增加3600秒，那么就需要<code>setSecond(getSecond()+3600)</code>，那么这个操作之后就需要再去调整分、小时，这两个属性，它们的进位、借位情况会随着不同的值而有很大的不同。但是如果按照方法二，我们需要考虑的情况就会大大减少，每一次操作最多影响两个属性，而且影响的范围不过是进或者借一位。</li>
<li>另一方面，我们可以直接省略进位&#x2F;借位的操作，尤其即使是只进了一位（$10:59:59+0:0:1$）会影响多个属性的特殊情况。通过规范化的函数，我们可以让任意一个<code>MyTime</code>对象的属性合法。也就是说，对于任何一次的运算结果，我们可以不用考虑过多运算进位&#x2F;借位的过程，而是将最后的运算结果（例如上一个例子的运算结果：$10:59:60$）再次进行一次规范化，不停的进行规范化操作，直到最后的结果合法，并且这个规范化的过程不过是调用一个函数。</li>
</ul>
<p>这个方法当然也不是我一下就想出来的，即使我有了用封装的办法来解决这个问题的思路后还是碰到了不少麻烦。虽然我想到了直接用两个对象进行操作，但我并没有意思到可以对操作的结果再进行一次标准化，以此来减少麻烦，我一开始还是想着在sub方法里详细的考虑每一种情况。如果按照这样的思路的话，其实我这样做也没有比方法一好太多。但是我还是学习到了不少东西，比如说有关于Java中的向上取整方法。</p>
<h4 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整"></a>向上取整</h4><ul>
<li><p>在Java中的除运算是向下取整的，向上取整需要调用<code>Math.ceil(double a)</code>方法</p>
</li>
<li><p>语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Math;<span class="comment">//需要导入Math包</span></span><br><span class="line"><span class="comment">//它的返回值是double类型的，参数列表也需要的也是一个double</span></span><br><span class="line"><span class="type">double</span> Math.ceil(<span class="type">double</span> a)</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算$5&#x2F;2$向下取整以及$-2&#x2F;3$向下取整</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要将最后的计算结果强制转化为int才</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res1</span> <span class="operator">=</span> (<span class="type">int</span>)Math.ceil((<span class="type">double</span>)<span class="number">5</span>/<span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">res2</span> <span class="operator">=</span> (<span class="type">int</span>)Math.ceil((<span class="type">double</span>)-<span class="number">2</span>/<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8f1iimxj7j30vq0f0q4a.jpg"></p>
</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTime</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hour;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> minute;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTime</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTime</span><span class="params">(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (second &lt; <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.second = second;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minute = minute + second / <span class="number">60</span>;</span><br><span class="line">            <span class="built_in">this</span>.second = second % <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minute &lt; <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.minute = minute;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hour = hour + minute / <span class="number">60</span>;</span><br><span class="line">            <span class="built_in">this</span>.minute = minute % <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.hour = hour % <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将输入的时间转换为MyTime对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyTime <span class="title function_">trans</span><span class="params">(<span class="type">int</span> time, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="comment">//2代表秒 1代表分 0代表小时</span></span><br><span class="line">        <span class="type">MyTime</span> <span class="variable">myTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTime</span>();</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                myTime.setHour(time / <span class="number">3600</span>);</span><br><span class="line">                time = time % <span class="number">3600</span>;</span><br><span class="line">                myTime.setMinute(time / <span class="number">60</span>);</span><br><span class="line">                myTime.setSecond(time % <span class="number">60</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                myTime.setHour(time / <span class="number">60</span>);</span><br><span class="line">                myTime.setMinute(time % <span class="number">60</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                myTime.setHour(time);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;时间类型错误！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整Mytime对象，使其数字合法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trans</span><span class="params">(MyTime time)</span> &#123;</span><br><span class="line">        <span class="comment">//对秒进行标准化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> time.getSecond();</span><br><span class="line">            <span class="comment">//如果秒大于或者等于60，则需要进位</span></span><br><span class="line">            <span class="comment">//需要注意的是，两个标准的MyTime类型相加，最多只会进一位</span></span><br><span class="line">        <span class="keyword">if</span> (second &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            time.setMinute(time.getMinute() + second / <span class="number">60</span>);</span><br><span class="line">            time.setSecond(second % <span class="number">60</span>);</span><br><span class="line">            trans(time);<span class="comment">//再次标准化，因为可能分钟属性超过了60</span></span><br><span class="line">        &#125; <span class="keyword">if</span>(second &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//若秒小于0，则需要借为</span></span><br><span class="line">            <span class="comment">//两个标准的MyTime类型相减，最多只会借一位</span></span><br><span class="line">            time.setSecond(<span class="number">60</span> + second);</span><br><span class="line">            time.setMinute(time.getMinute() - <span class="number">1</span>);<span class="comment">//借一位</span></span><br><span class="line">            trans(time);<span class="comment">//再次标准化</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果秒小于60，且大于0，则直接赋值即可</span></span><br><span class="line">            time.setSecond(second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对分钟进行标准化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> time.getMinute();</span><br><span class="line">            <span class="comment">//如果分钟大于或者等于60，则需要进位</span></span><br><span class="line">            <span class="comment">//最多进一位</span></span><br><span class="line">        <span class="keyword">if</span> (minute &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            time.setHour(time.getHour() + minute / <span class="number">60</span>);</span><br><span class="line">            time.setMinute(minute % <span class="number">60</span>);</span><br><span class="line">            trans(time);</span><br><span class="line">        &#125;<span class="keyword">if</span> (minute &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//分钟小于0，则需要借位</span></span><br><span class="line">            <span class="comment">//最多只会借一位</span></span><br><span class="line">            time.setMinute(<span class="number">60</span> + minute);</span><br><span class="line">            <span class="comment">//https://blog.csdn.net/qq_39290394/article/details/102468431</span></span><br><span class="line">            time.setHour(time.getHour() - <span class="number">1</span>);<span class="comment">//对应的小时减少</span></span><br><span class="line">            trans(time);<span class="comment">//再次标准化</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果分钟小于60，且大于0，则直接赋值即可</span></span><br><span class="line">            time.setMinute(minute);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对小时进行标准化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> time.getHour();</span><br><span class="line">            <span class="comment">//如果小时大于24，则需要进行取模运输</span></span><br><span class="line">        <span class="keyword">if</span> (hour &gt; <span class="number">24</span>)&#123;</span><br><span class="line">            time.setHour(hour % <span class="number">24</span>);</span><br><span class="line">            <span class="comment">//如果小时小于0，则需要转换为正数</span></span><br><span class="line">            <span class="comment">//两个标准的MyTime进行相减，最小的结果为-24</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hour &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            time.setHour(hour + <span class="number">24</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            time.setHour(hour);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHour</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hour;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHour</span><span class="params">(<span class="type">int</span> hour)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hour = hour;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minute;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMinute</span><span class="params">(<span class="type">int</span> minute)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.minute = minute;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSecond</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(<span class="type">int</span> second)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//显示时间结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getHour() + <span class="string">&quot; : &quot;</span> + getMinute() + <span class="string">&quot; : &quot;</span> + getSecond());</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//显示运算结果</span></span><br><span class="line">  	<span class="comment">//type 0代表加，1代表减</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dispaly</span><span class="params">(MyTime time1, MyTime time2, <span class="type">int</span> type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(time1.getHour() + <span class="string">&quot; : &quot;</span> + time1.getMinute() + <span class="string">&quot; : &quot;</span> + time1.getSecond() + <span class="string">&quot; + &quot;</span> + time2.getHour() + <span class="string">&quot; : &quot;</span> + time2.getMinute() + <span class="string">&quot; : &quot;</span> + time2.getSecond());</span><br><span class="line">            time1.add(time2);</span><br><span class="line">            time1.display();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(time1.getHour() + <span class="string">&quot; : &quot;</span> + time1.getMinute() + <span class="string">&quot; : &quot;</span> + time1.getSecond() + <span class="string">&quot; - &quot;</span> + time2.getHour() + <span class="string">&quot; : &quot;</span> + time2.getMinute() + <span class="string">&quot; : &quot;</span> + time2.getSecond());</span><br><span class="line">            time1.sub(time2);</span><br><span class="line">            time1.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//时间相加操作</span></span><br><span class="line">  	<span class="comment">//直接让两个属性相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MyTime time)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setSecond(<span class="built_in">this</span>.getSecond() + time.getSecond());</span><br><span class="line">        <span class="built_in">this</span>.setMinute(<span class="built_in">this</span>.getMinute() + time.getMinute());</span><br><span class="line">        <span class="built_in">this</span>.setHour(<span class="built_in">this</span>.getHour() + time.getHour());</span><br><span class="line">        trans(<span class="built_in">this</span>);<span class="comment">//增加之后使其合法</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//时间相减操作</span></span><br><span class="line">  	<span class="comment">//直接让两个属性相减</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sub</span><span class="params">(MyTime time)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setHour(<span class="built_in">this</span>.getHour() - time.getHour());</span><br><span class="line">        <span class="built_in">this</span>.setMinute(<span class="built_in">this</span>.getMinute() - time.getMinute());</span><br><span class="line">        <span class="built_in">this</span>.setSecond(<span class="built_in">this</span>.getSecond() - time.getSecond());</span><br><span class="line">        trans(<span class="built_in">this</span>);<span class="comment">//减完之后使其合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

































]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2022/11/14/%E7%AE%97%E6%B3%95/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 1 开始的整数数组<code>numbers</code> ，该数组已按<u>非递减顺序排列</u>，请你从数组中找出满足相加之和等于目标数<code>target</code>的两个数。如果设这两个数分别是<code>numbers[index1]</code>和<code>numbers[index2]</code>，则<code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code>。</p>
<p>你可以假设每个输入 只对应唯一的答案 ，而且你不可以重复使用相同的元素。</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个问题可以等价于先固定<code>numbers[index1]</code>这个数，要求我们在数组中找到<code>target-numbers[index1]</code>这个数的下标。由于当前的数组是有序的，所以我们首先考虑到通过二分法来解决这个问题。为了避免重复，我们可以每次在numbers[index1]这个数右边寻找。</p>
<ul>
<li>采用这种方法时，<code>index1</code>的下标需要将整个数组遍历一遍来确定第一个数，在<code>index1</code>遍历的一轮中，对剩下的数采用二分法来查找<code>index2</code>，一轮二分法查找需要$O(logN)$的时间，而一共需要$N$轮，总的时间复杂度为$O(NlogN)$</li>
<li>这种方法不需要申请额外的辅助空间，空间复杂度为$O(1)$</li>
<li>注意：如果将二分查找封装成一个函数，那么可能会因为频繁调用函数而造成超时</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; index1 &lt; numbers.length; index1++) &#123;</span><br><span class="line">            low = index1 + <span class="number">1</span>;</span><br><span class="line">            high = numbers.length - <span class="number">1</span>;</span><br><span class="line">          	<span class="comment">//在每一轮中采用二分法来查找</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                mid = low + ((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (numbers[index1] + numbers[mid] &gt; target) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[index1] + numbers[mid] &lt; target)&#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    index2 = mid;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;++index1,++index2&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;<span class="comment">//否则查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="针对上述方法的优化"><a href="#针对上述方法的优化" class="headerlink" title="针对上述方法的优化"></a>针对上述方法的优化</h3><p>我们仔细思考可以发现，如果当<code>index1</code>过小，以至于index2指向数组中最末尾的数时，它们的二者之和也不能大于或者等于<code>target</code>时，那么就可以直接略过这一轮，直接对下一个更大的<code>index1</code>进行查找</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; index1 &lt; numbers.length; index1++) &#123;</span><br><span class="line">            low = index1 + <span class="number">1</span>;</span><br><span class="line">            high = numbers.length - <span class="number">1</span>;</span><br><span class="line">          	<span class="comment">//如果index1和数组中最大的数相加都小了，则直接跳过这一轮</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[index1] + numbers[high] &lt; target)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                mid = low + ((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (numbers[index1] + numbers[mid] &gt; target) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[index1] + numbers[mid] &lt; target)&#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    index2 = mid;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;++index1,++index2&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>使用双指针的方法，初始化时低位的指针指向最左边的元素，高位的指针指向最右边的元素，判断这二者之和与<code>target</code>的关系，如果大了，则代表<code>high</code>指针指向的元素过大，<code>high</code>指针左移。如果小了，则代表<code>low</code>指针指向的元素过小，low<code>指针</code>右移。如果刚好等于，则输出<code>low</code>和<code>high</code>指针即可。</p>
<p>这里我们会疑惑，这样的移动会不会造成正确答案被我们遗漏。我们假定<code>numbers[i]+numbers[j]=target</code>.初始时两个指针分别指向下标<code>0</code>和下标<br><code>numbers.length−1</code>，左指针指向的下标小于或等于 <code>i</code>，右指针指向的下标大于或等于 <code>j</code>。除非初始时左指针和右指针已经位于下标<code>i</code>和<code>j,</code>否则一定是左指针先到达下标<code>i</code>的位置或者右指针先到达下标<code>j</code> 的位置。<br>如果左指针先到达下标<code>i</code>的位置，此时右指针还在下标<code>j</code> 的右侧，因此一定是右指针左移，左指针不可能移<code>i</code>的右侧。对应的同理。由此可见，在整个移动过程中，左指针不可能移到<code>i</code>的右侧，右指针不可能移到<code>j</code> 的左侧，因此不会把可能的解过滤掉。由于题目确保有唯一的答案，因此使用双指针一定可以找到答案。</p>
<ul>
<li>这种方法时间只用遍历一遍数组，时间复杂度是$O(N)$</li>
<li>空间复杂度显然是$O(1)$</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[low] + numbers[high];</span><br><span class="line">        <span class="keyword">while</span>(sum != target)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                high --;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low ++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum = numbers[low] + numbers[high];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;++low,++high&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/2022/11/19/%E7%AE%97%E6%B3%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组<code>prices</code>其中<code>prices[i]</code>表示某支股票第<code>i</code>天的价格。在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。返回你能获得的最大利润 。</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="动态规划的思想"><a href="#动态规划的思想" class="headerlink" title="动态规划的思想"></a>动态规划的思想</h4><p>动态规划的思想是：给定一个问题，我们把它拆成一个个<u>子问题</u>，直到子问题可以直接解决。然后，把子问题答案<u>保存起来</u>，以减少重复计算。再根据子问题答案反推，得出原问题解。</p>
<p>其核心就是：<strong>拆分子问题，记住过往，减少重复计算</strong></p>
<p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后发现存在重叠子问题，就可以考虑使用动态规划。</p>
<h4 id="动态规划问题的解决思路"><a href="#动态规划问题的解决思路" class="headerlink" title="动态规划问题的解决思路"></a>动态规划问题的解决思路</h4><p>动态规划问题的解题步骤主要的有两步</p>
<ol>
<li><strong>状态定义</strong><ul>
<li>每一个子问题的求解就能获得一个状态，这个状态可以是当前最长的路径、最大的利润。而状态转移方程</li>
</ul>
</li>
<li><strong>状态转移方程</strong><ul>
<li>而从之前已知的状态递推到待求解的目标值这个状态上，我们需要为其规划一个最优的路线，这个状态的转变的路线就称为状态转移方程。</li>
</ul>
</li>
<li>确定边界条件<ul>
<li>边界条件也就是整个状态转移方程的初始值，只有确定边界条件后才可以使整个递推的状态转移方程运算起来，求得任意状态下的目标值</li>
</ul>
</li>
</ol>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>回到这道题，我们可以列举出每天可能获得的最大利润。这些最大利润之间必然存在关联与重叠，比如要想要通过卖股票增加利润，那么就必须在前几天购入这只股票，然后在前几天购入这只股票会让前几天的利润减少。也就是说，这个问题可以被分成一个个相互重叠的子问题。</p>
<p>其次，每天的利润是可以被穷尽的。因为每天的状态是有穷尽的，要么买、要么卖、要么没有动作，然后因为天数也是有限的，也就是说每个子问题的状态是有限的。所以这道题是可以采用动态规划的方法来解决的。</p>
<p>那么一旦确定要使用动态规划的思想去解决问题，我们就可以按照上述的两个步骤来继续思考。</p>
<ol>
<li><p>首先是确定子问题的状态。我认为对状态的定义是解决一道题的关键，并且这个步骤是非常需要技巧和经验的。针对这道题，我们可以把每天获得的最大利润定义为一个状态，也可以把每天的行为定义成一个状态。</p>
<p>我在一开始的时候尝试用第一个思路，即把每天的最大利润定义成一个状态，<code>profit[i]</code>表示每天最大的利润，但我发现这样的话去推导状态转移方程会十分的麻烦。我们一方面需要考虑当天的情况，另一方面还需要不停的回顾之前的情况，比如前几天去买股票、买了股票之后持有的那几天里的利润又不能改变等等。</p>
<p>但是当我们把状态定义为每天的交易情况后题目就瞬间变得容易起来。</p>
<p>我们定义<code>profit[i][]</code>这个二维数组为第<code>i</code>天的状态，<code>dp[i][0]</code>表示第<code>i</code>天交易完之后手里没有股票的最大利润，<code>dp[i][1]</code>表示第<code>i</code>天交易完之后手里持有股票的最大利润</p>
</li>
<li><p>接下来就是求状态转移方程，找到状态与状态之间的关系</p>
<ul>
<li><p>当天交易完之后手里没有股票可能有两种情况</p>
<ul>
<li>一种是当天没有进行任何交易，又因为当天手里没有股票，所以当天没有股票的利润只能取前一天手里没有股票的利润</li>
<li>另一种是把当天手里的股票给卖了，既然能卖，说明手里是有股票的，所以这个时候当天没有股票的利润要取前一天手里有股票的利润加上当天股票能卖的价格。这两种情况我们取利润最大的即可</li>
<li>所以可以得到：<code>profit[i][0] = max(profit[i-1][0],profit[i-1][1] + prices[i])</code></li>
</ul>
</li>
<li><p>当天交易完之后手里持有股票也有两种情况</p>
<ul>
<li><p>一种是当天没有任何交易，又因为当天手里持有股票，所以当天手里持有的股票其实前一天就已经持有了。</p>
</li>
<li><p>还一种是当天买入了股票，当天能买股票，说明前一天手里肯定是没有股票的，我们取这两者的最大值</p>
</li>
<li><p>所以可以得到:<code>profit[i][1] = max(profit[i-1][1],profit[i-1][0] - prices[i]);</code></p>
</li>
</ul>
</li>
<li><p>这样每一天的状态仅仅与前面一天有关，不用再考虑几天前的情况</p>
</li>
</ul>
</li>
<li><p>当然还要确定整个问题的边界条件，即<code>profit[1][0]</code>和<code>profit[1][1]</code></p>
<ul>
<li><code>profit[1][0] = 0</code>，<code>profit[1][1] = -prieces[0]</code></li>
</ul>
</li>
</ol>
<ul>
<li>时间复杂度：每天只有两种状态，所以时间复杂度是$O(2N)$</li>
<li>空间复杂度：我们需要申请$O(2N)$来存储状态信息</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">//记录每一天的最大利润</span></span><br><span class="line">        <span class="type">int</span>[][] profit = <span class="keyword">new</span> <span class="title class_">int</span>[days][<span class="number">2</span>];</span><br><span class="line">        profit[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> - prices[<span class="number">0</span>];</span><br><span class="line">        profit[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; days; i++) &#123;</span><br><span class="line">            profit[i][<span class="number">0</span>] = max(profit[i-<span class="number">1</span>][<span class="number">0</span>],profit[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            profit[i][<span class="number">1</span>] = max(profit[i-<span class="number">1</span>][<span class="number">1</span>],profit[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//最后一天肯定是手里没有股票的时候，利润才会最大，</span></span><br><span class="line">   		 	<span class="comment">//只需要返回dp[length - 1][0]即可</span></span><br><span class="line">        <span class="keyword">return</span> profit[days-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题可以将每天的价格趋势画成一张图</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8aqljjgbmj30y10u0wg5.jpg"></p>
<p>我们不难发现，最后获得的利润最大值就是所有上升区间的和。</p>
<p>但是我在思考这道问题的时候会有疑惑，有如下这种情况：</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8aqng6o7ej30zp0qwwfr.jpg"></p>
<p>即一次到位的绿色部分的高度大于中间有转折的黄色部分，对应着时机情况就是：先涨，但跌了一些，最后又涨，一直拿在手里不卖比见涨就买，见跌就卖的利润更高。但通过图示可以很清晰的发现，黄色部分的长度是肯定大于绿色部分的，因此这道题可以等价于：<strong>求上升区间的累加和</strong>，其实这也有一些贪心算法的思想在里面。</p>
<ul>
<li>时间复杂度：我们只需要遍历一遍数组，求出所有上升区间累加和即可，因此时间复杂度是$O(N)$</li>
<li>空间复杂度：在这种方法里我们不需要申请辅助空间，空间复杂度为$O(1)$</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (days == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> profit; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; days; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dif</span> <span class="operator">=</span> prices[i] - prices[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dif &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                profit = profit + dif;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

































]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串中的单词</title>
    <url>/2022/11/16/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串 <code>s</code> ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul>
<li><p>在Java中处理字符串常用的有三种类型：<code>String</code>、<code>StringBuffer</code>以及<code>StringBuilder</code>。这里我们着重介绍前两种</p>
<ol>
<li><code>String</code>和<code>StringBuffer</code>都是由final所修饰的，无法再被继承</li>
<li>它们的主要区别是：<code>String</code>的长度和内容是不可变的，<code>StringBuffer</code>的长度和内容是可变的</li>
<li><code>String</code>是不可变的对象，每次对<code>String</code>类进行改变时都会生成一个新的<code>String</code>类对象，然后将引用指向新的对象。因此如果需要改变字符串的长度，我们通常不会使用<code>String</code>类</li>
<li>使用<code>StringBuffer</code>时，我们每次都会对<code>StringBuffer</code>对象本身进行操作，而不会生成一个新的对象。当需要经常需要修改字符串时，我们推荐使用<code>StringBuffer</code>类</li>
</ol>
</li>
<li><p>遍历字符串<code>String</code>的方式</p>
<ol>
<li><p>调用<code>String</code>类的<code>toCharArray()</code>方法，先将字符串转变成一个字符数组，然后遍历数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;This is Kevin&#x27;s Blog&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] arr = str.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>String</code>类的<code>charAt(int i)</code>方法，在遍历字符串的过程中，每扫描到下标为<code>i</code>的一个字符就将它提取出来变成字符类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;This is Kevin&#x27;s Blog&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length()l i++)&#123;</span><br><span class="line">  System.out.print(str.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，获得字符串的长度时需要使用<code>String</code>类的<code>length()</code>方法，而获得数组的长度时可以直接方法数组中的<code>length</code>属性</p>
</li>
<li><p>调用<code>String</code>类的<code>subString(i,i+1)</code>方法，将字符串中的每个字符按照子串的形式提取出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;This is Kevin&#x27;s Blog&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length()l i++)&#123;</span><br><span class="line">  System.out.print(str.subString(i,i+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>s = str.substring(int beginIndex)</code>：将<code>str</code>从首字母起长度为<code>beginIndex</code>的字符串截取下来，将剩余的部分赋值给s</li>
<li><code>s = str.substring(int beginIndex,int endIndex)</code>：将str中下标从beginIndex到<code>endIndex</code>之间的字符串截取下来给s</li>
</ul>
</li>
</ol>
</li>
<li><p><code>StringBuffer</code>常用操作</p>
<ol>
<li><p><code>StringBuffer append(char c)</code>：添加字符<code>c</code>到<code>StringBuffer</code>对象中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">str.append(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"><span class="comment">//str = &quot;abcd&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>StringBuffer deleteCharAt(int index)</code>：移除下标为<code>index</code>的字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">str.deleteCharAt(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//str = &quot;ab&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>StringBuffer delete(int start,int end)</code>：移除下标从<code>start</code>到<code>end</code>之间的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line">str.delete(<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//str = &quot;def&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>String toString()</code>：将<code>StringBuffer</code>转换成<code>String</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> str.toString();</span><br><span class="line"><span class="comment">//s = &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>StringBuffer reverse()</code>：将此<code>StringBuffer</code>逆序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">str.reverse();</span><br><span class="line"><span class="comment">//str = &quot;cba&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>开辟一个新字符串<code>res</code>。扫描原来的字符串s，每扫描到一个新的单词，就暂停扫描，先将扫描到的单词逆序放到<code>res</code>，然后再继续向后扫描。为了达到这个效果我们需要两个指针，一个指针控制字符串<code>s</code>的扫描，另一个指针记录每个单词起始的位置。由于我们需要不停的增加<code>res</code>中的内容，所以考虑申请<code>StringBuffer</code>类型的<code>res</code>，每次添加新的单词时调用<code>append(char c)</code>方法</p>
<ul>
<li>时间复杂度$O(N)$</li>
<li>空间复杂度$O(N)$，由于在Java中字符串类型是不能修改的，所以无法做到原地工作</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//申请StringBuffer类型的辅助空间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于遍历整个字符串</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">//不采用for循环是因为循环控制语句不好设置，在扫描s字符串时，有很多情况下都会导致继续向前扫描</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">startWord</span> <span class="operator">=</span> i;<span class="comment">//一个指向单词的首字母的指针，记录下每个单词的起始位置</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//在while循环中，如果使用短路与的判断的话，优先将更重要的条件放到第一个表达式是位置，这样更安全，避免index溢出</span></span><br><span class="line">            <span class="comment">//如果扫描到的是正常的字母，则继续向后扫描，尝试找到一整个单词</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳出循环代表一个单词结束，或者遍历完了整个数组</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>;<span class="comment">//记录下一个单词最后的字母下标</span></span><br><span class="line">            <span class="comment">//不需要再设置一个逆序函数，让整个单词逆序后再加入res</span></span><br><span class="line">          	<span class="comment">//直接从后向前扫描，将后面的字母放到前面去即可</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= startWord)&#123;</span><br><span class="line">                res.append(s.charAt(j--));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//可能一个单词之后有多个空格</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                res.append(<span class="string">&#x27; &#x27;</span>);<span class="comment">//每扫描到一个空格，那就加一个空格</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//由于方法的返回值类型是String，最后还需要进行一下类型转换</span></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>调试过程我发现，在使用短路与时<code>while(i &lt; s.length() &amp;&amp; s.charAt(i) != &#39; &#39;)</code>，如果将<code>s.charAt(i) != &#39; &#39;</code>放在表达式1的位置，很容易编译器报错。</p>
<p>假设此时已经遍历完字符串中的最后一个字符(<code>i=s.length</code>)按照我们的设计，下一轮应该直接跳出循环。从逻辑上表达式1和表达式2的位置不是很重要，如果<code>s.charAt(i) != &#39; &#39;</code>放在表达式1的位置，<code>i=s.length</code>，那么程序会先判断<code>s.charAt(i) != &#39; &#39;</code>，在判断过程中就会发生下标越界的错误。但是如果<code>i &lt; s.length()</code> 放在表达式1的位置，在判断过程中不会报错，而会根据表达式结果直接跳出循环！</p>
<p>因此在之后设计下标的逻辑判断时，优先判断下标关系！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>存在重复元素</title>
    <url>/2022/11/21/%E7%AE%97%E6%B3%95/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code></p>
<h2 id="方法一：利用排序"><a href="#方法一：利用排序" class="headerlink" title="方法一：利用排序"></a>方法一：利用排序</h2><p>在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。</p>
<p>在进行排序时，我们其实可以先导入<code>java.util.Arrays</code>的包，直接利用<code>sort</code>方法进行排序</p>
<ul>
<li>时间复杂度：$O(NlogN)$，排序的时间复杂度</li>
<li>空间复杂度：$O(logN)$，快排的递归深度</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i-<span class="number">1</span>]) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题并不能通过位运算的技巧来快速解决，通过排序解决应该是最简单的办法</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组</title>
    <url>/2022/11/08/%E7%AE%97%E6%B3%95/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h1><p align="right">11.8</p>

<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>



<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>最直观的方法是直接计算出<code>nums</code>数组中每个元素新位置的下标<code>i</code>，把这些元素按照新的下标位置重新摆放到一个新的数组<code>arr</code>中。当<code>nums</code>数组中的每个元素都计算出新的下标位置后，再将整个<code>arr</code>数组重新拷贝回<code>nums</code>数组中即可</p>
<ul>
<li>这种方法因为需要遍历整个数组，所以它的时间复杂度是$O(n)$</li>
<li>又因为这种方法需要计算好每个nums数组中元素的新位置后，才能进行拷贝操作，所以它的空间复杂度也是$O(n)$</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];<span class="comment">//申请的辅助空间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newPosition</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录每个元素在轮转之后的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++) &#123;<span class="comment">//遍历整个数组，计算每个元素的新下标</span></span><br><span class="line">            newPosition = (i + k) % nums.length;</span><br><span class="line">            arr[newPosition] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新数组拷贝至原数组</span></span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>该方法非常容易想到，并且实现起来也很容易，但在这里需要说明一下Java语言中数组拷贝的方法<sup><a href="#ref1">[1]</a></sup></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos, Object dest, <span class="type">int</span> desPos, <span class="type">int</span> length)</span></span><br><span class="line"><span class="comment">//形参列表的含义</span></span><br><span class="line"><span class="comment">//（原数组，原数组的开始位置，目标数组，目标数组的开始位置，拷贝元素个数）</span></span><br><span class="line"><span class="comment">//其中目标数组是要拷贝到的数组</span></span><br></pre></td></tr></table></figure>

<p><code>System.arraycopy()</code>方法是本地的方法，不需要导入任何包，其余的方法大多是基于该方法而实现的，因此在这里着重介绍一下这个方法。</p>
<p>当使用这个方法的时候，需要复制到一个已经分配内存单元的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用法示例：</span></span><br><span class="line"><span class="type">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">System.arraycopy(a1, <span class="number">1</span>, a2, <span class="number">3</span>, <span class="number">3</span>);<span class="comment">//将a1从第一个位置开始，拷贝3个数，到a2的第三个数后面</span></span><br><span class="line">System.out.println(Arrays.toString(a1)); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">System.out.println(Arrays.toString(a2)); <span class="comment">// [0, 0, 0, 2, 3, 4, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>在方法一的基础上，我们可以尝试尽量减少辅助空间的使用。</p>
<p>我们发现，之所以要申请辅助空间，是因为拷贝数组过程中会覆盖原数据。按照这个思路，我们不难发现在拷贝数组时，有些数据其实我们是允许它们被覆盖的，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p>我们将输出的部分分成两段<code>[5,6,7]</code>以及<code>[1,2,3,4]</code>，我们可以先只将<code>[5,6,7]</code>挪到辅助数组里，允许<code>[1,2,3,4]</code>覆盖掉后面的内容，最后将辅助数组中的内容再拷贝到前面空缺的地方。按照这样的思路，<code>arr</code>数组的就不需要是备份整个nums数组，而是将<code>nums</code>数组一分为二，备份其中较小的一段即可。</p>
<ul>
<li>这种方法在拷贝数组的过程中还是遍历了整个数组，所以它的时间复杂度是$O(n)$</li>
<li>这种方法所申请的辅助空间虽然只需要备份数组中一部分的内容，但是它的空间复杂度还是与问题规模$n$成正比，空间复杂度还是$O(n)$</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">      	<span class="keyword">if</span>(k == <span class="number">0</span>)<span class="comment">//这种情况下不需要操作</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//辅助数组的大小</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; (nums.length-k))&#123;<span class="comment">//移动的距离超过数组的一半</span></span><br><span class="line">            length = nums.length-k;<span class="comment">//拷贝后半部分</span></span><br><span class="line">            <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">            <span class="comment">//将少的那一部分（后半部分）拷贝到arr中</span></span><br><span class="line">            System.arraycopy(nums, <span class="number">0</span>, arr, <span class="number">0</span>, length);</span><br><span class="line">            <span class="comment">//将前半部分直接后移到目标位置</span></span><br><span class="line">            System.arraycopy(nums, length, nums, <span class="number">0</span>, k);</span><br><span class="line">            <span class="comment">//将arr数组移动到前面空缺的位置</span></span><br><span class="line">            System.arraycopy(arr, <span class="number">0</span>, nums, k, length);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//移动的距离小于数组的一半</span></span><br><span class="line">            length = k;<span class="comment">//拷贝后半部分</span></span><br><span class="line">            <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">            <span class="comment">//同理</span></span><br><span class="line">            System.arraycopy(nums, nums.length-k, arr, <span class="number">0</span>, k);</span><br><span class="line">            System.arraycopy(nums, <span class="number">0</span>, nums, k, nums.length-k);</span><br><span class="line">            System.arraycopy(arr, <span class="number">0</span>, nums, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>在方法二的基础上，我们其实已经发现，旋转数组后会将原来的数组分成两个部分。</p>
<p>按照这个思路，我们可以继续探索这其中的规律：当我们将数组的元素向右移动 <em>k</em> 次后，尾部<code>k</code>个元素会移动至数组头部，其余元素向后移动<code>k</code>个位置。</p>
<p>这种效果等价于：我们先将这个数组进行逆序反转，然后再逆序反转前一部分，以及后一部分，我们还是以杠杠的例子做展示：</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">原始数组</td>
<td align="center"><code>1,2,3,4,5,6,7</code></td>
</tr>
<tr>
<td align="center">逆序</td>
<td align="center"><code>7,6,5,4,3,2,1</code></td>
</tr>
<tr>
<td align="center">翻转<code>[0,3]</code>上的元素</td>
<td align="center"><code>[5,6,7],[4,3,2,1]</code></td>
</tr>
<tr>
<td align="center">翻转[4,7]上的元素</td>
<td align="center"><code>[5,6,7],[1,2,3,4]</code></td>
</tr>
</tbody></table>
<ul>
<li>这个方法需要将每个元素都翻转两边，因此时间复杂度是$O(n)$</li>
<li>这个方法没有申请任何多余的辅助空间，因此空间复杂度是$O(1)$</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)<span class="comment">//这种情况下不需要操作</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">        reverse(nums,<span class="number">0</span>,(nums.length-<span class="number">1</span>));<span class="comment">//逆序整个数组</span></span><br><span class="line">        reverse(nums,<span class="number">0</span>,k-<span class="number">1</span>);<span class="comment">//逆序前半部分</span></span><br><span class="line">        reverse(nums,k,(nums.length-<span class="number">1</span>));<span class="comment">//逆序后半部分</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组nums下标为a到b之间的数进行交换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= (b-a)/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            swap(nums, (a+i), (b-i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换两个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == b)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        nums[a] = nums[a] ^ nums[b];</span><br><span class="line">        nums[b] = nums[a] ^ nums[b];</span><br><span class="line">        nums[a] = nums[a] ^ nums[b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h2><p>方法四是我在看了参考答案后才明白的一种方法，借助移动过程中的数学推导，该方法也可以用$O(1)$的空间复杂度解决这个问题，但由于时间问题今天就不再整理了！回去休息了！</p>
<p>Reference <a name="ref1"><font color="black">[1]https://blog.csdn.net/u011669700/article/details/79323251</font></a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组2</title>
    <url>/2022/11/20/%E7%AE%97%E6%B3%95/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%842/</url>
    <content><![CDATA[<h1 id="旋转数组2"><a href="#旋转数组2" class="headerlink" title="旋转数组2"></a>旋转数组2</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组，将数组中的元素向右轮转<code>k</code>个位置，其中<code>k</code>是非负数</p>
<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>在这之前我们已经能用两种方法解决这个问题，分别是申请辅助空间和翻转数组这两种方法。这次的方法是<strong>环状替换</strong>法。</p>
<p>方法一中使用额外数组的原因在于如果我们直接将每个数字放至它最后的位置，这样被放置位置的元素会被覆盖从而丢失。因此，从另一个角度，我们可以仅仅将被替换的<u>那一个元素</u>保存在变量<code>temp</code>中，从而避免了额外数组的开销。在这种方法里，每一轮可以确定一个数<code>a</code>的最终位置<code>b</code>，我们先将数<code>b</code>拷贝出来，这样就能避免等下将<code>a</code>放过来时覆盖了<code>b</code>的信息，拷贝好信息后我们就能将<code>a</code>直接放过去。然后在下一轮中，我们可以再去考虑<code>b</code>的最终位置，假设是<code>b&#39;</code>，然后不停的重复上述过程。</p>
<p>具体来说，我们不妨假设一个很长的数组向右移动3个位置。我们从位置<code>0</code>开始，根据规则，位置<code>0</code>的元素将会被放置到<code>(0+3)%n=3</code>的位置上，我们先拷贝这个位置上的元素到临时变量temp里，然后将<code>0</code>位置的元素直接放过来，这样就确定了0位置元素的最终位置。然后我们再考虑位置<code>3</code>的元素的最终位置，它的最终位置是<code>6</code>，我们先拷贝<code>6</code>位置元素的信息，然后再把3位置的元素放过来…以此类推。</p>
<p>容易发现，当回到初始位置<code>0</code>时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们可以设置一个计数器，每确定好一个数的最终位置，计数器就加一，当计数器的数量刚好等于数组中的元素个数时程序就可以结束了。</p>
<p>###代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录交换了多少个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//从第一个数开始交换</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt; nums.length) &#123;<span class="comment">//直到所有的数都交换了一遍</span></span><br><span class="line">        <span class="comment">//注意，判断循环结束的条件不能加等号</span></span><br><span class="line">        <span class="comment">//移动了一个数，计数器才加一，如果等于了还进入循环的话，就会移动length+1个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[start];<span class="comment">//存储上一轮的b</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">toSwap</span> <span class="operator">=</span> (start + k) % nums.length;<span class="comment">//找到a下一个要交换的数b的下标</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(toSwap != start)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[toSwap];<span class="comment">//将b拷贝出来，因为等下a要覆盖它</span></span><br><span class="line">                nums[toSwap] = pre;<span class="comment">//将a（也就是上一轮的b）放到它的位置上</span></span><br><span class="line"></span><br><span class="line">                pre = temp;<span class="comment">//这一轮的b成为下一轮的a</span></span><br><span class="line">                toSwap = (toSwap + k) % nums.length;<span class="comment">//找到下一轮b的位置</span></span><br><span class="line">                count ++;<span class="comment">//找到了一个数a的最终位置</span></span><br><span class="line">            &#125;</span><br><span class="line">          	</span><br><span class="line">            nums[toSwap] = pre;<span class="comment">//当下一个位置与初始位置相同时，将上一轮的数放到初始位置</span></span><br><span class="line">            count ++;</span><br><span class="line">            start ++;<span class="comment">//从下一个数再开始</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>对数器和比较器</title>
    <url>/2022/11/07/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%BE%83%E5%99%A8%20&amp;%20%E5%AF%B9%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<h1 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h1><ul>
<li>用自己产生随机数的方法来检验自己的编写算法是否正确</li>
<li>现有两个方法<ul>
<li>方法A：想要测试的目标方法</li>
<li>方法B：容易实现，但是性能较差的方法</li>
</ul>
</li>
<li>实现一个随机样本产生器，使A和B同时运行随机生成的样本，检查结果是否一致</li>
<li>若不一致，则可以使用print的方法进行人工干预</li>
</ul>
<h4 id="Java产生随机数"><a href="#Java产生随机数" class="headerlink" title="Java产生随机数"></a>Java产生随机数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.random()						<span class="comment">//[0,1)之间所有的小数，等概率的返回一个</span></span><br><span class="line">Math.random()*N					<span class="comment">//[0,N)之间所有的小数，等概率返回一个</span></span><br><span class="line">(<span class="type">int</span>)(Math.random()*N)	<span class="comment">//[o,N)之间所有的整数，等概率返回一个</span></span><br></pre></td></tr></table></figure>

<h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><ul>
<li>重载比较运算符</li>
<li>比较器可以很好的应用在特殊标准的排序上，因为我们可以自定义排序标准</li>
</ul>
<h5 id="自定义排序标准"><a href="#自定义排序标准" class="headerlink" title="自定义排序标准"></a>自定义排序标准</h5><ul>
<li><p><code>Arrays.sort()</code></p>
<ul>
<li><code>Arrays.sort()</code>重载了四类方法<ol>
<li><code>Arrays.sort(T[] a)</code>: 对指定的T型数组按数字升序排序</li>
<li><code>Arrays.sort(T[] a, int formIndex, int toIndex)</code>: 对指定的T型数组在下标[formIndex, toIndex]之间排序</li>
<li><code>Arrays.sort(T[] a, Comparator&lt;? supre T&gt; c)</code>: 根据比较器产生的顺序对指定对象数组进行排序</li>
<li><code>Arrasy.sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c</code>): …</li>
</ol>
</li>
</ul>
</li>
<li><p><code>Arrays.sort(T[] a)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">LENGTH</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">//产生长度为20的数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">30</span>;<span class="comment">//数组元素的值在[0,30)之间</span></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[LENGTH];</span><br><span class="line">    arr = randomGener(LENGTH,N);</span><br><span class="line">    System.out.print(<span class="string">&quot;随机产生的数组为：&quot;</span>);</span><br><span class="line">    display(arr);</span><br><span class="line">    Arrays.sort(arr);<span class="comment">//对arr进行升序排序</span></span><br><span class="line">    System.out.print(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">    display(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h83jzswsmnj31bi0hq0us.jpg"></p>
</li>
<li><p><code>Arrays.sort(T[] a, int formIndex, int toIndex)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[LENGTH];</span><br><span class="line">arr2 = randomGener(LENGTH,N);</span><br><span class="line">System.out.print(<span class="string">&quot;随机产生的数组为：&quot;</span>);</span><br><span class="line">display(arr2);</span><br><span class="line">Arrays.sort(arr2,<span class="number">0</span>,<span class="number">9</span>);<span class="comment">//只对前半部分进行排序</span></span><br><span class="line">System.out.print(<span class="string">&quot;只对前半部分排序后的数组为：&quot;</span>);</span><br><span class="line">display(arr2);</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h83k3fliumj31de0ca40d.jpg"></p>
</li>
<li><p><code>Arrays.sort(T[] a, Comparator&lt;? supre T&gt; c)</code>	</p>
</li>
<li><p><strong>注意这里的数据类型不能是基本数据类型</strong></p>
<ul>
<li>创建一个学生类，包含姓名、年级、年龄三个属性，分别对后两个属性进行升序和降序排序</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重载比较器</span></span><br><span class="line"><span class="comment">//按照 数据类型的属性a的升序排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> class 类名 <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;数据类型&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> 数据类型 compare(数据类型 o1, 数据类型 o2) &#123;</span><br><span class="line">    <span class="comment">//当返回值为负数时，第一个参数在前</span></span><br><span class="line">    <span class="comment">//当返回值为正数时，第二个参数在前</span></span><br><span class="line">    <span class="comment">//当返回值为0时，顺序无所谓</span></span><br><span class="line">    <span class="keyword">if</span>(o1.属性a &lt; o2.属性a)</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//第一个数先输出，第一个数小，所以时升序</span></span><br><span class="line">    <span class="keyword">if</span> (o1.属性a &gt; o2.属性a)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//第二个数先输出，第二个数小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Student;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentSort</span> &#123;</span><br><span class="line">    <span class="comment">//重载比较器</span></span><br><span class="line">    <span class="comment">//根据年级升序排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GradeAscendingComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(o1.grade &lt; o2.grade)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (o1.grade &gt; o2.grade)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载比较器</span></span><br><span class="line">    <span class="comment">//根据年龄降序排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AgeDescendingComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">//降序：大的先输出</span></span><br><span class="line">        <span class="comment">//o2&gt;o1，则先输出o2</span></span><br><span class="line">        <span class="comment">//o2&lt;o1，则先输出o1</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.age - o1.age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;aaa&quot;</span>,<span class="number">8</span>,<span class="number">20</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;bbb&quot;</span>,<span class="number">10</span>,<span class="number">15</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;ccc&quot;</span>,<span class="number">5</span>,<span class="number">21</span>);</span><br><span class="line"></span><br><span class="line">        Student[] stus = &#123;s1,s2,s3&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生信息为：&quot;</span>);</span><br><span class="line">        print(stus);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;按照年级升序排序的学生信息为：&quot;</span>);</span><br><span class="line">        Arrays.sort(stus,<span class="keyword">new</span> <span class="title class_">GradeAscendingComparator</span>());</span><br><span class="line">        print(stus);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;按照年龄降序排序的学生信息为：&quot;</span>);</span><br><span class="line">        Arrays.sort(stus,<span class="keyword">new</span> <span class="title class_">AgeDescendingComparator</span>());</span><br><span class="line">        print(stus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Student[] stus)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stus.length ; i++)&#123;</span><br><span class="line">            System.out.println(stus[i].name + <span class="string">&quot; &quot;</span> + stus[i].grade + <span class="string">&quot; &quot;</span> + stus[i].age);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h83kwq4abej30u00vkq4u.jpg"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>猜数游戏</title>
    <url>/2022/11/22/%E7%AE%97%E6%B3%95/%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="猜数游戏"><a href="#猜数游戏" class="headerlink" title="猜数游戏"></a>猜数游戏</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我在做Java一个简单的猜数游戏时突发奇想，能不能编写一个程序让计算机自己产生一个随机数，自己再猜。</p>
<h2 id="方法一：二分查找法"><a href="#方法一：二分查找法" class="headerlink" title="方法一：二分查找法"></a>方法一：二分查找法</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>解决这个问题很容易就能想到用二分查找来高效的解决，但是我在实际做的过程中发现自己对二分查找的理解还是差了一点。</p>
<p>先看看我的第一个版本的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">guessNum</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(flag &lt; <span class="number">0</span>)&#123;<span class="comment">//猜小了，则输出右半部分的中点</span></span><br><span class="line">    <span class="keyword">return</span> (mid + high) / <span class="number">2</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;<span class="comment">//猜大了，则输出左半部分的中点</span></span><br><span class="line">    <span class="keyword">return</span> (low + mid) / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (count &lt;= <span class="number">100</span> &amp;&amp; guess != numToguess)&#123;</span><br><span class="line">	<span class="keyword">if</span> (guess &gt; numToguess)&#123;</span><br><span class="line">		System.out.println(guess + <span class="string">&quot; 大于 &quot;</span> + numToguess + <span class="string">&quot;猜大了，请再试一次&quot;</span>);</span><br><span class="line">		guess = guessNum(<span class="number">1</span>,a,guess);</span><br><span class="line">		count ++;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(guess + <span class="string">&quot; 小于 &quot;</span> + numToguess + <span class="string">&quot;猜小了，请再试一次&quot;</span>);</span><br><span class="line">    a = guess;</span><br><span class="line">    guess = guessNum(-<span class="number">1</span>,guess,b);</span><br><span class="line">    count ++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找的精髓在于<u>每一次查找之后都能舍弃另一半的信息</u>，然而运行我上面的代码会发现，我每次猜测的数据都在左右不停的摇摆。</p>
<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8dp35qixlj30vm0midhs.jpg"></p>
<p>在熟悉通过数组来实现二分查找后，我发现自己并不能很轻松的解决这个问题，我开始思考原因。</p>
<p>在数组里之所以每次都能做到精确的划分出目标所在的区间，是因为我们巧妙的设置了<code>low</code>和<code>high</code>两个指针。每一次比较之后，都根据目标和中间数据的大小关系来调整<code>low</code>或者<code>high</code>指针，而每次查找的数据都是在<code>low</code>和<code>high</code>指针之间查找，并不会超过这个区域。也就是说，<u>二分查找之所以能每查找一轮都能舍弃另一半的原因，在于只在<code>low</code>和<code>high</code>指针之间查找，每查找一轮都要修改这个区间</u>。</p>
<p>那么想要解决我现在的问题我们就要重新检查我们是否真的发挥了<code>low</code>和<code>high</code>指针的作用。不难发现，在<code>guess = guessNum(1,a,guess);</code>和<code>guess = guessNum(-1,guess,b);</code>两个关键的划分区间的操作中，我的a和b指针从来都没有发生过改变，也就是查找的范围一直没有变：要么就在最左边查找、要么就在最右边查找，无法做到真正的二分。</p>
<p>要解决这个问题，我们只需要根据每一轮查到的结果来及时调整<code>low</code>或者<code>high</code>指针即可，以下是完整的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Random</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> random;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> low;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> high;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHigh</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.random;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRandom</span><span class="params">(<span class="type">int</span> random)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.random = random;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLow</span><span class="params">(<span class="type">int</span> low)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.low = low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHigh</span><span class="params">(<span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.high = high;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Random()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Random(<span class="type">int</span> random)&#123;</span><br><span class="line">        <span class="built_in">this</span>.random = random;</span><br><span class="line">    &#125;</span><br><span class="line">    Random(<span class="type">int</span> random, <span class="type">int</span> low, <span class="type">int</span> high)&#123;</span><br><span class="line">        <span class="built_in">this</span>.random = random;</span><br><span class="line">        <span class="built_in">this</span>.low = low;</span><br><span class="line">        <span class="built_in">this</span>.high = high;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//产生一个在low～high之间的随机数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">randGen</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数字区间&quot;</span>);</span><br><span class="line">        java.util.<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Scanner((System.in));</span><br><span class="line">        setLow(scanner.nextInt());</span><br><span class="line">        setHigh(scanner.nextInt());</span><br><span class="line">        <span class="type">int</span> <span class="variable">ran</span> <span class="operator">=</span> getLow() - <span class="number">1</span> + (<span class="type">int</span>)(Math.random() *(getHigh()-getLow()));</span><br><span class="line">        setRandom(ran);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//返回low与high的中点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mid</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span>.getLow() + <span class="built_in">this</span>.getHigh()) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">LIMIT_GUESS</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//控制猜测的次数，避免死循环</span></span><br><span class="line">    <span class="keyword">private</span> Random random;<span class="comment">//Random是Guess的一个属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Guess</span><span class="params">(Random random)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.random = random;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Random <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">guess</span><span class="params">()</span>&#123;</span><br><span class="line">        getRandom().randGen();<span class="comment">//产生随机数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">guess</span> <span class="operator">=</span> getRandom().mid();<span class="comment">//猜测中点的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt;= LIMIT_GUESS &amp;&amp; guess != getRandom().getRandom())&#123;</span><br><span class="line">            <span class="keyword">if</span> (guess &gt; getRandom().getRandom())&#123;</span><br><span class="line">                System.out.println(guess + <span class="string">&quot; 大于 &quot;</span> + getRandom().getRandom() + <span class="string">&quot;猜大了，请再试一次&quot;</span>);</span><br><span class="line">                getRandom().setHigh(guess);<span class="comment">//猜大了，则及时调整high指针</span></span><br><span class="line">                guess = getRandom().mid();</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(guess + <span class="string">&quot; 小于 &quot;</span> + getRandom().getRandom() + <span class="string">&quot;猜小了，请再试一次&quot;</span>);</span><br><span class="line">                getRandom().setLow(guess);<span class="comment">//猜小了，则及时调整low指针</span></span><br><span class="line">                guess = getRandom().mid();</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜！猜对了，是 &quot;</span> + guess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">Guess</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Guess</span>(random);</span><br><span class="line">        test.guess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h8dq3yz1rjj30vm0tutbc.jpg"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>移动零</title>
    <url>/2022/11/11/%E7%AE%97%E6%B3%95/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。<strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我最先联想到昨天做过的数组轮转问题，我每找到一个0，我就把这个0移动到数组的最后，这样的情况下前面的非零的数的顺序也不会有变化。</p>
<p>这是一个非常简单的想法，我再进步一的优化。每一次轮转也不需要轮转数组中的所有元素，只用把第一个为零的元素（前面的元素已经满足要求，不动即可）转移到最后一个不为0的元素（再后面的元素都为0也满足要求）之后就好了。我设置了两个指针low 和 high，分别指向第一个为0的元素，以及最后一个不为0的元素。</p>
<p>进一步我发现，high指针（从后往前找到第一个非零元素）其实不会怎么移动，每一轮下来要么不动（前面没有0，不需要轮转），要么就向前移动一个（一轮下来只会找到一个0）。然而low指针（从前往后找到第一个零元素）的移动跨度可能会非常大，每一轮都是在上一轮的基础上继续向后寻找，找下一个零元素。所以可以在流程开始之前就确定high指针的位置，然而low指针的位置就要根据每一轮动态的变化了。</p>
<p>在每一轮里，一旦low指针找到了一个0元素，那么就把low和high之间的元素左轮转一个位置，这样0元素就到了这个区间最后的位置，区间中的数相对位置不变的向前移动了一位。</p>
<p>一次轮转之后，high指针要前移一位（因为0元素被放到了最后），low指针不变（因为新向前移动的数还没有判断是否为0），所以我们要再次寻找下一个0元素。</p>
<ul>
<li>这种方法首先需要遍历一整遍数组，在每一轮中，一旦需要轮转元素，就又要遍历一遍这一轮的所有数，时间复杂度为$O(n^{2} )$，并且由于又要遍历数组，又要实现轮转，代码的长度也很长</li>
<li>由于不需要额外的辅助空间，空间复杂度为$O(1)$</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//low标记第一个为0的下标，high标记最后一个不为0的下标</span></span><br><span class="line">		<span class="comment">//确定high指针的位置</span></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[high] != <span class="number">0</span>) </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			high --;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">			<span class="comment">//i寻找从low 到 high 第一个0</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low;</span><br><span class="line">			<span class="keyword">while</span>(i &lt; high)&#123;</span><br><span class="line">				<span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">					low = i;</span><br><span class="line">					turnLeft(nums,low,high);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				i ++;</span><br><span class="line">			&#125;</span><br><span class="line">			high --;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//nums数组从i到j下标所有数向左轮转一位</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">turnLeft</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    	reverse(nums,i,j);</span><br><span class="line">    	reverse (nums,i,j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换nums数组中i和j两个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (i == j) </span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	nums[i] = nums[i] ^ nums[j];</span><br><span class="line">    	nums[j] = nums[i] ^ nums[j];</span><br><span class="line">    	nums[i] = nums[i] ^ nums[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使nums数组中i到j间的数逆序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    		swap(nums,i++,j--);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>双指针其实不一定要呆板的规定一个指针从前往后遍历，另一个从后往前遍历。我们可以根据不同的特点重新设置两个指针的功能，一般而言双指针可以将数组划分成三个部分，根据三个部分不同的功能再来设置指针的位置。</p>
<p>比如在这一题中，可以设置一个指针<code>right</code>指向已经整理过的非零数组的末尾，另一个指针left指向待处理的数。也就是说，<code>right</code>指针左边全部是非零元素，<code>left</code>指针右边全部是待处理的元素，<code>right</code>指针和left指针中间都是0</p>
<p><code>left</code>指针不停的向后移动，<code>left</code>指针每碰到一个数，如果这个数为0，那就跨过它继续向后找，同时<code>right</code>指针向后移动一位；如果不是0，就把它放到非0元素序列的末尾(right指针指向的地方)。</p>
<p>这样一方面确保了非零元素之间相对位置的有序（按照遍历到的顺序调整的数，所以调整之后也是有序的），并且两个指针移动的方向相同，只用遍历一遍数组，每一轮中也只用交换两个数的位置，操作更简单。</p>
<ul>
<li>这种方法只用遍历一遍数组，如果left指针遇到了非零数，也只用做简单的交换操作，时间复杂度为$O(n)$</li>
<li>空间复杂度为$O(1)$</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左指针指向非零元素的末尾</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//右指针指向待调整的数</span></span><br><span class="line">		<span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">      <span class="comment">//如果是0，则继续向后遍历</span></span><br><span class="line">      <span class="comment">//如果非0，则将其向前移动</span></span><br><span class="line">			<span class="keyword">if</span> (nums[right] != <span class="number">0</span> ) &#123;</span><br><span class="line">				swap(nums,left,right);</span><br><span class="line">				left ++;</span><br><span class="line">			&#125;</span><br><span class="line">			right ++;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换nums数组中i和j两个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (i == j) </span><br><span class="line">    		<span class="keyword">return</span>;</span><br><span class="line">    	nums[i] = nums[i] ^ nums[j];</span><br><span class="line">    	nums[j] = nums[i] ^ nums[j];</span><br><span class="line">    	nums[i] = nums[i] ^ nums[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2022/11/14/%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><ul>
<li>计数排序是一种<u>稳定</u>的排序算法。使用一个额外数组<code>C</code>，其中第<code>i</code>个元素是待排序数组<code>arr</code>中值等于<code>i</code>的元素个数，然后根据数组<code>C</code>来将<code>arr</code>中的元素放到正确的位置<ul>
<li>假设现在对学校里的所有学生按照年龄进行排序，则申请一个0到30的数组C</li>
<li>遍历一遍所有学生的年龄，如果一个学生的年龄是18，则<code>C[18]++</code></li>
<li>遍历结束后，顺序输出数组$i\times C[i]$即可</li>
</ul>
</li>
<li>它只能对整数进行排序</li>
<li>计数排序的核心在于：将输入的数据转化为键存储在额外开辟的数组空间中</li>
</ul>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countSotr</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//遍历数组，求数组的最大值和最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            max = (max &gt; nums[i]) ? max : nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组中所有的数的取值都比max小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> max + <span class="number">1</span>;<span class="comment">//申请的辅助空间的数组长度</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            arr[nums[i]]++;<span class="comment">//arr[i]存储着nums中值为i的元素的个数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指向nums数组的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[i] &gt; <span class="number">0</span>)&#123;<span class="comment">//使每一个arr[i]都输出完</span></span><br><span class="line">                nums[index] = i;</span><br><span class="line">                index ++;</span><br><span class="line">                arr[i] --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><ul>
<li>时间复杂度$O(n)$，由于计数排序不是比较排序，它的速度远快于任何排序算法</li>
<li>空间复杂度：计数排序中所使用的辅助空间与数组中的最大值有关，所以当数组中的数很大时，计数排序需要很夸张的辅助空间。</li>
<li>也因此，计数排序不适用于大部分的情况，但对于某些特定的情况，计数排序的效率会非常的高</li>
</ul>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">LENGTH</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[LENGTH];</span><br><span class="line">        nums = randomGen(LENGTH,MAX);</span><br><span class="line">        <span class="type">int</span>[] test = (<span class="type">int</span>[])Arrays.copyOf(nums,nums.length);</span><br><span class="line"></span><br><span class="line">        countSotr(nums);</span><br><span class="line">        Arrays.sort(test);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(nums,test))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;排序成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countSotr</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//遍历数组，求数组的最大值和最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            max = (max &gt; nums[i]) ? max : nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组中所有的数的取值都比max小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> max + <span class="number">1</span>;<span class="comment">//申请的辅助空间的数组长度</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            arr[nums[i]]++;<span class="comment">//arr[i]存储着nums中值为i的元素的个数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指向nums数组的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[i] &gt; <span class="number">0</span>)&#123;<span class="comment">//使每一个arr[i]都输出完</span></span><br><span class="line">                nums[index] = i;</span><br><span class="line">                index ++;</span><br><span class="line">                arr[i] --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomGen(<span class="type">int</span> length, <span class="type">int</span> max)&#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; length; i++)&#123;</span><br><span class="line">            nums[i] = (<span class="type">int</span>) (Math.random()*max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://tva1.sinaimg.cn/large/008vxvgGly1h84s2ozzlij30u60cyjs7.jpg"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
</search>
